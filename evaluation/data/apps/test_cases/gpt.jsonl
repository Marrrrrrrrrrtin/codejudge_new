{"task_id": "0015", "program": "a, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "problem": "Vasya likes everything infinite. Now he is studying the properties of a sequence s, such that its first element is equal to a (s_1 = a), and the difference between any two neighbouring elements is equal to c (s_{i} - s_{i} - 1 = c). In particular, Vasya wonders if his favourite integer b appears in this sequence, that is, there exists a positive integer i, such that s_{i} = b. Of course, you are the person he asks for a help.\n\n\n-----Input-----\n\nThe first line of the input contain three integers a, b and c ( - 10^9 \u2264 a, b, c \u2264 10^9)\u00a0\u2014 the first element of the sequence, Vasya's favorite number and the difference between any two neighbouring elements of the sequence, respectively.\n\n\n-----Output-----\n\nIf b appears in the sequence s print \"YES\" (without quotes), otherwise print \"NO\" (without quotes).\n\n\n-----Examples-----\nInput\n1 7 3\n\nOutput\nYES\n\nInput\n10 10 0\n\nOutput\nYES\n\nInput\n1 -4 5\n\nOutput\nNO\n\nInput\n0 60 50\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first sample, the sequence starts from integers 1, 4, 7, so 7 is its element.\n\nIn the second sample, the favorite integer of Vasya is equal to the first element of the sequence.\n\nIn the third sample all elements of the sequence are greater than Vasya's favorite integer.\n\nIn the fourth sample, the sequence starts from 0, 50, 100, and all the following elements are greater than Vasya's favorite integer.", "solution": "a,b,c = list(map(int,input().split()))\nif c == 0:\n    if b == a:\n        print('YES')\n    else:\n        print('NO')\nelif c > 0:\n    if b < a:\n        print('NO')\n    else:\n        if a%c == b%c:\n            print('YES')\n        else:\n            print('NO')\nelse:\n    if b > a:\n        print('NO')\n    else:\n        if a%c == b%c:\n            print('YES')\n        else:\n            print('NO')\n", "pass": true}
{"task_id": "0018", "program": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    s = list(s)\n    \n    while s or t:\n        if not t:\n            t.append(s.pop(0))\n        elif not s:\n            u.append(t.pop())\n        else:\n            if s[0] <= t[-1]:\n                t.append(s.pop(0))\n            else:\n                u.append(t.pop())\n    \n    return ''.join(u)\n\n# Read input\nimport sys\ninput = sys.stdin.read().strip()\n\n# Get the result\nresult = lexicographically_minimal_string(input)\n\n# Print the result\nprint(result)", "problem": "Petya recieved a gift of a string s with length up to 10^5 characters for his birthday. He took two more empty strings t and u and decided to play a game. This game has two possible moves:  Extract the first character of s and append t with this character.  Extract the last character of t and append u with this character. \n\nPetya wants to get strings s and t empty and string u lexicographically minimal.\n\nYou should write a program that will help Petya win the game.\n\n\n-----Input-----\n\nFirst line contains non-empty string s (1 \u2264 |s| \u2264 10^5), consisting of lowercase English letters.\n\n\n-----Output-----\n\nPrint resulting string u.\n\n\n-----Examples-----\nInput\ncab\n\nOutput\nabc\n\nInput\nacdb\n\nOutput\nabdc", "solution": "from queue import deque\n\ndp = {}\n\ndef sol_1():\n    idx = 0\n    while True:\n        min_idx = get_min_char_idx(s, idx)\n        if min_idx == -1:\n            break\n        if len(t) > 0 and ord(t[-1]) <= ord(s[min_idx]):\n            # we need to take t\n            u.append(t.pop())\n        else:\n            # take up to min_idx\n            t.extend(s[idx:min_idx+1])\n            idx = min_idx+1\n\ndef efficient_sol():\n    nonlocal u, t, s\n    import string\n    indices = {char: [] for char in string.ascii_lowercase}  # will hold indices for each char\n\n    # fill indices\n    for idx, char in enumerate(s):\n        indices[char].append(idx)\n\n    curr_idx = 0\n    for char in string.ascii_lowercase:\n        if curr_idx == len(s):\n            break\n        if len(t) > 0 and ord(char) >= ord(t[-1]):\n            # We've started searching for bigger characters, so we need to empty the smaller ones first\n            while len(t) > 0 and ord(char) >= ord(t[-1]):\n                u.append(t.pop())\n\n        for idx in sorted(indices[char]):\n            if curr_idx == len(s):\n                return\n            min_idx = idx\n            if min_idx < curr_idx:\n                # we've passed this character\n                continue\n            elif min_idx == curr_idx:\n                if len(t) > 0 and ord(char) > ord(t[-1]):\n                    raise Exception()\n                # we are at that character, so just add it\n                u.append(char)\n                curr_idx += 1\n                continue\n            # mid_idx is bigger, so we put everything up until this character in T\n            # then, add the character himself\n            t.extend(s[curr_idx:min_idx])\n            u.append(char)\n            curr_idx = min_idx + 1\n    while curr_idx < len(s):\n        pass\n\ndef get_min_char_idx(s: str, start_idx: int):\n    nonlocal dp\n    if start_idx >= len(s):\n        return -1\n    if start_idx in dp:\n        return dp[start_idx]\n    min_char = s[start_idx]\n    min_idx = start_idx\n    while start_idx < len(s):\n        if ord(s[start_idx]) < ord(min_char):\n            min_char = s[start_idx]\n            min_idx = start_idx\n        start_idx += 1\n    dp[start_idx] = min_idx\n    return min_idx\n\n# aaaczbgjs\nimport string\ns = input()\n# s = 'abcadc'\n# s = string.ascii_lowercase + string.ascii_lowercase\n\nu = []\nt = []\n\n# if len(s) >= 10**3:\nefficient_sol()\n# else:\n#     sol_1()\n\n# abaaabababacba\n# print(t)\nprint(''.join(u + list(reversed(t))))\n", "pass": false}
{"task_id": "0088", "program": "def count_years_with_one_zero(a, b):\n    def has_exactly_one_zero_in_binary(n):\n        binary_representation = bin(n)[2:]  # Get binary representation without '0b' prefix\n        return binary_representation.count('0') == 1\n\n    count = 0\n    for year in range(a, b + 1):\n        if has_exactly_one_zero_in_binary(year):\n            count += 1\n\n    return count\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(count_years_with_one_zero(a, b))", "problem": "The year 2015 is almost over.\n\nLimak is a little polar bear. He has recently learnt about the binary system. He noticed that the passing year has exactly one zero in its representation in the binary system\u00a0\u2014 2015_10 = 11111011111_2. Note that he doesn't care about the number of zeros in the decimal representation.\n\nLimak chose some interval of years. He is going to count all years from this interval that have exactly one zero in the binary representation. Can you do it faster?\n\nAssume that all positive integers are always written without leading zeros.\n\n\n-----Input-----\n\nThe only line of the input contains two integers a and b (1 \u2264 a \u2264 b \u2264 10^18)\u00a0\u2014 the first year and the last year in Limak's interval respectively.\n\n\n-----Output-----\n\nPrint one integer\u00a0\u2013 the number of years Limak will count in his chosen interval.\n\n\n-----Examples-----\nInput\n5 10\n\nOutput\n2\n\nInput\n2015 2015\n\nOutput\n1\n\nInput\n100 105\n\nOutput\n0\n\nInput\n72057594000000000 72057595000000000\n\nOutput\n26\n\n\n\n-----Note-----\n\nIn the first sample Limak's interval contains numbers 5_10 = 101_2, 6_10 = 110_2, 7_10 = 111_2, 8_10 = 1000_2, 9_10 = 1001_2 and 10_10 = 1010_2. Two of them (101_2 and 110_2) have the described property.", "solution": "def zero(strx):\n    k = []\n    str2 = list(strx)\n    for i in range(1, len(str2)):\n        str3 = str2[:]\n        str3[i] = '0'\n        k.append(''.join(str3))\n    return k\na = []\nfor i in range(1, 64):\n    a += zero('1'*i)\n\nct = 0\nx, y = list(map(int, input().split(' ')))\nfor i in a:\n    if x <= int(i, 2) <= y:\n        ct+=1\nprint(ct)\n", "pass": false}
{"task_id": "0165", "program": "b, d, s = map(int, input().split())\n\n# Find the maximum number of meals of any type\nmax_meals = max(b, d, s)\n\n# Calculate the minimum number of missed meals\nmissed_meals = max(0, (max_meals - 1 - b)) + max(0, (max_meals - 1 - d)) + max(0, (max_meals - 1 - s))\n\nprint(missed_meals)", "problem": "Vasiliy spent his vacation in a sanatorium, came back and found that he completely forgot details of his vacation! \n\nEvery day there was a breakfast, a dinner and a supper in a dining room of the sanatorium (of course, in this order). The only thing that Vasiliy has now is a card from the dining room contaning notes how many times he had a breakfast, a dinner and a supper (thus, the card contains three integers). Vasiliy could sometimes have missed some meal, for example, he could have had a breakfast and a supper, but a dinner, or, probably, at some days he haven't been at the dining room at all.\n\nVasiliy doesn't remember what was the time of the day when he arrived to sanatorium (before breakfast, before dinner, before supper or after supper), and the time when he left it (before breakfast, before dinner, before supper or after supper). So he considers any of these options. After Vasiliy arrived to the sanatorium, he was there all the time until he left. Please note, that it's possible that Vasiliy left the sanatorium on the same day he arrived.\n\nAccording to the notes in the card, help Vasiliy determine the minimum number of meals in the dining room that he could have missed. We shouldn't count as missed meals on the arrival day before Vasiliy's arrival and meals on the departure day after he left.\n\n\n-----Input-----\n\nThe only line contains three integers b, d and s (0 \u2264 b, d, s \u2264 10^18,  b + d + s \u2265 1)\u00a0\u2014 the number of breakfasts, dinners and suppers which Vasiliy had during his vacation in the sanatorium. \n\n\n-----Output-----\n\nPrint single integer\u00a0\u2014 the minimum possible number of meals which Vasiliy could have missed during his vacation. \n\n\n-----Examples-----\nInput\n3 2 1\n\nOutput\n1\n\n\nInput\n1 0 0\n\nOutput\n0\n\n\nInput\n1 1 1\n\nOutput\n0\n\n\nInput\n1000000000000000000 0 1000000000000000000\n\nOutput\n999999999999999999\n\n\n\n\n\n-----Note-----\n\nIn the first sample, Vasiliy could have missed one supper, for example, in case he have arrived before breakfast, have been in the sanatorium for two days (including the day of arrival) and then have left after breakfast on the third day. \n\nIn the second sample, Vasiliy could have arrived before breakfast, have had it, and immediately have left the sanatorium, not missing any meal.\n\nIn the third sample, Vasiliy could have been in the sanatorium for one day, not missing any meal.", "solution": "a, b, c = list(map(int, input().split()))\nx = max(a, b, c)\na = x - a\nb = x - b\nc = x - c\nif (a > 0 and b > 0) or (a > 0 and c > 0) or (b > 0 and c > 0):\n    print(a + b + c - 2)\nelif a > 0 or b > 0 or c > 0:\n    print(a + b + c - 1)\nelse:\n    print(a + b + c)", "pass": true}
{"task_id": "0238", "program": "def max_cost_subarray(n, m, k, a):\n    # Initialize the maximum cost to 0 (considering the empty subarray)\n    max_cost = 0\n    # Initialize the current sum and the minimum sum seen so far\n    current_sum = 0\n    min_sum = 0\n    \n    # Iterate over the array\n    for i in range(n):\n        current_sum += a[i]\n        # Calculate the number of segments of length m in the current subarray\n        segments = (i + 1) // m\n        # Calculate the cost of the current subarray\n        cost = current_sum - k * segments\n        # Update the maximum cost\n        max_cost = max(max_cost, cost - min_sum)\n        # Update the minimum sum seen so far\n        if (i + 1) % m == 0:\n            min_sum = min(min_sum, current_sum - k * ((i + 1) // m))\n    \n    return max_cost\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Calculate and print the result\nprint(max_cost_subarray(n, m, k, a))", "problem": "You are given an array $a_1, a_2, \\dots , a_n$ and two integers $m$ and $k$.\n\nYou can choose some subarray $a_l, a_{l+1}, \\dots, a_{r-1}, a_r$. \n\nThe cost of subarray $a_l, a_{l+1}, \\dots, a_{r-1}, a_r$ is equal to $\\sum\\limits_{i=l}^{r} a_i - k \\lceil \\frac{r - l + 1}{m} \\rceil$, where $\\lceil x \\rceil$ is the least integer greater than or equal to $x$. \n\nThe cost of empty subarray is equal to zero.\n\nFor example, if $m = 3$, $k = 10$ and $a = [2, -4, 15, -3, 4, 8, 3]$, then the cost of some subarrays are:  $a_3 \\dots a_3: 15 - k \\lceil \\frac{1}{3} \\rceil = 15 - 10 = 5$;  $a_3 \\dots a_4: (15 - 3) - k \\lceil \\frac{2}{3} \\rceil = 12 - 10 = 2$;  $a_3 \\dots a_5: (15 - 3 + 4) - k \\lceil \\frac{3}{3} \\rceil = 16 - 10 = 6$;  $a_3 \\dots a_6: (15 - 3 + 4 + 8) - k \\lceil \\frac{4}{3} \\rceil = 24 - 20 = 4$;  $a_3 \\dots a_7: (15 - 3 + 4 + 8 + 3) - k \\lceil \\frac{5}{3} \\rceil = 27 - 20 = 7$. \n\nYour task is to find the maximum cost of some subarray (possibly empty) of array $a$.\n\n\n-----Input-----\n\nThe first line contains three integers $n$, $m$, and $k$ ($1 \\le n \\le 3 \\cdot 10^5, 1 \\le m \\le 10, 1 \\le k \\le 10^9$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-10^9 \\le a_i \\le 10^9$).\n\n\n-----Output-----\n\nPrint the maximum cost of some subarray of array $a$.\n\n\n-----Examples-----\nInput\n7 3 10\n2 -4 15 -3 4 8 3\n\nOutput\n7\n\nInput\n5 2 1000\n-13 -4 -9 -20 -11\n\nOutput\n0", "solution": "from sys import stdin, stdout, exit\n\nn, m, k = list(map(int, stdin.readline().split()))\na = list(map(int, stdin.readline().split()))\n\ndef bf(a):\n    best = 0\n    best_arg = (-1, -1)\n    for i in range(n):\n        for j in range(i, n):\n            cur = sum(a[i:j+1]) - k*((j - i) // m + 1)\n            if cur > best:\n                best = max(best, cur)\n                best_arg = (i,j)\n    return best, best_arg\n\ndef max_sum(a):\n    if len(a) == 0:\n        return 0\n    elif len(a) == 1:\n        return max(0, a[0] - k)\n    mid = len(a) // 2\n    l_rec = max_sum(a[:mid])\n    r_rec = max_sum(a[mid:])\n    l_bests = [0]*m\n    r_bests = [0]*m\n    l_sum = 0\n    for idx in range(1,mid+1):\n        l_sum += a[mid-idx]\n        if idx % m == 0:\n            l_sum -= k\n        l_bests[idx%m] = max(l_bests[idx%m], l_sum)\n    r_sum = 0\n    for idx in range(0, len(a)-mid):\n        r_sum += a[idx+mid]\n        if (idx+1) % m == 0:\n            r_sum -= k\n        r_bests[(idx+1)%m] = max(r_bests[(idx+1)%m], r_sum)\n\n #   print(\"Array:\", a, \"mid:\", mid)\n#    print(l_bests)\n  #  print(r_bests)\n    best_acr = 0\n    for i in range(m):\n        for j in range(m):\n            best_acr = max(best_acr, l_bests[i] + r_bests[j] - (k if i+j>0 else 0) - (k if i+j>m else 0))\n    ans = max(l_rec,r_rec, best_acr)\n   # print(\"Answer:\", ans)\n    return ans\n\n\nans = max_sum(a)\nstdout.write(str(ans) + \"\\n\")\n#stdout.write(str(bf(a))+\"\\n\")\n", "pass": false}
{"task_id": "0294", "program": "def is_valid_sequence(n, days):\n    # Define the days in each month for both leap and non-leap years\n    non_leap_year = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    leap_year = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Create a combined list to handle the wrap-around of months\n    combined = non_leap_year + non_leap_year + leap_year + leap_year\n    \n    # Check if the sequence exists in the combined list\n    for i in range(len(combined) - n + 1):\n        if combined[i:i+n] == days:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input().strip())\ndays = list(map(int, input().strip().split()))\n\n# Output the result\nprint(is_valid_sequence(n, days))", "problem": "Everybody in Russia uses Gregorian calendar. In this calendar there are 31 days in January, 28 or 29 days in February (depending on whether the year is leap or not), 31 days in March, 30 days in April, 31 days in May, 30 in June, 31 in July, 31 in August, 30 in September, 31 in October, 30 in November, 31 in December.\n\nA year is leap in one of two cases: either its number is divisible by 4, but not divisible by 100, or is divisible by 400. For example, the following years are leap: 2000, 2004, but years 1900 and 2018 are not leap.\n\nIn this problem you are given n (1 \u2264 n \u2264 24) integers a_1, a_2, ..., a_{n}, and you have to check if these integers could be durations in days of n consecutive months, according to Gregorian calendar. Note that these months could belong to several consecutive years. In other words, check if there is a month in some year, such that its duration is a_1 days, duration of the next month is a_2 days, and so on.\n\n\n-----Input-----\n\nThe first line contains single integer n (1 \u2264 n \u2264 24) \u2014 the number of integers.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (28 \u2264 a_{i} \u2264 31) \u2014 the numbers you are to check.\n\n\n-----Output-----\n\nIf there are several consecutive months that fit the sequence, print \"YES\" (without quotes). Otherwise, print \"NO\" (without quotes).\n\nYou can print each letter in arbitrary case (small or large).\n\n\n-----Examples-----\nInput\n4\n31 31 30 31\n\nOutput\nYes\n\n\nInput\n2\n30 30\n\nOutput\nNo\n\n\nInput\n5\n29 31 30 31 30\n\nOutput\nYes\n\n\nInput\n3\n31 28 30\n\nOutput\nNo\n\n\nInput\n3\n31 31 28\n\nOutput\nYes\n\n\n\n\n-----Note-----\n\nIn the first example the integers can denote months July, August, September and October.\n\nIn the second example the answer is no, because there are no two consecutive months each having 30 days.\n\nIn the third example the months are: February (leap year) \u2014 March \u2014 April \u2013 May \u2014 June.\n\nIn the fourth example the number of days in the second month is 28, so this is February. March follows February and has 31 days, but not 30, so the answer is NO.\n\nIn the fifth example the months are: December \u2014 January \u2014 February (non-leap year).", "solution": "n = int(input())\ns = input().split()\na = [0] * n\nm = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\nfor i in range(n):\n  a[i] = int(s[i])\nans = \"No\"\nfor i in range(len(m) - n):\n  if a == m[i:i+n]:\n    ans = \"Yes\"\n    break\nprint(ans)", "pass": false}
{"task_id": "0371", "program": "def find_smallest_n(m):\n    # Function to count the number of valid ways for a given n\n    def count_ways(n):\n        count = 0\n        k = 2\n        while k * k * k * k <= n:\n            count += n // (k * k * k * k)\n            k += 1\n        return count\n\n    # Binary search for the smallest n\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if count_ways(mid) < m:\n            left = mid + 1\n        else:\n            right = mid\n\n    if count_ways(left) == m:\n        return left\n    else:\n        return -1\n\n# Read input\nm = int(input().strip())\n\n# Find and print the smallest possible value of n\nprint(find_smallest_n(m))", "problem": "Bad news came to Mike's village, some thieves stole a bunch of chocolates from the local factory! Horrible! \n\nAside from loving sweet things, thieves from this area are known to be very greedy. So after a thief takes his number of chocolates for himself, the next thief will take exactly k times more than the previous one. The value of k (k > 1) is a secret integer known only to them. It is also known that each thief's bag can carry at most n chocolates (if they intend to take more, the deal is cancelled) and that there were exactly four thieves involved. \n\nSadly, only the thieves know the value of n, but rumours say that the numbers of ways they could have taken the chocolates (for a fixed n, but not fixed k) is m. Two ways are considered different if one of the thieves (they should be numbered in the order they take chocolates) took different number of chocolates in them.\n\nMike want to track the thieves down, so he wants to know what their bags are and value of n will help him in that. Please find the smallest possible value of n or tell him that the rumors are false and there is no such n.\n\n\n-----Input-----\n\nThe single line of input contains the integer m (1 \u2264 m \u2264 10^15)\u00a0\u2014 the number of ways the thieves might steal the chocolates, as rumours say.\n\n\n-----Output-----\n\nPrint the only integer n\u00a0\u2014 the maximum amount of chocolates that thieves' bags can carry. If there are more than one n satisfying the rumors, print the smallest one.\n\nIf there is no such n for a false-rumoured m, print  - 1.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n8\n\nInput\n8\n\nOutput\n54\n\nInput\n10\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first sample case the smallest n that leads to exactly one way of stealing chocolates is n = 8, whereas the amounts of stealed chocolates are (1, 2, 4, 8) (the number of chocolates stolen by each of the thieves).\n\nIn the second sample case the smallest n that leads to exactly 8 ways is n = 54 with the possibilities: (1, 2, 4, 8), \u2002(1, 3, 9, 27), \u2002(2, 4, 8, 16), \u2002(2, 6, 18, 54), \u2002(3, 6, 12, 24), \u2002(4, 8, 16, 32), \u2002(5, 10, 20, 40), \u2002(6, 12, 24, 48).\n\nThere is no n leading to exactly 10 ways of stealing chocolates in the third sample case.", "solution": "def main():\n    m = int(input())\n    lo = m*4\n    hi = m*8\n    loposs = countposs(lo)\n    hiposs = countposs(hi)\n    while lo < hi - 1:\n        if hi - lo > 10000:\n            mid = lo + int((m-loposs)/(hiposs-loposs)*(hi-lo))\n            mid = max(lo + 1, min(hi - 1, mid))\n        else:\n            mid = (hi + lo)//2\n        nposs = countposs(mid)\n        if nposs < m:\n            lo = mid\n        else:\n            hi = mid\n    if m == countposs(hi):\n        print(hi)\n    else:\n        print(-1)\n\ndef countposs(maxtake):\n    k = 2\n    ans = 0\n    while True:\n        term = maxtake//(k*k*k)\n        if term == 0:\n            return ans\n        ans += term\n        k += 1\n\nmain()", "pass": false}
{"task_id": "0431", "program": "def min_time_to_turn_off_lights(n, m, building):\n    # Initialize the total time\n    total_time = 0\n    \n    # Initialize the current position (ground floor, left stairs)\n    current_floor = 0\n    current_position = 0\n    \n    # Process each floor from the ground floor to the top floor\n    for floor in range(n):\n        # Get the current floor's light status\n        lights = building[floor]\n        \n        # Find the leftmost and rightmost lights that are on\n        leftmost = lights.find('1')\n        rightmost = lights.rfind('1')\n        \n        if leftmost == -1:\n            # No lights are on in this floor, just move to the next floor\n            total_time += 1\n            continue\n        \n        if floor % 2 == 0:\n            # If the floor is even, we start from the left stairs\n            total_time += rightmost\n            total_time += 1  # Move to the next floor\n        else:\n            # If the floor is odd, we start from the right stairs\n            total_time += (m + 1 - leftmost)\n            total_time += 1  # Move to the next floor\n    \n    # Add the time to reach the last light on the top floor\n    if n % 2 == 0:\n        total_time += rightmost\n    else:\n        total_time += (m + 1 - leftmost)\n    \n    return total_time\n\n# Read input\nn, m = map(int, input().split())\nbuilding = [input().strip() for _ in range(n)]\n\n# Calculate and print the minimum total time\nprint(min_time_to_turn_off_lights(n, m, building))", "problem": "Some people leave the lights at their workplaces on when they leave that is a waste of resources. As a hausmeister of DHBW, Sagheer waits till all students and professors leave the university building, then goes and turns all the lights off.\n\nThe building consists of n floors with stairs at the left and the right sides. Each floor has m rooms on the same line with a corridor that connects the left and right stairs passing by all the rooms. In other words, the building can be represented as a rectangle with n rows and m + 2 columns, where the first and the last columns represent the stairs, and the m columns in the middle represent rooms.\n\nSagheer is standing at the ground floor at the left stairs. He wants to turn all the lights off in such a way that he will not go upstairs until all lights in the floor he is standing at are off. Of course, Sagheer must visit a room to turn the light there off. It takes one minute for Sagheer to go to the next floor using stairs or to move from the current room/stairs to a neighboring room/stairs on the same floor. It takes no time for him to switch the light off in the room he is currently standing in. Help Sagheer find the minimum total time to turn off all the lights.\n\nNote that Sagheer does not have to go back to his starting position, and he does not have to visit rooms where the light is already switched off.\n\n\n-----Input-----\n\nThe first line contains two integers n and m (1 \u2264 n \u2264 15 and 1 \u2264 m \u2264 100) \u2014 the number of floors and the number of rooms in each floor, respectively.\n\nThe next n lines contains the building description. Each line contains a binary string of length m + 2 representing a floor (the left stairs, then m rooms, then the right stairs) where 0 indicates that the light is off and 1 indicates that the light is on. The floors are listed from top to bottom, so that the last line represents the ground floor.\n\nThe first and last characters of each string represent the left and the right stairs, respectively, so they are always 0.\n\n\n-----Output-----\n\nPrint a single integer \u2014 the minimum total time needed to turn off all the lights.\n\n\n-----Examples-----\nInput\n2 2\n0010\n0100\n\nOutput\n5\n\nInput\n3 4\n001000\n000010\n000010\n\nOutput\n12\n\nInput\n4 3\n01110\n01110\n01110\n01110\n\nOutput\n18\n\n\n\n-----Note-----\n\nIn the first example, Sagheer will go to room 1 in the ground floor, then he will go to room 2 in the second floor using the left or right stairs.\n\nIn the second example, he will go to the fourth room in the ground floor, use right stairs, go to the fourth room in the second floor, use right stairs again, then go to the second room in the last floor.\n\nIn the third example, he will walk through the whole corridor alternating between the left and right stairs at each floor.", "solution": "def minimum(floor,j,s,n,m):\n\tif(s==[]):\n\t\treturn 0\n\tif(floor==0):\n\t\tif(j==0):\n\t\t\treturn s[floor].rfind('1')\n\t\telse:\n\t\t\treturn m+1-s[floor].find('1')\n\tif(j==0):\n\t\treturn min(2*s[floor].rfind('1')+1+minimum(floor-1,0,s,n,m),m+2+minimum(floor-1,m+1,s,n,m))\n\telse:\n\t\treturn min(2*(m+1-s[floor].find('1'))+1+minimum(floor-1,m+1,s,n,m),m+2+minimum(floor-1,0,s,n,m))\n\ninp=input().split()\nn=int(inp[0])\nm=int(inp[1])\ns=[]\nfor i in range(n):\n\ts.append(input())\ncounter=0\nwhile(s!=[]):\n\tif(s[0].find('1')==-1):\n\t\tcounter+=1\n\t\ts.pop(0)\n\telse:\n\t\tbreak\ncounter2=0\ns2=[]\nfor val in s:\n\tif(val.find('1')==-1):\n\t\tcounter2+=1\n\telse:\n\t\ts2.append(val)\n\nprint(minimum(n-1-counter-counter2,0,s2,n,m)+counter2)", "pass": false}
{"task_id": "0551", "program": "def can_draw_parallel_lines(n, y):\n    if n < 3:\n        return \"No\"\n    \n    # Check if we can split the points into two groups with the same slope\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            # Calculate the slope of the line passing through points (1, y[0]) and (i+1, y[i])\n            slope1 = (y[i] - y[0]) / (i)\n            # Calculate the slope of the line passing through points (1, y[0]) and (j+1, y[j])\n            slope2 = (y[j] - y[0]) / (j)\n            \n            if slope1 == slope2:\n                continue\n            \n            # Try to split the points into two groups with these slopes\n            group1 = set([0, i])\n            group2 = set([j])\n            \n            for k in range(1, n):\n                if k == i or k == j:\n                    continue\n                \n                # Check if point (k+1, y[k]) can be added to group1\n                if (y[k] - y[0]) / k == slope1:\n                    group1.add(k)\n                # Check if point (k+1, y[k]) can be added to group2\n                elif (y[k] - y[0]) / k == slope2:\n                    group2.add(k)\n                else:\n                    break\n            else:\n                if len(group1) > 1 and len(group2) > 1:\n                    return \"Yes\"\n    \n    return \"No\"\n\n# Read input\nn = int(input())\ny = list(map(int, input().split()))\n\n# Output result\nprint(can_draw_parallel_lines(n, y))", "problem": "Connect the countless points with lines, till we reach the faraway yonder.\n\nThere are n points on a coordinate plane, the i-th of which being (i, y_{i}).\n\nDetermine whether it's possible to draw two parallel and non-overlapping lines, such that every point in the set lies on exactly one of them, and each of them passes through at least one point in the set.\n\n\n-----Input-----\n\nThe first line of input contains a positive integer n (3 \u2264 n \u2264 1 000) \u2014 the number of points.\n\nThe second line contains n space-separated integers y_1, y_2, ..., y_{n} ( - 10^9 \u2264 y_{i} \u2264 10^9) \u2014 the vertical coordinates of each point.\n\n\n-----Output-----\n\nOutput \"Yes\" (without quotes) if it's possible to fulfill the requirements, and \"No\" otherwise.\n\nYou can print each letter in any case (upper or lower).\n\n\n-----Examples-----\nInput\n5\n7 5 8 6 9\n\nOutput\nYes\n\nInput\n5\n-1 -2 0 0 -5\n\nOutput\nNo\n\nInput\n5\n5 4 3 2 1\n\nOutput\nNo\n\nInput\n5\n1000000000 0 0 0 0\n\nOutput\nYes\n\n\n\n-----Note-----\n\nIn the first example, there are five points: (1, 7), (2, 5), (3, 8), (4, 6) and (5, 9). It's possible to draw a line that passes through points 1, 3, 5, and another one that passes through points 2, 4 and is parallel to the first one.\n\nIn the second example, while it's possible to draw two lines that cover all points, they cannot be made parallel.\n\nIn the third example, it's impossible to satisfy both requirements at the same time.", "solution": "n=int(input())\ny=list(map(int,input().split()))\ndef check(d):\n    return len(set(2*yi-d*i for i,yi in enumerate(y)))==2\n\nprint('Yes' if any(check(d) for d in [2*(y[1]-y[0]),2*(y[2]-y[1]),y[2]-y[0]]) else 'No')", "pass": false}
{"task_id": "0630", "program": "def calculate_messages_read(n, k, links):\n    result = []\n    for t in range(1, n + 1):\n        visited = set()\n        current = t - 1\n        while current >= 0:\n            start = max(0, current - k)\n            end = min(n, current + k + 1)\n            for i in range(start, end):\n                visited.add(i)\n            if links[current] == 0:\n                break\n            current = links[current] - 1\n        result.append(len(visited))\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nlinks = list(map(int, data[2:]))\n\n# Calculate the result\nresult = calculate_messages_read(n, k, links)\n\n# Print the result\nprint(\" \".join(map(str, result)))", "problem": "There are times you recall a good old friend and everything you've come through together. Luckily there are social networks\u00a0\u2014 they store all your message history making it easy to know what you argued over 10 years ago.\n\nMore formal, your message history is a sequence of messages ordered by time sent numbered from 1 to n where n is the total number of messages in the chat.\n\nEach message might contain a link to an earlier message which it is a reply to. When opening a message x or getting a link to it, the dialogue is shown in such a way that k previous messages, message x and k next messages are visible (with respect to message x). In case there are less than k messages somewhere, they are yet all shown.\n\nDigging deep into your message history, you always read all visible messages and then go by the link in the current message x (if there is one) and continue reading in the same manner.\n\nDetermine the number of messages you'll read if your start from message number t for all t from 1 to n. Calculate these numbers independently. If you start with message x, the initial configuration is x itself, k previous and k next messages. Messages read multiple times are considered as one.\n\n\n-----Input-----\n\nThe first line contains two integers n and k (1 \u2264 n \u2264 10^5, 0 \u2264 k \u2264 n) \u2014 the total amount of messages and the number of previous and next messages visible.\n\nThe second line features a sequence of integers a_1, a_2, ..., a_{n} (0 \u2264 a_{i} < i), where a_{i} denotes the i-th message link destination or zero, if there's no link from i. All messages are listed in chronological order. It's guaranteed that the link from message x goes to message with number strictly less than x.\n\n\n-----Output-----\n\nPrint n integers with i-th denoting the number of distinct messages you can read starting from message i and traversing the links while possible.\n\n\n-----Examples-----\nInput\n6 0\n0 1 1 2 3 2\n\nOutput\n1 2 2 3 3 3 \n\nInput\n10 1\n0 1 0 3 4 5 2 3 7 0\n\nOutput\n2 3 3 4 5 6 6 6 8 2 \n\nInput\n2 2\n0 1\n\nOutput\n2 2 \n\n\n\n-----Note-----\n\nConsider i = 6 in sample case one. You will read message 6, then 2, then 1 and then there will be no link to go.\n\nIn the second sample case i = 6 gives you messages 5, 6, 7 since k = 1, then 4, 5, 6, then 2, 3, 4 and then the link sequence breaks. The number of distinct messages here is equal to 6.", "solution": "n, k = map(int,input().split())\ndp = [0]\nbound = [0]\na = list(map(int,input().split()))\n\nfor i in range(1, n+1):\n    dp.append(dp[a[i-1]])\n    bound.append(i+k)\n    t1 = max(bound[a[i-1]]+1, i-k)\n    t2 = min(i+k, n)\n    t3 = t2 - t1 + 1\n    if t3>0: dp[i] += t3\n\nfor i in range(1, n+1):\n    print(dp[i],end = ' ')\n", "pass": true}
{"task_id": "0716", "program": "def min_cost_to_olympiad(n, a, b, companies):\n    # If starting and ending airports are the same, cost is zero\n    if a == b:\n        return 0\n    \n    # If starting and ending airports belong to the same company, cost is zero\n    if companies[a - 1] == companies[b - 1]:\n        return 0\n    \n    # Otherwise, the cost is the absolute difference between the airport ids\n    return abs(a - b)\n\n# Read input\nn, a, b = map(int, input().split())\ncompanies = input().strip()\n\n# Calculate and print the minimum cost\nprint(min_cost_to_olympiad(n, a, b, companies))", "problem": "Vladik is a competitive programmer. This year he is going to win the International Olympiad in Informatics. But it is not as easy as it sounds: the question Vladik face now is to find the cheapest way to get to the olympiad.\n\nVladik knows n airports. All the airports are located on a straight line. Each airport has unique id from 1 to n, Vladik's house is situated next to the airport with id a, and the place of the olympiad is situated next to the airport with id b. It is possible that Vladik's house and the place of the olympiad are located near the same airport. \n\nTo get to the olympiad, Vladik can fly between any pair of airports any number of times, but he has to start his route at the airport a and finish it at the airport b.\n\nEach airport belongs to one of two companies. The cost of flight from the airport i to the airport j is zero if both airports belong to the same company, and |i - j| if they belong to different companies.\n\nPrint the minimum cost Vladik has to pay to get to the olympiad.\n\n\n-----Input-----\n\nThe first line contains three integers n, a, and b (1 \u2264 n \u2264 10^5, 1 \u2264 a, b \u2264 n)\u00a0\u2014 the number of airports, the id of the airport from which Vladik starts his route and the id of the airport which he has to reach. \n\nThe second line contains a string with length n, which consists only of characters 0 and 1. If the i-th character in this string is 0, then i-th airport belongs to first company, otherwise it belongs to the second.\n\n\n-----Output-----\n\nPrint single integer\u00a0\u2014 the minimum cost Vladik has to pay to get to the olympiad.\n\n\n-----Examples-----\nInput\n4 1 4\n1010\n\nOutput\n1\nInput\n5 5 2\n10110\n\nOutput\n0\n\n\n-----Note-----\n\nIn the first example Vladik can fly to the airport 2 at first and pay |1 - 2| = 1 (because the airports belong to different companies), and then fly from the airport 2 to the airport 4 for free (because the airports belong to the same company). So the cost of the whole flight is equal to 1. It's impossible to get to the olympiad for free, so the answer is equal to 1. \n\nIn the second example Vladik can fly directly from the airport 5 to the airport 2, because they belong to the same company.", "solution": "n, a, b = list(map(int, input().split()))\ns = input()\n\na -= 1\nb -= 1\nif s[a] == s[b]:\n    print(0)\nelse:\n    print(1)\n    #i = a\n    #while s[i] != s[b]:\n        #i += 1\n   # j = a\n    #while j > 0 and s[i] != s[b]:\n        #j -= a\n", "pass": false}
{"task_id": "0773", "program": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    facts = []\n    index = 2\n    for _ in range(q):\n        t = int(data[index])\n        l = int(data[index + 1])\n        r = int(data[index + 2])\n        v = int(data[index + 3])\n        facts.append((t, l, r, v))\n        index += 4\n    \n    # Initialize the array with the minimum possible values\n    a = [1] * n\n    \n    # Apply the facts\n    for t, l, r, v in facts:\n        if t == 1:\n            for i in range(l - 1, r):\n                a[i] = max(a[i], v)\n        elif t == 2:\n            for i in range(l - 1, r):\n                a[i] = min(a[i], v)\n    \n    # Check for contradictions\n    for t, l, r, v in facts:\n        if t == 1:\n            for i in range(l - 1, r):\n                if a[i] < v:\n                    print(-1)\n                    return\n        elif t == 2:\n            for i in range(l - 1, r):\n                if a[i] > v:\n                    print(-1)\n                    return\n    \n    # Calculate the cost\n    from collections import Counter\n    cnt = Counter(a)\n    cost = sum(cnt[i] ** 2 for i in cnt)\n    \n    print(cost)", "problem": "Recently Ivan noticed an array a while debugging his code. Now Ivan can't remember this array, but the bug he was trying to fix didn't go away, so Ivan thinks that the data from this array might help him to reproduce the bug.\n\nIvan clearly remembers that there were n elements in the array, and each element was not less than 1 and not greater than n. Also he remembers q facts about the array. There are two types of facts that Ivan remembers:  1 l_{i} r_{i} v_{i} \u2014 for each x such that l_{i} \u2264 x \u2264 r_{i} a_{x} \u2265 v_{i};  2 l_{i} r_{i} v_{i} \u2014 for each x such that l_{i} \u2264 x \u2264 r_{i} a_{x} \u2264 v_{i}. \n\nAlso Ivan thinks that this array was a permutation, but he is not so sure about it. He wants to restore some array that corresponds to the q facts that he remembers and is very similar to permutation. Formally, Ivan has denoted the cost of array as follows:\n\n$\\operatorname{cos} t = \\sum_{i = 1}^{n}(\\operatorname{cnt}(i))^{2}$, where cnt(i) is the number of occurences of i in the array.\n\nHelp Ivan to determine minimum possible cost of the array that corresponds to the facts!\n\n\n-----Input-----\n\nThe first line contains two integer numbers n and q (1 \u2264 n \u2264 50, 0 \u2264 q \u2264 100).\n\nThen q lines follow, each representing a fact about the array. i-th line contains the numbers t_{i}, l_{i}, r_{i} and v_{i} for i-th fact (1 \u2264 t_{i} \u2264 2, 1 \u2264 l_{i} \u2264 r_{i} \u2264 n, 1 \u2264 v_{i} \u2264 n, t_{i} denotes the type of the fact).\n\n\n-----Output-----\n\nIf the facts are controversial and there is no array that corresponds to them, print -1. Otherwise, print minimum possible cost of the array.\n\n\n-----Examples-----\nInput\n3 0\n\nOutput\n3\n\nInput\n3 1\n1 1 3 2\n\nOutput\n5\n\nInput\n3 2\n1 1 3 2\n2 1 3 2\n\nOutput\n9\n\nInput\n3 2\n1 1 3 2\n2 1 3 1\n\nOutput\n-1", "solution": "import sys\n \ndef is_feasible(cnt,L,R):\n\tn = len(R)\n\tinter = [(L[i],R[i]) for i in range(n)]\n\tright = []\n\tfeasible = True\n\tfor x in range(n):\n\t\tfor p in inter:\n\t\t\tif p[0] == x:\n\t\t\t\tright.append(p[1])\n\t\t\t\t\n\t\twhile right and min(right) < x:\n\t\t\tright.remove(min(right))\n\t\tfor quantity in range(cnt[x]):\n\t\t\tif right:\n\t\t\t\tright.remove(min(right))\n\t\t\telse:\n\t\t\t\tfeasible = False\n\treturn feasible\n \n \nn,q = list(map(int,sys.stdin.readline().split()))\nL = [0 for i in range(n)]\nR = [n-1 for i in range(n)]\nfor restriction in range(q):\n\tt,l,r,v = list(map(int,sys.stdin.readline().split()))\n\tif t == 1:\n\t\tfor k in range(l-1,r):\n\t\t\tL[k] = max(L[k],v-1)\n\telse:\n\t\tfor k in range(l-1,r):\n\t\t\tR[k] = min(R[k],v-1)\n\t\t\t\nis_possible = all(map(lambda x,y : x <= y,L,R))\nif not is_possible:\n\tprint(-1)\nelse:\n\tcnt = {x:0 for x in range(n)}\n\tfor y in range(n):\n\t\tfor x in range(n):\n\t\t\tif cnt[x] == y:\n\t\t\t\tcnt[x] += 1\n\t\t\t\tif not is_feasible(cnt,L,R):\n\t\t\t\t\tcnt[x] -= 1 \n\tans = sum([cnt[x]*cnt[x] for x in range(n)])\n\tprint(ans)\n\t\n\t\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n", "pass": false}
{"task_id": "0793", "program": "MOD = 10**9 + 7\n\ndef count_subsequence_pairs(N, M, S, T):\n    # Create a 2D DP array\n    dp = [[0] * (M + 1) for _ in range(N + 1)]\n    \n    # Initialize the base case\n    for i in range(N + 1):\n        dp[i][0] = 1\n    for j in range(M + 1):\n        dp[0][j] = 1\n    \n    # Fill the DP table\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n            if S[i - 1] == T[j - 1]:\n                dp[i][j] += dp[i - 1][j - 1]\n            dp[i][j] %= MOD\n    \n    return dp[N][M]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nS = list(map(int, data[2:N+2]))\nT = list(map(int, data[N+2:N+2+M]))\n\n# Calculate the result\nresult = count_subsequence_pairs(N, M, S, T)\n\n# Print the result\nprint(result)", "problem": "You are given two integer sequences S and T of length N and M, respectively, both consisting of integers between 1 and 10^5 (inclusive).\nIn how many pairs of a subsequence of S and a subsequence of T do the two subsequences are the same in content?\nHere the subsequence of A is a sequence obtained by removing zero or more elements from A and concatenating the remaining elements without changing the order.\nFor both S and T, we distinguish two subsequences if the sets of the indices of the removed elements are different, even if the subsequences are the same in content.\nSince the answer can be tremendous, print the number modulo 10^9+7.\n\n-----Constraints-----\n - 1 \\leq N, M \\leq 2 \\times 10^3\n - The length of S is N.\n - The length of T is M.     \n - 1 \\leq S_i, T_i \\leq 10^5\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nS_1 S_2 ... S_{N-1} S_{N}\nT_1 T_2 ... T_{M-1} T_{M}\n\n-----Output-----\nPrint the number of pairs of a subsequence of S and a subsequence of T such that the subsequences are the same in content, modulo 10^9+7.\n\n-----Sample Input-----\n2 2\n1 3\n3 1\n\n-----Sample Output-----\n3\n\nS has four subsequences: (), (1), (3), (1, 3).\nT has four subsequences: (), (3), (1), (3, 1).\nThere are 1 \\times 1 pair of subsequences in which the subsequences are both (), 1 \\times 1 pair of subsequences in which the subsequences are both (1), and 1 \\times 1 pair of subsequences in which the subsequences are both (3), for a total of three pairs.", "solution": "# \u4e21\u65b9\u306e\u6570\u5217\u304b\u3089\u540c\u3058\u90e8\u5206\u5217\u304c\u3044\u304f\u3064\u3042\u308b\u304b\uff1f\nimport numpy as np\n\nMOD = 10**9+7\nN, M = list(map(int, input().split()))\nS = input().split()\nT = np.array(input().split(), dtype=np.int32)\ndp = np.ones(M+1, dtype=np.int64)\n\nfor s in S:\n  dp[1:] = ((dp[:-1] * (T == int(s))).cumsum() + dp[1:]) % MOD\n\nprint((dp[M]))\n\n", "pass": false}
{"task_id": "0809", "program": "def arrange_tea(n, k, a, b):\n    if a < b:\n        a, b = b, a\n        main_char, alt_char = 'B', 'G'\n    else:\n        main_char, alt_char = 'G', 'B'\n    \n    result = []\n    while a > 0 or b > 0:\n        if a > b:\n            take = min(k, a)\n            result.append(main_char * take)\n            a -= take\n            if b > 0:\n                result.append(alt_char)\n                b -= 1\n        else:\n            take = min(k, b)\n            result.append(alt_char * take)\n            b -= take\n            if a > 0:\n                result.append(main_char)\n                a -= 1\n        \n        if len(result) > 1 and result[-1] == result[-2]:\n            print(\"NO\")\n            return\n    \n    print(\"\".join(result))\n\n# Read input\nn, k, a, b = map(int, input().split())\n\n# Call the function\narrange_tea(n, k, a, b)", "problem": "Innokentiy likes tea very much and today he wants to drink exactly n cups of tea. He would be happy to drink more but he had exactly n tea bags, a of them are green and b are black.\n\nInnokentiy doesn't like to drink the same tea (green or black) more than k times in a row. Your task is to determine the order of brewing tea bags so that Innokentiy will be able to drink n cups of tea, without drinking the same tea more than k times in a row, or to inform that it is impossible. Each tea bag has to be used exactly once.\n\n\n-----Input-----\n\nThe first line contains four integers n, k, a and b (1 \u2264 k \u2264 n \u2264 10^5, 0 \u2264 a, b \u2264 n)\u00a0\u2014 the number of cups of tea Innokentiy wants to drink, the maximum number of cups of same tea he can drink in a row, the number of tea bags of green and black tea. It is guaranteed that a + b = n.\n\n\n-----Output-----\n\nIf it is impossible to drink n cups of tea, print \"NO\" (without quotes).\n\nOtherwise, print the string of the length n, which consists of characters 'G' and 'B'. If some character equals 'G', then the corresponding cup of tea should be green. If some character equals 'B', then the corresponding cup of tea should be black.\n\nIf there are multiple answers, print any of them.\n\n\n-----Examples-----\nInput\n5 1 3 2\n\nOutput\nGBGBG\n\nInput\n7 2 2 5\n\nOutput\nBBGBGBB\nInput\n4 3 4 0\n\nOutput\nNO", "solution": "n,k,a,b = map(int,input().split())\nA = []\nper = 0\nif a >= b:\n    per=0\n    while True:\n        if b == 0:\n            if a <=k:\n                A.append('G'*a)\n                break\n            else:\n                per = 1\n                break\n        else:\n            if a-b>=k-1:\n                a-=k\n                b-=1\n                A.append('G'*k + 'B')\n            elif a - b > 0:\n                A.append((a-b+1) * 'G' + 'B')\n                a -= (a-b+1)\n                b -= 1\n            else:\n                A.append('GB' * a)\n                break\nelse:\n    a,b=b,a\n    per=0\n    while True:\n        if b == 0:\n            if a <=k:\n                A.append('B'*a)\n                break\n            else:\n                per = 1\n                break\n        else:\n            if a-b>=k-1:\n                a-=k\n                b-=1\n                A.append('B'*k + 'G')\n            elif a - b > 0:\n                A.append((a-b+1) * 'B' + 'G')\n                a -= (a-b+1)\n                b -= 1\n            else:\n                A.append('BG' * a)\n                break\nif per == 1:\n    print('NO')\nelse:\n    print(''.join(map(str,A)))", "pass": false}
{"task_id": "0824", "program": "MOD = 10**9 + 7\n\ndef count_rsbs(s):\n    n = len(s)\n    if n % 2 != 0:\n        return 0\n\n    left_count = [0] * (n + 1)\n    right_count = [0] * (n + 1)\n\n    for i in range(n):\n        left_count[i + 1] = left_count[i] + (1 if s[i] == '(' else 0)\n    \n    for i in range(n - 1, -1, -1):\n        right_count[i] = right_count[i + 1] + (1 if s[i] == ')' else 0)\n\n    result = 0\n    for i in range(n):\n        if s[i] == '(':\n            result = (result + right_count[i + 1]) % MOD\n\n    return result\n\ns = input().strip()\nprint(count_rsbs(s))", "problem": "As you probably know, Anton goes to school. One of the school subjects that Anton studies is Bracketology. On the Bracketology lessons students usually learn different sequences that consist of round brackets (characters \"(\" and \")\" (without quotes)).\n\nOn the last lesson Anton learned about the regular simple bracket sequences (RSBS). A bracket sequence s of length n is an RSBS if the following conditions are met:\n\n  It is not empty (that is n \u2260 0).  The length of the sequence is even.  First $\\frac{n}{2}$ charactes of the sequence are equal to \"(\".  Last $\\frac{n}{2}$ charactes of the sequence are equal to \")\". \n\nFor example, the sequence \"((()))\" is an RSBS but the sequences \"((())\" and \"(()())\" are not RSBS.\n\nElena Ivanovna, Anton's teacher, gave him the following task as a homework. Given a bracket sequence s. Find the number of its distinct subsequences such that they are RSBS. Note that a subsequence of s is a string that can be obtained from s by deleting some of its elements. Two subsequences are considered distinct if distinct sets of positions are deleted.\n\nBecause the answer can be very big and Anton's teacher doesn't like big numbers, she asks Anton to find the answer modulo 10^9 + 7.\n\nAnton thought of this task for a very long time, but he still doesn't know how to solve it. Help Anton to solve this task and write a program that finds the answer for it!\n\n\n-----Input-----\n\nThe only line of the input contains a string s\u00a0\u2014 the bracket sequence given in Anton's homework. The string consists only of characters \"(\" and \")\" (without quotes). It's guaranteed that the string is not empty and its length doesn't exceed 200 000.\n\n\n-----Output-----\n\nOutput one number\u00a0\u2014 the answer for the task modulo 10^9 + 7.\n\n\n-----Examples-----\nInput\n)(()()\n\nOutput\n6\n\nInput\n()()()\n\nOutput\n7\n\nInput\n)))\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first sample the following subsequences are possible:\n\n  If we delete characters at the positions 1 and 5 (numbering starts with one), we will get the subsequence \"(())\".  If we delete characters at the positions 1, 2, 3 and 4, we will get the subsequence \"()\".  If we delete characters at the positions 1, 2, 4 and 5, we will get the subsequence \"()\".  If we delete characters at the positions 1, 2, 5 and 6, we will get the subsequence \"()\".  If we delete characters at the positions 1, 3, 4 and 5, we will get the subsequence \"()\".  If we delete characters at the positions 1, 3, 5 and 6, we will get the subsequence \"()\". \n\nThe rest of the subsequnces are not RSBS. So we got 6 distinct subsequences that are RSBS, so the answer is 6.", "solution": "#!/usr/bin/env python3\n\ndef ri():\n    return list(map(int, input().split()))\n\nm = 10**9+7\ns = input()\nn = len(s)\no = [0 for i in range(len(s))]\nc = [0 for i in range(len(s))]\nfac = [0 for i in range(n)]\n\nfac[0] = 1\nfor i in range(1,n):\n    fac[i] = fac[i-1]*i%m\n\ninvfac = [pow(fac[i], m-2, m) for i in range(n)]\nif s[0] == '(':\n    o[0] = 1\nfor i in range(1,n):\n    if s[i] == '(':\n        o[i] = o[i-1] + 1\n    else:\n        o[i] = o[i-1]\n\nif s[n-1] == ')':\n    c[n-1] = 1\nfor i in range(n-2, -1, -1):\n    if s[i] == ')':\n        c[i] = c[i+1] + 1\n    else:\n        c[i] = c[i+1]\n\nans = 0\nfor i in range(n):\n    if s[i] == '(':\n        a = o[i]\n        b = c[i]\n        if a != 0 and b != 0:\n            ans += fac[a+b-1]*invfac[a]*invfac[b-1]\n            ans %= m\n\nprint(ans)\n\n", "pass": false}
{"task_id": "0833", "program": "n, v = map(int, input().split())\ntrees = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Create a list to store the number of fruits ripening on each day\nmax_day = 3000\nripening = [0] * (max_day + 2)\n\n# Populate the ripening list with the number of fruits ripening on each day\nfor a, b in trees:\n    ripening[a] += b\n\n# Initialize the total number of fruits collected\ntotal_collected = 0\n\n# Iterate through each day to collect fruits\nfor day in range(1, max_day + 1):\n    # Collect fruits from the previous day if any\n    if ripening[day - 1] > 0:\n        collect_today = min(v, ripening[day - 1])\n        total_collected += collect_today\n        ripening[day - 1] -= collect_today\n        v_left = v - collect_today\n    else:\n        v_left = v\n\n    # Collect fruits from the current day\n    if ripening[day] > 0:\n        collect_today = min(v_left, ripening[day])\n        total_collected += collect_today\n        ripening[day] -= collect_today\n\nprint(total_collected)", "problem": "Valera loves his garden, where n fruit trees grow.\n\nThis year he will enjoy a great harvest! On the i-th tree b_{i} fruit grow, they will ripen on a day number a_{i}. Unfortunately, the fruit on the tree get withered, so they can only be collected on day a_{i} and day a_{i} + 1 (all fruits that are not collected in these two days, become unfit to eat).\n\nValera is not very fast, but there are some positive points. Valera is ready to work every day. In one day, Valera can collect no more than v fruits. The fruits may be either from the same tree, or from different ones. What is the maximum amount of fruit Valera can collect for all time, if he operates optimally well?\n\n\n-----Input-----\n\nThe first line contains two space-separated integers n and v (1 \u2264 n, v \u2264 3000) \u2014 the number of fruit trees in the garden and the number of fruits that Valera can collect in a day. \n\nNext n lines contain the description of trees in the garden. The i-th line contains two space-separated integers a_{i} and b_{i} (1 \u2264 a_{i}, b_{i} \u2264 3000) \u2014 the day the fruits ripen on the i-th tree and the number of fruits on the i-th tree.\n\n\n-----Output-----\n\nPrint a single integer \u2014 the maximum number of fruit that Valera can collect. \n\n\n-----Examples-----\nInput\n2 3\n1 5\n2 3\n\nOutput\n8\n\nInput\n5 10\n3 20\n2 20\n1 20\n4 20\n5 20\n\nOutput\n60\n\n\n\n-----Note-----\n\nIn the first sample, in order to obtain the optimal answer, you should act as follows.   On the first day collect 3 fruits from the 1-st tree.  On the second day collect 1 fruit from the 2-nd tree and 2 fruits from the 1-st tree.  On the third day collect the remaining fruits from the 2-nd tree.  \n\nIn the second sample, you can only collect 60 fruits, the remaining fruit will simply wither.", "solution": "\"\"\"\nCodeforces Round 252 Div 2 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n\"\"\"\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s=\"\\n\"):\n    if isinstance(s, list): s = \" \".join(s)\n    s = str(s)\n    print(s, end=\"\")\n\n################################################### SOLUTION\nn,v = read()\na = []\nfor i in range(n):\n    a.append(read())\na.sort(key=lambda x: x[0])\nres = 0\nfor day in range(1, 3002):\n    n = 0\n    while a and a[0][0] <= day:\n        if a[0][1] <= v-n:\n            n += a[0][1]\n            a[0][1] = 0\n        else:\n            a[0][1] -= v-n\n            n = v\n        if a[0][1] == 0:\n            a.pop(0)\n        else:\n            break\n    while a and a[0][0] == day-1: a.pop(0)\n    res += n\nprint(res)", "pass": false}
{"task_id": "0854", "program": "def count_candies(n, T, prices):\n    total_candies = 0\n    while True:\n        current_spent = 0\n        current_candies = 0\n        for price in prices:\n            if T >= price:\n                T -= price\n                current_spent += price\n                current_candies += 1\n        if current_candies == 0:\n            break\n        total_candies += current_candies\n        T -= current_spent\n    return total_candies\n\n# Read input\nn, T = map(int, input().split())\nprices = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_candies(n, T, prices))", "problem": "XXI Berland Annual Fair is coming really soon! Traditionally fair consists of $n$ booths, arranged in a circle. The booths are numbered $1$ through $n$ clockwise with $n$ being adjacent to $1$. The $i$-th booths sells some candies for the price of $a_i$ burles per item. Each booth has an unlimited supply of candies.\n\nPolycarp has decided to spend at most $T$ burles at the fair. However, he has some plan in mind for his path across the booths:  at first, he visits booth number $1$;  if he has enough burles to buy exactly one candy from the current booth, then he buys it immediately;  then he proceeds to the next booth in the clockwise order (regardless of if he bought a candy or not). \n\nPolycarp's money is finite, thus the process will end once he can no longer buy candy at any booth.\n\nCalculate the number of candies Polycarp will buy.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $T$ ($1 \\le n \\le 2 \\cdot 10^5$, $1 \\le T \\le 10^{18}$) \u2014 the number of booths at the fair and the initial amount of burles Polycarp has.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the price of the single candy at booth number $i$.\n\n\n-----Output-----\n\nPrint a single integer \u2014 the total number of candies Polycarp will buy.\n\n\n-----Examples-----\nInput\n3 38\n5 2 5\n\nOutput\n10\n\nInput\n5 21\n2 4 100 2 6\n\nOutput\n6\n\n\n\n-----Note-----\n\nLet's consider the first example. Here are Polycarp's moves until he runs out of money:  Booth $1$, buys candy for $5$, $T = 33$;  Booth $2$, buys candy for $2$, $T = 31$;  Booth $3$, buys candy for $5$, $T = 26$;  Booth $1$, buys candy for $5$, $T = 21$;  Booth $2$, buys candy for $2$, $T = 19$;  Booth $3$, buys candy for $5$, $T = 14$;  Booth $1$, buys candy for $5$, $T = 9$;  Booth $2$, buys candy for $2$, $T = 7$;  Booth $3$, buys candy for $5$, $T = 2$;  Booth $1$, buys no candy, not enough money;  Booth $2$, buys candy for $2$, $T = 0$. \n\nNo candy can be bought later. The total number of candies bought is $10$.\n\nIn the second example he has $1$ burle left at the end of his path, no candy can be bought with this amount.", "solution": "n,t=map(int,input().split())\na=list(map(int,input().split()))\nsum1=0\nfor i in range(n):\n    sum1+=a[i]\nb=t%sum1\nbought=(t//sum1)*n\nk=0\nl=min(a)\ngone=[0]*n\nwhile b>=l:\n    for i in range(n):\n        if a[i]>b and gone[i]==0:\n            k+=1\n            gone[i]=1\n            sum1-=a[i]\n    bought+=(b//sum1)*(n-k)\n    b=b%sum1\n    if b//sum1==0:\n        for i in range(n):\n            if a[i]<=b:\n                bought+=1\n                b-=a[i]\nprint(bought)", "pass": false}
{"task_id": "0857", "program": "# Read input values\nn, m = map(int, input().split())\nsequence = list(map(int, input().split()))\nfingerprints = set(map(int, input().split()))\n\n# Find the longest subsequence\nresult = [digit for digit in sequence if digit in fingerprints]\n\n# Print the result\nprint(\" \".join(map(str, result)))", "problem": "You are locked in a room with a door that has a keypad with 10 keys corresponding to digits from 0 to 9. To escape from the room, you need to enter a correct code. You also have a sequence of digits.\n\nSome keys on the keypad have fingerprints. You believe the correct code is the longest not necessarily contiguous subsequence of the sequence you have that only contains digits with fingerprints on the corresponding keys. Find such code.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 10$) representing the number of digits in the sequence you have and the number of keys on the keypad that have fingerprints.\n\nThe next line contains $n$ distinct space-separated integers $x_1, x_2, \\ldots, x_n$ ($0 \\le x_i \\le 9$) representing the sequence.\n\nThe next line contains $m$ distinct space-separated integers $y_1, y_2, \\ldots, y_m$ ($0 \\le y_i \\le 9$) \u2014 the keys with fingerprints.\n\n\n-----Output-----\n\nIn a single line print a space-separated sequence of integers representing the code. If the resulting sequence is empty, both printing nothing and printing a single line break is acceptable.\n\n\n-----Examples-----\nInput\n7 3\n3 5 7 1 6 2 8\n1 2 7\n\nOutput\n7 1 2\n\nInput\n4 4\n3 4 1 0\n0 1 7 9\n\nOutput\n1 0\n\n\n\n-----Note-----\n\nIn the first example, the only digits with fingerprints are $1$, $2$ and $7$. All three of them appear in the sequence you know, $7$ first, then $1$ and then $2$. Therefore the output is 7 1 2. Note that the order is important, and shall be the same as the order in the original sequence.\n\nIn the second example digits $0$, $1$, $7$ and $9$ have fingerprints, however only $0$ and $1$ appear in the original sequence. $1$ appears earlier, so the output is 1 0. Again, the order is important.", "solution": "n, m = map(int, input().split())\nxs = list(map(int, input().split()))\nys = set(map(int, input().split()))\nfor i in xs:\n    if i in ys:\n        print(i, end = ' ')", "pass": true}
{"task_id": "0872", "program": "def lexicographically_smallest_array(n, a):\n    # Separate the array into odd and even numbers\n    odd = [x for x in a if x % 2 != 0]\n    even = [x for x in a if x % 2 == 0]\n    \n    # Sort both odd and even numbers\n    odd.sort()\n    even.sort()\n    \n    # Merge the sorted odd and even numbers back into the array\n    result = []\n    odd_index, even_index = 0, 0\n    \n    for num in a:\n        if num % 2 == 0:\n            result.append(even[even_index])\n            even_index += 1\n        else:\n            result.append(odd[odd_index])\n            odd_index += 1\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Get the lexicographically smallest array\nresult = lexicographically_smallest_array(n, a)\n\n# Print the result\nprint(\" \".join(map(str, result)))", "problem": "You're given an array $a$ of length $n$. You can perform the following operation on it as many times as you want:  Pick two integers $i$ and $j$ $(1 \\le i,j \\le n)$ such that $a_i+a_j$ is odd, then swap $a_i$ and $a_j$. \n\nWhat is lexicographically the smallest array you can obtain?\n\nAn array $x$ is lexicographically smaller than an array $y$ if there exists an index $i$ such that $x_i<y_i$, and $x_j=y_j$ for all $1 \\le j < i$. Less formally, at the first index $i$ in which they differ, $x_i<y_i$\n\n\n-----Input-----\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$)\u00a0\u2014 the number of elements in the array $a$.\n\nThe second line contains $n$ space-separated integers $a_1$, $a_2$, $\\ldots$, $a_{n}$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the elements of the array $a$.\n\n\n-----Output-----\n\nThe only line contains $n$ space-separated integers, the lexicographically smallest array you can obtain.\n\n\n-----Examples-----\nInput\n3\n4 1 7\n\nOutput\n1 4 7 \nInput\n2\n1 1\n\nOutput\n1 1 \n\n\n-----Note-----\n\nIn the first example, we can swap $1$ and $4$ since $1+4=5$, which is odd.", "solution": "n=int(input())\na=list(map(int,input().split()))\no=0\ne=0\nfor i in range(n):\n\tif(a[i]%2==0):\n\t\te+=1\n\telse:\n\t\to+=1\nif(o==n or e==n):\n\tprint(*a)\nelse:\n\ta.sort()\n\tprint(*a)", "pass": true}
{"task_id": "0914", "program": "from collections import Counter\n\ndef min_sheets(s, n):\n    # Count the frequency of each character in the string s\n    freq = Counter(s)\n    \n    # Find the maximum frequency of any character\n    max_freq = max(freq.values())\n    \n    # If the maximum frequency of any character is greater than n, it's impossible to form the string\n    if max_freq > n:\n        return -1, \"\"\n    \n    # Calculate the minimum number of sheets required\n    min_sheets = (len(s) + n - 1) // n\n    \n    # Create a string for the sheet of stickers\n    sheet = []\n    for char, count in freq.items():\n        sheet.extend([char] * min(count, n))\n    \n    # If the sheet is shorter than n, fill the rest with any character (e.g., 'a')\n    while len(sheet) < n:\n        sheet.append('a')\n    \n    return min_sheets, ''.join(sheet)\n\n# Read input\ns = input().strip()\nn = int(input().strip())\n\n# Get the result\nsheets, sheet_string = min_sheets(s, n)\n\n# Print the result\nif sheets == -1:\n    print(-1)\nelse:\n    print(sheets)\n    print(sheet_string)", "problem": "Piegirl is buying stickers for a project. Stickers come on sheets, and each sheet of stickers contains exactly n stickers. Each sticker has exactly one character printed on it, so a sheet of stickers can be described by a string of length n. Piegirl wants to create a string s using stickers. She may buy as many sheets of stickers as she wants, and may specify any string of length n for the sheets, but all the sheets must be identical, so the string is the same for all sheets. Once she attains the sheets of stickers, she will take some of the stickers from the sheets and arrange (in any order) them to form s. Determine the minimum number of sheets she has to buy, and provide a string describing a possible sheet of stickers she should buy.\n\n\n-----Input-----\n\nThe first line contains string s (1 \u2264 |s| \u2264 1000), consisting of lowercase English characters only. The second line contains an integer n (1 \u2264 n \u2264 1000).\n\n\n-----Output-----\n\nOn the first line, print the minimum number of sheets Piegirl has to buy. On the second line, print a string consisting of n lower case English characters. This string should describe a sheet of stickers that Piegirl can buy in order to minimize the number of sheets. If Piegirl cannot possibly form the string s, print instead a single line with the number -1.\n\n\n-----Examples-----\nInput\nbanana\n4\n\nOutput\n2\nbaan\n\nInput\nbanana\n3\n\nOutput\n3\nnab\n\nInput\nbanana\n2\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the second example, Piegirl can order 3 sheets of stickers with the characters \"nab\". She can take characters \"nab\" from the first sheet, \"na\" from the second, and \"a\" from the third, and arrange them to from \"banana\".", "solution": "from collections import Counter\n\ns = input()\nn = int(input())\n\nd = Counter()\n\nfor c in s:\n    d[c] += 1\n\nif len(d) > n:\n    print(-1)\nelse:\n    left = 0\n    right = 10**10\n    s = \"\"\n    lastok = (\"\", 0)\n    while left + 1 < right:\n        mid = (left + right) // 2\n        s = \"\"\n        for (c, cnt) in list(d.items()):\n            cntnow = (cnt - 1) // mid + 1\n            s += c * cntnow\n        if len(s) < n:\n            s += 'a' * (n - len(s))\n        if len(s) == n:\n            lastok = (s, mid)\n            right = mid\n        else:\n            left = mid\n    print(lastok[1])\n    print(lastok[0])\n", "pass": false}
{"task_id": "0933", "program": "def correct_typos(s):\n    t = []\n    for char in s:\n        t.append(char)\n        if len(t) >= 3 and t[-1] == t[-2] == t[-3]:\n            t.pop()\n        if len(t) >= 4 and t[-1] == t[-2] and t[-3] == t[-4]:\n            t.pop()\n    return ''.join(t)\n\n# Read input\ns = input().strip()\n\n# Correct typos\nresult = correct_typos(s)\n\n# Print the result\nprint(result)", "problem": "Many modern text editors automatically check the spelling of the user's text. Some editors even suggest how to correct typos.\n\nIn this problem your task to implement a small functionality to correct two types of typos in a word. We will assume that three identical letters together is a typo (for example, word \"helllo\" contains a typo). Besides, a couple of identical letters immediately followed by another couple of identical letters is a typo too (for example, words \"helloo\" and \"wwaatt\" contain typos).\n\nWrite a code that deletes the minimum number of letters from a word, correcting described typos in the word. You are allowed to delete letters from both ends and from the middle of the word.\n\n\n-----Input-----\n\nThe single line of the input contains word s, its length is from 1 to 200000 characters. The given word s consists of lowercase English letters.\n\n\n-----Output-----\n\nPrint such word t that it doesn't contain any typos described in the problem statement and is obtained from s by deleting the least number of letters.\n\nIf there are multiple solutions, print any of them.\n\n\n-----Examples-----\nInput\nhelloo\n\nOutput\nhello\n\nInput\nwoooooow\n\nOutput\nwoow\n\n\n\n-----Note-----\n\nThe second valid answer to the test from the statement is \"heloo\".", "solution": "import sys\nimport math            \n\ns = input()\nl = len(s)\n\np = '1'\nk = 0\nv = 1\nres = []\nfor i in range(l):\n    if(p != s[i]):\n        p = s[i]\n        if(v == 1):\n            k = 0\n        v = 1\n        res.append(p)\n    else:\n        v += 1\n        if(v == 2):\n            if(k % 2 == 0):\n                res.append(p)\n                k = 1\n            else:\n                 k = 0\n\nprint(\"\".join(res))", "pass": true}
{"task_id": "0960", "program": "def find_smallest_x(n, k):\n    for b in range(1, k):\n        if n % b == 0:\n            a = n // b\n            x = a * k + b\n            return x\n\n# Read input\nn, k = map(int, input().split())\n\n# Find and print the smallest x\nprint(find_smallest_x(n, k))", "problem": "Vasya likes to solve equations. Today he wants to solve $(x~\\mathrm{div}~k) \\cdot (x \\bmod k) = n$, where $\\mathrm{div}$ and $\\mathrm{mod}$ stand for integer division and modulo operations (refer to the Notes below for exact definition). In this equation, $k$ and $n$ are positive integer parameters, and $x$ is a positive integer unknown. If there are several solutions, Vasya wants to find the smallest possible $x$. Can you help him?\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ ($1 \\leq n \\leq 10^6$, $2 \\leq k \\leq 1000$).\n\n\n-----Output-----\n\nPrint a single integer $x$\u00a0\u2014 the smallest positive integer solution to $(x~\\mathrm{div}~k) \\cdot (x \\bmod k) = n$. It is guaranteed that this equation has at least one positive integer solution.\n\n\n-----Examples-----\nInput\n6 3\n\nOutput\n11\n\nInput\n1 2\n\nOutput\n3\n\nInput\n4 6\n\nOutput\n10\n\n\n\n-----Note-----\n\nThe result of integer division $a~\\mathrm{div}~b$ is equal to the largest integer $c$ such that $b \\cdot c \\leq a$. $a$ modulo $b$ (shortened $a \\bmod b$) is the only integer $c$ such that $0 \\leq c < b$, and $a - c$ is divisible by $b$.\n\nIn the first sample, $11~\\mathrm{div}~3 = 3$ and $11 \\bmod 3 = 2$. Since $3 \\cdot 2 = 6$, then $x = 11$ is a solution to $(x~\\mathrm{div}~3) \\cdot (x \\bmod 3) = 6$. One can see that $19$ is the only other positive integer solution, hence $11$ is the smallest one.", "solution": "n, k = map(int, input().split())\nmod = k-1\nwhile n//mod != n/mod:\n    mod-=1\nt = n//mod\nprint(t*k+mod)", "pass": false}
{"task_id": "0998", "program": "def construct_array(n, x):\n    max_val = 1 << n\n    if x >= max_val:\n        return 0, []\n\n    # Initialize the array with all possible values\n    array = list(range(1, max_val))\n    result = []\n    current_xor = 0\n\n    for num in array:\n        if current_xor ^ num != x:\n            result.append(num)\n            current_xor ^= num\n\n    return len(result), result\n\n# Read input\nn, x = map(int, input().strip().split())\n\n# Get the result\nlength, result_array = construct_array(n, x)\n\n# Print the result\nprint(length)\nif length > 0:\n    print(\" \".join(map(str, result_array)))", "problem": "Given two integers $n$ and $x$, construct an array that satisfies the following conditions:   for any element $a_i$ in the array, $1 \\le a_i<2^n$;  there is no non-empty subsegment with bitwise XOR equal to $0$ or $x$,  its length $l$ should be maximized. \n\nA sequence $b$ is a subsegment of a sequence $a$ if $b$ can be obtained from $a$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\n\n-----Input-----\n\nThe only line contains two integers $n$ and $x$ ($1 \\le n \\le 18$, $1 \\le x<2^{18}$).\n\n\n-----Output-----\n\nThe first line should contain the length of the array $l$.\n\nIf $l$ is positive, the second line should contain $l$ space-separated integers $a_1$, $a_2$, $\\dots$, $a_l$ ($1 \\le a_i < 2^n$)\u00a0\u2014 the elements of the array $a$.\n\nIf there are multiple solutions, print any of them.\n\n\n-----Examples-----\nInput\n3 5\n\nOutput\n3\n6 1 3\nInput\n2 4\n\nOutput\n3\n1 3 1 \nInput\n1 1\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example, the bitwise XOR of the subsegments are $\\{6,7,4,1,2,3\\}$.", "solution": "n, x = list(map(int ,input().split()))\na = []; d = {0:True}; d1=[0]\nif (x<(1<<n)):\n\n    \n\n    for t in range(1, 1<<n):\n        \n        if not d.get(t^x, False):\n            a.append(t^d1[-1])\n            d[t] = True\n            d1.append(t)\n    print(len(a))\n    print(\" \".join(map(str,a)))\nelse:\n    for t in range(1, (1<<n)):\n        \n        \n        a.append(t^(t-1))  \n    print(len(a))\n    print(\" \".join(map(str,a)))\n      \n", "pass": false}
{"task_id": "1012", "program": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef solve_queries(queries):\n    results = []\n    for s in queries:\n        if len(s) == 1:\n            results.append(\"-1\")\n        else:\n            sorted_s = ''.join(sorted(s))\n            if is_palindrome(sorted_s):\n                results.append(\"-1\")\n            else:\n                results.append(sorted_s)\n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nqueries = data[1:t+1]\n\n# Solve the queries\nresults = solve_queries(queries)\n\n# Print the results\nfor result in results:\n    print(result)", "problem": "You are given a string $s$ consisting only of lowercase Latin letters.\n\nYou can rearrange all letters of this string as you wish. Your task is to obtain a good string by rearranging the letters of the given string or report that it is impossible to do it.\n\nLet's call a string good if it is not a palindrome. Palindrome is a string which is read from left to right the same as from right to left. For example, strings \"abacaba\", \"aa\" and \"z\" are palindromes and strings \"bba\", \"xd\" are not.\n\nYou have to answer $t$ independent queries.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 100$) \u2014 number of queries.\n\nEach of the next $t$ lines contains one string. The $i$-th line contains a string $s_i$ consisting only of lowercase Latin letter. It is guaranteed that the length of $s_i$ is from $1$ to $1000$ (inclusive).\n\n\n-----Output-----\n\nPrint $t$ lines. In the $i$-th line print the answer to the $i$-th query: -1 if it is impossible to obtain a good string by rearranging the letters of $s_i$ and any good string which can be obtained from the given one (by rearranging the letters) otherwise.\n\n\n-----Example-----\nInput\n3\naa\nabacaba\nxdd\n\nOutput\n-1\nabaacba\nxdd\n\n\n-----Note-----\n\nIn the first query we cannot rearrange letters to obtain a good string.\n\nOther examples (not all) of correct answers to the second query: \"ababaca\", \"abcabaa\", \"baacaba\".\n\nIn the third query we can do nothing to obtain a good string.", "solution": "t = int(input())\nfor i in range(t):\n    s = input()\n    r = ''.join(sorted(list(s)))\n    if r[0] == r[-1]:\n        print(-1)\n    else:\n        print(r)\n\n", "pass": true}
{"task_id": "1025", "program": "def count_non_zero_area_triangles(n, points):\n    def area(x1, y1, x2, y2, x3, y3):\n        return abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2\n\n    if n < 3:\n        return 0\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if area(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]) > 0:\n                    count += 1\n\n    return count\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Calculate and print the result\nprint(count_non_zero_area_triangles(n, points))", "problem": "Vanya got bored and he painted n distinct points on the plane. After that he connected all the points pairwise and saw that as a result many triangles were formed with vertices in the painted points. He asks you to count the number of the formed triangles with the non-zero area.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 2000) \u2014 the number of the points painted on the plane. \n\nNext n lines contain two integers each x_{i}, y_{i} ( - 100 \u2264 x_{i}, y_{i} \u2264 100) \u2014 the coordinates of the i-th point. It is guaranteed that no two given points coincide.\n\n\n-----Output-----\n\nIn the first line print an integer \u2014 the number of triangles with the non-zero area among the painted points.\n\n\n-----Examples-----\nInput\n4\n0 0\n1 1\n2 0\n2 2\n\nOutput\n3\n\nInput\n3\n0 0\n1 1\n2 0\n\nOutput\n1\n\nInput\n1\n1 1\n\nOutput\n0\n\n\n\n-----Note-----\n\nNote to the first sample test. There are 3 triangles formed: (0, 0) - (1, 1) - (2, 0); (0, 0) - (2, 2) - (2, 0); (1, 1) - (2, 2) - (2, 0).\n\nNote to the second sample test. There is 1 triangle formed: (0, 0) - (1, 1) - (2, 0).\n\nNote to the third sample test. A single point doesn't form a single triangle.", "solution": "def main():\n    import sys\n    from collections import defaultdict\n    from fractions import gcd\n    \n    normalize = [[0] * 405 for i in range(405)]\n    for x in range(-200, 201):\n        for y in range(-200, 201):\n            if x == 0 and y == 0:\n                continue\n            nx, ny = x, y\n            g = abs(gcd(x, y))\n            nx //= g\n            ny //= g\n            if nx < 0 or nx == 0 and ny < 0:\n                nx = -nx\n                ny = -ny\n            nx += 200\n            ny += 200\n            normalize[x][y] = nx * 401 + ny\n            \n    \n    tokens = [int(i) for i in sys.stdin.read().split()]\n    tokens.reverse()\n    \n    n = tokens.pop()\n    points = [(tokens.pop(), tokens.pop()) for i in range(n)]\n    \n    result = 0\n    angles = [0] * 170000\n    for i in range(n):\n        x0, y0 = points[i]\n        for j in range(i + 1, n):\n            x, y = points[j]\n            angles[normalize[x - x0][y - y0]] += 1\n        for j in range(i + 1, n):\n            x, y = points[j]\n            k = angles[normalize[x - x0][y - y0]]\n            result += k * (n - i - 1 - k)\n            angles[normalize[x - x0][y - y0]] = 0\n    \n    print(result // 2)\n        \n        \n    \nmain()\n", "pass": true}
{"task_id": "1058", "program": "def max_valid_sequence_value(n, blocks):\n    from collections import defaultdict\n    import itertools\n\n    # Create a graph where each node is a color and edges are blocks\n    graph = defaultdict(list)\n    for color1, value, color2 in blocks:\n        graph[color1].append((value, color2))\n        graph[color2].append((value, color1))\n\n    # Function to find the maximum value path starting from a given color\n    def dfs(color, visited):\n        max_value = 0\n        for value, next_color in graph[color]:\n            if (color, next_color) not in visited and (next_color, color) not in visited:\n                visited.add((color, next_color))\n                max_value = max(max_value, value + dfs(next_color, visited))\n                visited.remove((color, next_color))\n        return max_value\n\n    # Try to start from each color and find the maximum value path\n    max_total_value = 0\n    for color in range(1, 5):\n        max_total_value = max(max_total_value, dfs(color, set()))\n\n    return max_total_value\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nblocks = []\nindex = 1\nfor i in range(n):\n    color1 = int(data[index])\n    value = int(data[index + 1])\n    color2 = int(data[index + 2])\n    blocks.append((color1, value, color2))\n    index += 3\n\n# Get the result and print it\nresult = max_valid_sequence_value(n, blocks)\nprint(result)", "problem": "You are given $n$ blocks, each of them is of the form [color$_1$|value|color$_2$], where the block can also be flipped to get [color$_2$|value|color$_1$]. \n\nA sequence of blocks is called valid if the touching endpoints of neighboring blocks have the same color. For example, the sequence of three blocks A, B and C is valid if the left color of the B is the same as the right color of the A and the right color of the B is the same as the left color of C.\n\nThe value of the sequence is defined as the sum of the values of the blocks in this sequence.\n\nFind the maximum possible value of the valid sequence that can be constructed from the subset of the given blocks. The blocks from the subset can be reordered and flipped if necessary. Each block can be used at most once in the sequence.\n\n\n-----Input-----\n\nThe first line of input contains a single integer $n$ ($1 \\le n \\le 100$)\u00a0\u2014 the number of given blocks.\n\nEach of the following $n$ lines describes corresponding block and consists of $\\mathrm{color}_{1,i}$, $\\mathrm{value}_i$ and $\\mathrm{color}_{2,i}$ ($1 \\le \\mathrm{color}_{1,i}, \\mathrm{color}_{2,i} \\le 4$, $1 \\le \\mathrm{value}_i \\le 100\\,000$).\n\n\n-----Output-----\n\nPrint exactly one integer\u00a0\u2014 the maximum total value of the subset of blocks, which makes a valid sequence.\n\n\n-----Examples-----\nInput\n6\n2 1 4\n1 2 4\n3 4 4\n2 8 3\n3 16 3\n1 32 2\n\nOutput\n63\nInput\n7\n1 100000 1\n1 100000 2\n1 100000 2\n4 50000 3\n3 50000 4\n4 50000 4\n3 50000 3\n\nOutput\n300000\nInput\n4\n1 1000 1\n2 500 2\n3 250 3\n4 125 4\n\nOutput\n1000\n\n\n-----Note-----\n\nIn the first example, it is possible to form a valid sequence from all blocks.\n\nOne of the valid sequences is the following:\n\n[4|2|1] [1|32|2] [2|8|3] [3|16|3] [3|4|4] [4|1|2]\n\nThe first block from the input ([2|1|4] $\\to$ [4|1|2]) and second ([1|2|4] $\\to$ [4|2|1]) are flipped.\n\nIn the second example, the optimal answers can be formed from the first three blocks as in the following (the second or the third block from the input is flipped):\n\n[2|100000|1] [1|100000|1] [1|100000|2]\n\nIn the third example, it is not possible to form a valid sequence of two or more blocks, so the answer is a sequence consisting only of the first block since it is the block with the largest value.", "solution": "n=int(input())\nmv = 10**9\nf = [0 for i in range(4)]\nadj = [[i == j for j in range(4)] for i in range(4)]\nw = [0 for i in range(4)]\nfor _ in range(n):\n a,v,b=map(int,input().split())\n a-=1\n b-=1\n if a!=b: mv = min(mv, v)\n f[a]^=1\n f[b]^=1\n w[a] += v\n adj[a][b] = adj[b][a] = True\nfor k in range(4):\n for i in range(4):\n  for j in range(4):\n   if adj[i][k] and adj[k][j]: adj[i][j] = True\nif all(adj[0]) and all(f):\n print(sum(w) - mv)\nelse:\n print(max(sum(w[j] for j in range(4) if adj[i][j]) for i in range(4)))", "pass": false}
{"task_id": "1078", "program": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    b = []\n    sum_b = 0\n    \n    for ai in a:\n        bi = ai // 2\n        b.append(bi)\n        sum_b += bi\n    \n    for i in range(n):\n        if sum_b == 0:\n            break\n        if a[i] % 2 != 0:\n            if sum_b > 0 and a[i] < 0:\n                b[i] -= 1\n                sum_b -= 1\n            elif sum_b < 0 and a[i] > 0:\n                b[i] += 1\n                sum_b += 1\n    \n    print(\"\\n\".join(map(str, b)))\n\nsolve()", "problem": "Another Codeforces Round has just finished! It has gathered $n$ participants, and according to the results, the expected rating change of participant $i$ is $a_i$. These rating changes are perfectly balanced\u00a0\u2014 their sum is equal to $0$.\n\nUnfortunately, due to minor technical glitches, the round is declared semi-rated. It means that all rating changes must be divided by two.\n\nThere are two conditions though:   For each participant $i$, their modified rating change $b_i$ must be integer, and as close to $\\frac{a_i}{2}$ as possible. It means that either $b_i = \\lfloor \\frac{a_i}{2} \\rfloor$ or $b_i = \\lceil \\frac{a_i}{2} \\rceil$. In particular, if $a_i$ is even, $b_i = \\frac{a_i}{2}$. Here $\\lfloor x \\rfloor$ denotes rounding down to the largest integer not greater than $x$, and $\\lceil x \\rceil$ denotes rounding up to the smallest integer not smaller than $x$.  The modified rating changes must be perfectly balanced\u00a0\u2014 their sum must be equal to $0$. \n\nCan you help with that?\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($2 \\le n \\le 13\\,845$), denoting the number of participants.\n\nEach of the next $n$ lines contains a single integer $a_i$ ($-336 \\le a_i \\le 1164$), denoting the rating change of the $i$-th participant.\n\nThe sum of all $a_i$ is equal to $0$.\n\n\n-----Output-----\n\nOutput $n$ integers $b_i$, each denoting the modified rating change of the $i$-th participant in order of input.\n\nFor any $i$, it must be true that either $b_i = \\lfloor \\frac{a_i}{2} \\rfloor$ or $b_i = \\lceil \\frac{a_i}{2} \\rceil$. The sum of all $b_i$ must be equal to $0$.\n\nIf there are multiple solutions, print any. We can show that a solution exists for any valid input.\n\n\n-----Examples-----\nInput\n3\n10\n-5\n-5\n\nOutput\n5\n-2\n-3\n\nInput\n7\n-7\n-29\n0\n3\n24\n-29\n38\n\nOutput\n-3\n-15\n0\n2\n12\n-15\n19\n\n\n\n-----Note-----\n\nIn the first example, $b_1 = 5$, $b_2 = -3$ and $b_3 = -2$ is another correct solution.\n\nIn the second example there are $6$ possible solutions, one of them is shown in the example output.", "solution": "n=int(input())\nmod=1\nfor _ in range(n):\n\ta=int(input())\n\tif(a%2)==0:\n\t\tprint(a//2)\n\telse:\n\t\tprint(a//2 + mod)\n\t\tmod=1-mod\n\n", "pass": false}
{"task_id": "1088", "program": "MOD = 998244353\n\ndef find_permutations(N, K, matrix):\n    def can_swap_columns(x, y):\n        for i in range(N):\n            if matrix[i][x] + matrix[i][y] > K:\n                return False\n        return True\n\n    def can_swap_rows(x, y):\n        for i in range(N):\n            if matrix[x][i] + matrix[y][i] > K:\n                return False\n        return True\n\n    def find_swappable_groups(can_swap_func):\n        parent = list(range(N))\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                parent[rootY] = rootX\n\n        for i in range(N):\n            for j in range(i + 1, N):\n                if can_swap_func(i, j):\n                    union(i, j)\n\n        groups = {}\n        for i in range(N):\n            root = find(i)\n            if root not in groups:\n                groups[root] = []\n            groups[root].append(i)\n\n        return groups\n\n    def factorial(n):\n        result = 1\n        for i in range(2, n + 1):\n            result = (result * i) % MOD\n        return result\n\n    column_groups = find_swappable_groups(can_swap_columns)\n    row_groups = find_swappable_groups(can_swap_rows)\n\n    column_permutations = 1\n    for group in column_groups.values():\n        column_permutations = (column_permutations * factorial(len(group))) % MOD\n\n    row_permutations = 1\n    for group in row_groups.values():\n        row_permutations = (row_permutations * factorial(len(group))) % MOD\n\n    return (column_permutations * row_permutations) % MOD\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nmatrix = []\nindex = 2\nfor i in range(N):\n    row = list(map(int, data[index:index + N]))\n    matrix.append(row)\n    index += N\n\nprint(find_permutations(N, K, matrix))", "problem": "Given are an N \\times N matrix and an integer K. The entry in the i-th row and j-th column of this matrix is denoted as a_{i, j}. This matrix contains each of 1, 2, \\dots, N^2 exactly once.\nSigma can repeat the following two kinds of operation arbitrarily many times in any order.\n - Pick two integers x, y (1 \\leq x < y \\leq N) that satisfy a_{i, x} + a_{i, y} \\leq K for all i (1 \\leq i \\leq N) and swap the x-th and the y-th columns.\n - Pick two integers x, y (1 \\leq x < y \\leq N) that satisfy a_{x, i} + a_{y, i} \\leq K for all i (1 \\leq i \\leq N) and swap the x-th and the y-th rows.\nHow many matrices can he obtain by these operations? Find it modulo 998244353.\n\n-----Constraints-----\n - 1 \\leq N \\leq 50\n - 1 \\leq K \\leq 2 \\times N^2\n - a_{i, j}'s are a rearrangement of 1, 2, \\dots, N^2.\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN K\na_{1, 1} a_{1, 2} ... a_{1, N}\na_{2, 1} a_{2, 2} ... a_{2, N}\n:\na_{N, 1} a_{N, 2} ... a_{N, N}\n\n-----Output-----\nPrint the number of matrices Sigma can obtain modulo 998244353.\n\n-----Sample Input-----\n3 13\n3 2 7\n4 8 9\n1 6 5\n\n-----Sample Output-----\n12\n\nFor example, Sigma can swap two columns, by setting x = 1, y = 2. After that, the resulting matrix will be:\n2 3 7\n8 4 9\n6 1 5\n\nAfter that, he can swap two row vectors by setting x = 1, y = 3, resulting in the following matrix:\n6 1 5\n8 4 9\n2 3 7", "solution": "\nimport itertools,math\nfrom collections import defaultdict\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in list(self.all_group_members().items()))\nn,k = list(map(int,input().split()))\na = [list(map(int,input().split())) for i in range(n)]\na_row = []\na_column = []\nfor i in itertools.combinations(list(range(n)),2):\n    for j in range(n):\n        if a[i[0]][j] + a[i[1]][j] > k:\n            break\n        if j == n - 1:\n            a_row.append(i)\n    for j in range(n):\n        if a[j][i[0]] + a[j][i[1]] > k:\n            break\n        if j == n - 1:\n            a_column.append(i)\nuf_row = UnionFind(n)\nuf_column = UnionFind(n)\nfor i in a_row:\n    uf_row.union(i[0],i[1])\nfor i in a_column:\n    uf_column.union(i[0],i[1])\nans = 1\nfor i in list(uf_row.all_group_members().values()):\n    ans = ans * math.factorial(len(i)) % 998244353\nfor i in list(uf_column.all_group_members().values()):\n    ans = ans * math.factorial(len(i)) % 998244353\nprint(ans)\n", "pass": true}
{"task_id": "1091", "program": "# Read the number of bidders\nn = int(input().strip())\n\n# Read the bids\nbids = list(map(int, input().strip().split()))\n\n# Find the highest bid and its index\nmax_bid = max(bids)\nwinner_index = bids.index(max_bid) + 1\n\n# Remove the highest bid to find the second highest bid\nbids.remove(max_bid)\nsecond_highest_bid = max(bids)\n\n# Output the winner index and the second highest bid\nprint(winner_index, second_highest_bid)", "problem": "In this problem we consider a special type of an auction, which is called the second-price auction. As in regular auction n bidders place a bid which is price a bidder ready to pay. The auction is closed, that is, each bidder secretly informs the organizer of the auction price he is willing to pay. After that, the auction winner is the participant who offered the highest price. However, he pay not the price he offers, but the highest price among the offers of other participants (hence the name: the second-price auction).\n\nWrite a program that reads prices offered by bidders and finds the winner and the price he will pay. Consider that all of the offered prices are different.\n\n\n-----Input-----\n\nThe first line of the input contains n (2 \u2264 n \u2264 1000) \u2014 number of bidders. The second line contains n distinct integer numbers p_1, p_2, ... p_{n}, separated by single spaces (1 \u2264 p_{i} \u2264 10000), where p_{i} stands for the price offered by the i-th bidder.\n\n\n-----Output-----\n\nThe single output line should contain two integers: index of the winner and the price he will pay. Indices are 1-based.\n\n\n-----Examples-----\nInput\n2\n5 7\n\nOutput\n2 5\n\nInput\n3\n10 2 8\n\nOutput\n1 8\n\nInput\n6\n3 8 2 9 4 14\n\nOutput\n6 9", "solution": "'''\n    CodeForces problem 386A\n    26/01/2014\n'''\n\n# (x, y) = (offerta, tizio)\nn = int( input() )\nl = [ int(x) for x in input().split()]\ni=1\noff = []\nfor x in l:\n    off.append( (x, i) )\n    i+=1\n    \noff.sort( reverse=True )    \n\nprint(str(off[0][1])+' '+str(off[1][0]))\n", "pass": true}
{"task_id": "1122", "program": "def atcoder_janken(N, M):\n    pairs = []\n    for i in range(1, M + 1):\n        pairs.append((i, N - i + 1))\n    for a, b in pairs:\n        print(a, b)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split()\nN = int(data[0])\nM = int(data[1])\n\n# Generate and print the pairs\natcoder_janken(N, M)", "problem": "You are going to hold a competition of one-to-one game called AtCoder Janken. (Janken is the Japanese name for Rock-paper-scissors.)N players will participate in this competition, and they are given distinct integers from 1 through N.\nThe arena has M playing fields for two players. You need to assign each playing field two distinct integers between 1 and N (inclusive).\nYou cannot assign the same integer to multiple playing fields.\nThe competition consists of N rounds, each of which proceeds as follows:\n - For each player, if there is a playing field that is assigned the player's integer, the player goes to that field and fight the other player who comes there.\n - Then, each player adds 1 to its integer. If it becomes N+1, change it to 1.\nYou want to ensure that no player fights the same opponent more than once during the N rounds.\nPrint an assignment of integers to the playing fields satisfying this condition.\nIt can be proved that such an assignment always exists under the constraints given.\n\n-----Constraints-----\n - 1 \\leq M\n - M \\times 2 +1 \\leq N \\leq 200000\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\n\n-----Output-----\nPrint M lines in the format below.\nThe i-th line should contain the two integers a_i and b_i assigned to the i-th playing field.\na_1 b_1\na_2 b_2\n:\na_M b_M\n\n-----Sample Input-----\n4 1\n\n-----Sample Output-----\n2 3\n\nLet us call the four players A, B, C, and D, and assume that they are initially given the integers 1, 2, 3, and 4, respectively.\n - The 1-st round is fought by B and C, who has the integers 2 and 3, respectively. After this round, A, B, C, and D have the integers 2, 3, 4, and 1, respectively.\n - The 2-nd round is fought by A and B, who has the integers 2 and 3, respectively. After this round, A, B, C, and D have the integers 3, 4, 1, and 2, respectively.\n - The 3-rd round is fought by D and A, who has the integers 2 and 3, respectively. After this round, A, B, C, and D have the integers 4, 1, 2, and 3, respectively.\n - The 4-th round is fought by C and D, who has the integers 2 and 3, respectively. After this round, A, B, C, and D have the integers 1, 2, 3, and 4, respectively.\nNo player fights the same opponent more than once during the four rounds, so this solution will be accepted.", "solution": "N,M=map(int,input().split())\n\nif M%2==0:\n  for i in range(M//2):\n    print(i+1,M-i)\n  for i in range(M//2):\n    print(M+i+1,2*M-i+1)  \nelse:\n  for i in range(M//2):\n    print(i+1,M-i)\n  for i in range(M//2+1):\n    print(M+i+1,2*M-i+1)", "pass": false}
{"task_id": "1147", "program": "def count_pairs(n, x, k, a):\n    a.sort()\n    count = 0\n\n    for i in range(n):\n        left = a[i]\n        if k == 0:\n            # We need to find pairs (i, j) such that a[i] <= a[j] and no number between them is divisible by x\n            # This means a[j] should be less than the next multiple of x greater than a[i]\n            next_multiple = ((left // x) + 1) * x\n            j = i\n            while j < n and a[j] < next_multiple:\n                j += 1\n            count += j - i\n        else:\n            # We need to find pairs (i, j) such that there are exactly k numbers divisible by x between a[i] and a[j]\n            # This means a[j] should be at least left + k * x and less than left + (k + 1) * x\n            lower_bound = left + k * x\n            upper_bound = left + (k + 1) * x\n            j = i\n            while j < n and a[j] < lower_bound:\n                j += 1\n            start = j\n            while j < n and a[j] < upper_bound:\n                j += 1\n            count += j - start\n\n    return count\n\n# Read input\nn, x, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nresult = count_pairs(n, x, k, a)\n\n# Print the result\nprint(result)", "problem": "While Vasya finished eating his piece of pizza, the lesson has already started. For being late for the lesson, the teacher suggested Vasya to solve one interesting problem. Vasya has an array a and integer x. He should find the number of different ordered pairs of indexes (i, j) such that a_{i} \u2264 a_{j} and there are exactly k integers y such that a_{i} \u2264 y \u2264 a_{j} and y is divisible by x.\n\nIn this problem it is meant that pair (i, j) is equal to (j, i) only if i is equal to j. For example pair (1, 2) is not the same as (2, 1).\n\n\n-----Input-----\n\nThe first line contains 3 integers n, x, k (1 \u2264 n \u2264 10^5, 1 \u2264 x \u2264 10^9, 0 \u2264 k \u2264 10^9), where n is the size of the array a and x and k are numbers from the statement.\n\nThe second line contains n integers a_{i} (1 \u2264 a_{i} \u2264 10^9)\u00a0\u2014 the elements of the array a.\n\n\n-----Output-----\n\nPrint one integer\u00a0\u2014 the answer to the problem.\n\n\n-----Examples-----\nInput\n4 2 1\n1 3 5 7\n\nOutput\n3\n\nInput\n4 2 0\n5 3 1 7\n\nOutput\n4\n\nInput\n5 3 1\n3 3 3 3 3\n\nOutput\n25\n\n\n\n-----Note-----\n\nIn first sample there are only three suitable pairs of indexes\u00a0\u2014 (1, 2), (2, 3), (3, 4).\n\nIn second sample there are four suitable pairs of indexes(1, 1), (2, 2), (3, 3), (4, 4).\n\nIn third sample every pair (i, j) is suitable, so the answer is 5 * 5 = 25.", "solution": "n,x,k=list(map(int,input().split()))\na=list(map(int,input().split()))\nfrom collections import Counter\nans=0\nif k!=0:\n    dn=Counter()\n    un=Counter()\n    for i in a:\n        dn[i//x]+=1\n        un[(i-0.1)//x]+=1\n    for item,kol in list(un.items()):\n        ans+=kol*dn[item+k]\n    print(ans)\nelse:\n    dn = Counter()\n    un = Counter()\n    s=set()\n    for i in a:\n        if i%x!=0:\n            un[i]+=1\n            dn[i//x]+=1\n    #print(dn,un,sep='\\n')\n    for item, kol in list(dn.items()):\n        ans += kol*(kol+1)//2\n    for item, kol in list(un.items()):\n        ans += kol*(kol-1)//2\n    print(ans)\n", "pass": false}
{"task_id": "1173", "program": "def tennis_tournament(N, matches):\n    from collections import deque, defaultdict\n\n    # Create a list of deques for each player to store their match order\n    match_order = [deque(matches[i]) for i in range(N)]\n    \n    # Create a dictionary to store the current match day for each pair\n    match_day = defaultdict(int)\n    \n    # Initialize the current day\n    current_day = 0\n    \n    # While there are still matches to be scheduled\n    while True:\n        # Track if any match is scheduled on this day\n        scheduled = False\n        \n        # Track the players who have already played today\n        played_today = set()\n        \n        # Try to schedule matches for each player\n        for i in range(N):\n            if i in played_today or not match_order[i]:\n                continue\n            \n            opponent = match_order[i][0] - 1\n            if opponent in played_today or not match_order[opponent]:\n                continue\n            \n            if match_order[opponent][0] - 1 == i:\n                # Schedule the match\n                match_order[i].popleft()\n                match_order[opponent].popleft()\n                played_today.add(i)\n                played_today.add(opponent)\n                scheduled = True\n        \n        if not scheduled:\n            break\n        \n        current_day += 1\n    \n    # Check if all matches are scheduled\n    for i in range(N):\n        if match_order[i]:\n            return -1\n    \n    return current_day\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nmatches = []\nindex = 1\nfor i in range(N):\n    matches.append([int(data[index + j]) for j in range(N - 1)])\n    index += (N - 1)\n\n# Output the result\nprint(tennis_tournament(N, matches))", "problem": "N players will participate in a tennis tournament. We will call them Player 1, Player 2, \\ldots, Player N.\nThe tournament is round-robin format, and there will be N(N-1)/2 matches in total.\nIs it possible to schedule these matches so that all of the following conditions are satisfied? If the answer is yes, also find the minimum number of days required.\n - Each player plays at most one matches in a day.\n - Each player i (1 \\leq i \\leq N) plays one match against Player A_{i, 1}, A_{i, 2}, \\ldots, A_{i, N-1} in this order.\n\n-----Constraints-----\n - 3 \\leq N \\leq 1000\n - 1 \\leq A_{i, j} \\leq N\n - A_{i, j} \\neq i\n - A_{i, 1}, A_{i, 2}, \\ldots, A_{i, N-1} are all different.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nA_{1, 1} A_{1, 2} \\ldots A_{1, N-1}\nA_{2, 1} A_{2, 2} \\ldots A_{2, N-1}\n:\nA_{N, 1} A_{N, 2} \\ldots A_{N, N-1}\n\n-----Output-----\nIf it is possible to schedule all the matches so that all of the conditions are satisfied, print the minimum number of days required; if it is impossible, print -1.\n\n-----Sample Input-----\n3\n2 3\n1 3\n1 2\n\n-----Sample Output-----\n3\n\nAll the conditions can be satisfied if the matches are scheduled for three days as follows:\n - Day 1: Player 1 vs Player 2\n - Day 2: Player 1 vs Player 3\n - Day 3: Player 2 vs Player 3\nThis is the minimum number of days required.", "solution": "from collections import deque\nfrom typing import List\n\n\ndef get_longest_path_depth(\n    graph: List[List[int]], in_degrees: List[int], first_index: int = 0\n) -> int:\n    \"\"\"Return the depth of the longest path of DAG.\n    if the given graph is not DAG, -1 is returned.\n    \"\"\"\n    V = len(graph) + first_index\n    queue = deque()\n    depths = [-1] * V  # depths[i] := the length of the longest path to V_i\n    for i in range(first_index, V):\n        if not in_degrees[i]:\n            queue.append(i)\n            depths[i] = 0\n\n    while queue:\n        u = queue.popleft()\n        cur_depth = depths[u]\n        for v in graph[u]:\n            in_degrees[v] -= 1\n            if not in_degrees[v]:\n                depths[v] = max(depths[v], cur_depth + 1)\n                queue.append(v)\n\n    return max(depths) if -1 not in depths else -1\n\n\ndef abc139_e():\n    N, *A = list(map(int, open(0).read().split()))\n\n    ids = [[-1] * (N + 1) for _ in range(N + 1)]\n    cur_id = 0\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            ids[i][j] = ids[j][i] = cur_id\n            cur_id += 1\n\n    graph = [[] for _ in range(N * (N - 1) // 2)]\n    in_degrees = [0] * (N * (N - 1) // 2)\n    for i, a in enumerate(zip(*[iter(A)] * (N - 1)), 1):\n        source = -1\n        for j in a:\n            target = ids[i][j]\n            if source != -1:\n                graph[source].append(target)\n                in_degrees[target] += 1\n            source = target\n\n    depth = get_longest_path_depth(graph, in_degrees)\n    print((depth + 1 if depth != -1 else -1))\n\n\ndef __starting_point():\n    abc139_e()\n\n__starting_point()", "pass": false}
{"task_id": "1181", "program": "def min_page_turns(n, m, a):\n    if m == 1:\n        return 0\n\n    # Calculate the initial number of page turns\n    initial_turns = sum(abs(a[i] - a[i - 1]) for i in range(1, m))\n\n    # If there's only one page, no need to merge\n    if n == 1:\n        return initial_turns\n\n    # Calculate the total number of turns if we merge each page to another\n    min_turns = initial_turns\n\n    # We will use a dictionary to count the frequency of each page\n    from collections import defaultdict\n    freq = defaultdict(int)\n    for page in a:\n        freq[page] += 1\n\n    # Calculate the total cost of turning pages\n    total_cost = defaultdict(int)\n    for i in range(1, m):\n        total_cost[a[i]] += abs(a[i] - a[i - 1])\n        total_cost[a[i - 1]] += abs(a[i] - a[i - 1])\n\n    # Try merging each page to another and calculate the new number of turns\n    for x in range(1, n + 1):\n        current_turns = initial_turns\n        for y in range(1, n + 1):\n            if x != y:\n                # Calculate the cost of merging x to y\n                merge_cost = 0\n                for i in range(1, m):\n                    if a[i] == x:\n                        merge_cost += abs(y - a[i - 1])\n                    if a[i - 1] == x:\n                        merge_cost += abs(y - a[i])\n                current_turns = min(current_turns, initial_turns - total_cost[x] + merge_cost)\n        min_turns = min(min_turns, current_turns)\n\n    return min_turns\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:]))\n\n# Output the result\nprint(min_page_turns(n, m, a))", "problem": "Ryouko is an extremely forgetful girl, she could even forget something that has just happened. So in order to remember, she takes a notebook with her, called Ryouko's Memory Note. She writes what she sees and what she hears on the notebook, and the notebook became her memory.\n\nThough Ryouko is forgetful, she is also born with superb analyzing abilities. However, analyzing depends greatly on gathered information, in other words, memory. So she has to shuffle through her notebook whenever she needs to analyze, which is tough work.\n\nRyouko's notebook consists of n pages, numbered from 1 to n. To make life (and this problem) easier, we consider that to turn from page x to page y, |x - y| pages should be turned. During analyzing, Ryouko needs m pieces of information, the i-th piece of information is on page a_{i}. Information must be read from the notebook in order, so the total number of pages that Ryouko needs to turn is $\\sum_{i = 1}^{m - 1}|a_{i + 1} - a_{i}|$.\n\nRyouko wants to decrease the number of pages that need to be turned. In order to achieve this, she can merge two pages of her notebook. If Ryouko merges page x to page y, she would copy all the information on page x to y\u00a0(1 \u2264 x, y \u2264 n), and consequently, all elements in sequence a that was x would become y. Note that x can be equal to y, in which case no changes take place.\n\nPlease tell Ryouko the minimum number of pages that she needs to turn. Note she can apply the described operation at most once before the reading. Note that the answer can exceed 32-bit integers.\n\n\n-----Input-----\n\nThe first line of input contains two integers n and m\u00a0(1 \u2264 n, m \u2264 10^5).\n\nThe next line contains m integers separated by spaces: a_1, a_2, ..., a_{m} (1 \u2264 a_{i} \u2264 n).\n\n\n-----Output-----\n\nPrint a single integer \u2014 the minimum number of pages Ryouko needs to turn.\n\n\n-----Examples-----\nInput\n4 6\n1 2 3 4 3 2\n\nOutput\n3\n\nInput\n10 5\n9 4 3 8 8\n\nOutput\n6\n\n\n\n-----Note-----\n\nIn the first sample, the optimal solution is to merge page 4 to 3, after merging sequence a becomes {1, 2, 3, 3, 3, 2}, so the number of pages Ryouko needs to turn is |1 - 2| + |2 - 3| + |3 - 3| + |3 - 3| + |3 - 2| = 3.\n\nIn the second sample, optimal solution is achieved by merging page 9 to 4.", "solution": "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = {}\nfor ai in a:\n    b[ai] = []\namt = 0\nfor i in range(1, len(a)):\n    amt += abs(a[i]-a[i-1])\n    if a[i]-a[i-1]:\n        b[a[i]] += [a[i-1]]\n        b[a[i-1]] += [a[i]]\ndiff = 0\nfor bi in b:\n    if b[bi]:\n        center = sorted(b[bi])[len(b[bi])//2]\n        sum = 0\n        for page in b[bi]:\n            sum += abs(page-center)-abs(page-bi)\n        diff = min(diff, sum)\nprint(amt+diff)", "pass": false}
{"task_id": "1199", "program": "def distribute_mittens(n, m, colors):\n    from collections import defaultdict, deque\n\n    # Count the number of children with each color\n    color_count = defaultdict(int)\n    for color in colors:\n        color_count[color] += 1\n\n    # Create a list of children for each color\n    color_children = defaultdict(deque)\n    for i, color in enumerate(colors):\n        color_children[color].append(i)\n\n    # Create the result array\n    result = [[0, 0] for _ in range(n)]\n\n    # Create a list of all children\n    all_children = deque(range(n))\n\n    # Distribute left mittens\n    for color in range(1, m + 1):\n        while color_count[color] > 0:\n            child = all_children.popleft()\n            result[child][0] = color\n            color_count[color] -= 1\n\n    # Reset the color count\n    color_count = defaultdict(int)\n    for color in colors:\n        color_count[color] += 1\n\n    # Distribute right mittens\n    for color in range(1, m + 1):\n        while color_count[color] > 0:\n            child = color_children[color].popleft()\n            result[child][1] = color\n            color_count[color] -= 1\n\n    # Ensure distinct colors for each child\n    for i in range(n):\n        if result[i][0] == result[i][1]:\n            for j in range(n):\n                if i != j and result[i][0] != result[j][1] and result[j][0] != result[i][1]:\n                    result[i][1], result[j][1] = result[j][1], result[i][1]\n                    break\n\n    # Count the number of children with distinct-colored mittens\n    distinct_count = sum(1 for left, right in result if left != right)\n\n    # Print the result\n    print(distinct_count)\n    for left, right in result:\n        print(left, right)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:]))\n\n# Distribute mittens\ndistribute_mittens(n, m, colors)", "problem": "A Christmas party in city S. had n children. All children came in mittens. The mittens can be of different colors, but each child had the left and the right mitten of the same color. Let's say that the colors of the mittens are numbered with integers from 1 to m, and the children are numbered from 1 to n. Then the i-th child has both mittens of color c_{i}.\n\nThe Party had Santa Claus ('Father Frost' in Russian), his granddaughter Snow Girl, the children danced around the richly decorated Christmas tree. In fact, everything was so bright and diverse that the children wanted to wear mittens of distinct colors. The children decided to swap the mittens so that each of them got one left and one right mitten in the end, and these two mittens were of distinct colors. All mittens are of the same size and fit all the children.\n\nThe children started exchanging the mittens haphazardly, but they couldn't reach the situation when each child has a pair of mittens of distinct colors. Vasily Petrov, the dad of one of the children, noted that in the general case the children's idea may turn out impossible. Besides, he is a mathematician and he came up with such scheme of distributing mittens that the number of children that have distinct-colored mittens was maximum. You task is to repeat his discovery. Note that the left and right mittens are different: each child must end up with one left and one right mitten.\n\n\n-----Input-----\n\nThe first line contains two integers n and m \u2014 the number of the children and the number of possible mitten colors (1 \u2264 n \u2264 5000, 1 \u2264 m \u2264 100). The second line contains n integers c_1, c_2, ... c_{n}, where c_{i} is the color of the mittens of the i-th child (1 \u2264 c_{i} \u2264 m).\n\n\n-----Output-----\n\nIn the first line, print the maximum number of children who can end up with a distinct-colored pair of mittens. In the next n lines print the way the mittens can be distributed in this case. On the i-th of these lines print two space-separated integers: the color of the left and the color of the right mitten the i-th child will get. If there are multiple solutions, you can print any of them.\n\n\n-----Examples-----\nInput\n6 3\n1 3 2 2 1 1\n\nOutput\n6\n2 1\n1 2\n2 1\n1 3\n1 2\n3 1\n\nInput\n4 2\n1 2 1 1\n\nOutput\n2\n1 2\n1 1\n2 1\n1 1", "solution": "n, m = [int(i) for i in input().split()]\nc1 = [int(i) for i in input().split()]\nc1.sort()\nms = 0\ni = 0\nwhile i < n - 1:\n    start = i\n    while i < n - 1 and c1[i] == c1[i + 1]:\n        i += 1\n    ms = max(ms, i - start)\n    i += 1\nms += 1\nc2 = c1[-ms:] + c1[:-ms]\ncnt = 0\nfor i in range(n):\n    if c1[i] != c2[i]:\n        cnt += 1\nprint(cnt)\nfor i in range(n):\n    print(c1[i], c2[i])\n", "pass": false}
{"task_id": "1243", "program": "def min_moves_to_equalize(n, matches):\n    target = sum(matches) // n\n    moves = 0\n    balance = 0\n    \n    for match in matches:\n        balance += match - target\n        moves += abs(balance)\n    \n    return moves\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nmatches = list(map(int, data[1:]))\n\n# Calculate and print the result\nprint(min_moves_to_equalize(n, matches))", "problem": "Petya has k matches, placed in n matchboxes lying in a line from left to right. We know that k is divisible by n. Petya wants all boxes to have the same number of matches inside. For that, he can move a match from its box to the adjacent one in one move. How many such moves does he need to achieve the desired configuration?\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 50000). The second line contains n non-negative numbers that do not exceed 10^9, the i-th written number is the number of matches in the i-th matchbox. It is guaranteed that the total number of matches is divisible by n.\n\n\n-----Output-----\n\nPrint the total minimum number of moves.\n\n\n-----Examples-----\nInput\n6\n1 6 2 5 3 7\n\nOutput\n12", "solution": "n = int(input())\nboxs = list(map(int,input().split()))\n\ntot = sum(boxs)\nnum = tot // n\n\ns = 0\nfor i in range(n-1):\n    if boxs[i] < num :\n        \n        boxs[i+1] = boxs[i+1] - (num - boxs[i])\n        s += num - boxs[i]\n        boxs[i] = num\n    elif boxs[i] > num :\n        boxs[i+1] = boxs[i+1] + (boxs[i] - num)\n        s += boxs[i] - num\n        boxs[i] = num\n    #print(boxs)\nprint(int(s))\n", "pass": true}
{"task_id": "1250", "program": "n = int(input())\n\nif n == 1:\n    print(-1)\nelse:\n    # A simple counter-example for n > 1\n    # For example, [2, 1] will not be sorted correctly by Valera's algorithm\n    print(\"2 1\")", "problem": "Little boy Valera studies an algorithm of sorting an integer array. After studying the theory, he went on to the practical tasks. As a result, he wrote a program that sorts an array of n integers a_1, a_2, ..., a_{n} in the non-decreasing order. The pseudocode of the program, written by Valera, is given below. The input of the program gets number n and array a.\n\nloop integer variable i from 1 to n - 1\n\n\u00a0\u00a0\u00a0\u00a0loop integer variable j from i to n - 1\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (a_{j} > a_{j} + 1), then swap the values of elements a_{j} and a_{j} + 1\n\n\n\nBut Valera could have made a mistake, because he hasn't yet fully learned the sorting algorithm. If Valera made a mistake in his program, you need to give a counter-example that makes his program work improperly (that is, the example that makes the program sort the array not in the non-decreasing order). If such example for the given value of n doesn't exist, print -1.\n\n\n-----Input-----\n\nYou've got a single integer n (1 \u2264 n \u2264 50) \u2014 the size of the sorted array.\n\n\n-----Output-----\n\nPrint n space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 100) \u2014 the counter-example, for which Valera's algorithm won't work correctly. If the counter-example that meets the described conditions is impossible to give, print -1.\n\nIf there are several counter-examples, consisting of n numbers, you are allowed to print any of them.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n-1", "solution": "#July 4, 2014\nsa=int(input())\nstring=''\nif sa==1 or sa==2:\n    print(\"-1\")\nelse:\n    for x in range(sa, 0, -1):\n        string+=str(x)\n        string+=' '\n    print(string.strip())\n", "pass": false}
{"task_id": "1334", "program": "def find_lexicographically_smallest_string(n, k, s):\n    # Get the set of unique characters in s\n    unique_chars = sorted(set(s))\n    \n    # If k is greater than n, we need to append the smallest character\n    if k > n:\n        print(s + unique_chars[0] * (k - n))\n        return\n    \n    # Start with the first k characters of s\n    t = list(s[:k])\n    \n    # Find the position from the end where we can increment the character\n    for i in range(k - 1, -1, -1):\n        if t[i] != unique_chars[-1]:\n            # Find the next character in the sorted unique characters\n            next_char = unique_chars[unique_chars.index(t[i]) + 1]\n            t[i] = next_char\n            # Fill the rest with the smallest character\n            t = t[:i + 1] + [unique_chars[0]] * (k - i - 1)\n            print(\"\".join(t))\n            return\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Find and print the result\nfind_lexicographically_smallest_string(n, k, s)", "problem": "And where the are the phone numbers?\n\nYou are given a string s consisting of lowercase English letters and an integer k. Find the lexicographically smallest string t of length k, such that its set of letters is a subset of the set of letters of s and s is lexicographically smaller than t.\n\nIt's guaranteed that the answer exists.\n\nNote that the set of letters is a set, not a multiset. For example, the set of letters of abadaba is {a, b, d}.\n\nString p is lexicographically smaller than string q, if p is a prefix of q, is not equal to q or there exists i, such that p_{i} < q_{i} and for all j < i it is satisfied that p_{j} = q_{j}. For example, abc is lexicographically smaller than abcd , abd is lexicographically smaller than abec, afa is not lexicographically smaller than ab and a is not lexicographically smaller than a.\n\n\n-----Input-----\n\nThe first line of input contains two space separated integers n and k (1 \u2264 n, k \u2264 100 000)\u00a0\u2014 the length of s and the required length of t.\n\nThe second line of input contains the string s consisting of n lowercase English letters.\n\n\n-----Output-----\n\nOutput the string t conforming to the requirements above.\n\nIt's guaranteed that the answer exists.\n\n\n-----Examples-----\nInput\n3 3\nabc\n\nOutput\naca\n\nInput\n3 2\nabc\n\nOutput\nac\n\nInput\n3 3\nayy\n\nOutput\nyaa\n\nInput\n2 3\nba\n\nOutput\nbaa\n\n\n\n-----Note-----\n\nIn the first example the list of strings t of length 3, such that the set of letters of t is a subset of letters of s is as follows: aaa, aab, aac, aba, abb, abc, aca, acb, .... Among them, those are lexicographically greater than abc: aca, acb, .... Out of those the lexicographically smallest is aca.", "solution": "n, k = list(map(int, input().split()))\ns = input().strip()\n\ncnt = [0] * 26\nfor i in s:\n    cnt[ord(i) - 97] += 1\n\nlo = 0\nhi = 25\n\nfor i in range(0, 26):\n    if cnt[i] != 0:\n        lo = i\n        break\n    \nfor i in range(25, -1, -1):\n    if cnt[i] != 0:\n        hi = i\n        break\n\nif k <= n:\n    ans = list(s[:k])\n    for j in range(k - 1, -1 , -1):\n        done = 0\n        for i in range(ord(s[j]) - 97 + 1, 26):\n            if cnt[i] != 0:\n                ans[j] = chr(i + 97)\n                done = 1\n                break\n        if done:\n            for z in range(j + 1 , k):\n                ans[z] = chr(lo + 97)\n            break\nelse:\n    ans = list(s)\n    for i in range(k - n):\n        ans.append(chr(lo + 97))\n\nprint(''.join(ans))\n", "pass": true}
{"task_id": "1347", "program": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    m = int(data[0])\n    essay = data[1:m+1]\n    n = int(data[m+1])\n    synonyms = data[m+2:]\n    \n    synonym_dict = {}\n    for i in range(n):\n        x = synonyms[2*i]\n        y = synonyms[2*i + 1]\n        synonym_dict[x.lower()] = y.lower()\n    \n    def count_r_and_length(word):\n        return word.lower().count('r'), len(word)\n    \n    optimal_essay = []\n    for word in essay:\n        original_word = word.lower()\n        if original_word in synonym_dict:\n            synonym_word = synonym_dict[original_word]\n            original_r_count, original_length = count_r_and_length(word)\n            synonym_r_count, synonym_length = count_r_and_length(synonym_word)\n            if (synonym_r_count < original_r_count) or (synonym_r_count == original_r_count and synonym_length < original_length):\n                optimal_essay.append(synonym_word)\n            else:\n                optimal_essay.append(word)\n        else:\n            optimal_essay.append(word)\n    \n    min_r_count = sum(word.lower().count('r') for word in optimal_essay)\n    min_length = sum(len(word) for word in optimal_essay)\n    \n    print(min_r_count, min_length)\n\nif __name__ == \"__main__\":\n    main()", "problem": "After you had helped Fedor to find friends in the \u00abCall of Soldiers 3\u00bb game, he stopped studying completely. Today, the English teacher told him to prepare an essay. Fedor didn't want to prepare the essay, so he asked Alex for help. Alex came to help and wrote the essay for Fedor. But Fedor didn't like the essay at all. Now Fedor is going to change the essay using the synonym dictionary of the English language.\n\nFedor does not want to change the meaning of the essay. So the only change he would do: change a word from essay to one of its synonyms, basing on a replacement rule from the dictionary. Fedor may perform this operation any number of times.\n\nAs a result, Fedor wants to get an essay which contains as little letters \u00abR\u00bb (the case doesn't matter) as possible. If there are multiple essays with minimum number of \u00abR\u00bbs he wants to get the one with minimum length (length of essay is the sum of the lengths of all the words in it). Help Fedor get the required essay.\n\nPlease note that in this problem the case of letters doesn't matter. For example, if the synonym dictionary says that word cat can be replaced with word DOG, then it is allowed to replace the word Cat with the word doG.\n\n\n-----Input-----\n\nThe first line contains a single integer m (1 \u2264 m \u2264 10^5) \u2014 the number of words in the initial essay. The second line contains words of the essay. The words are separated by a single space. It is guaranteed that the total length of the words won't exceed 10^5 characters.\n\nThe next line contains a single integer n (0 \u2264 n \u2264 10^5) \u2014 the number of pairs of words in synonym dictionary. The i-th of the next n lines contains two space-separated non-empty words x_{i} and y_{i}. They mean that word x_{i} can be replaced with word y_{i} (but not vise versa). It is guaranteed that the total length of all pairs of synonyms doesn't exceed 5\u00b710^5 characters.\n\nAll the words at input can only consist of uppercase and lowercase letters of the English alphabet.\n\n\n-----Output-----\n\nPrint two integers \u2014 the minimum number of letters \u00abR\u00bb in an optimal essay and the minimum length of an optimal essay.\n\n\n-----Examples-----\nInput\n3\nAbRb r Zz\n4\nxR abRb\naA xr\nzz Z\nxr y\n\nOutput\n2 6\n\nInput\n2\nRuruRu fedya\n1\nruruRU fedor\n\nOutput\n1 10", "solution": "from collections import defaultdict\n\ninput()\nindex = {}\nstat = lambda word: (word.count('r'), \n    len(word), index.setdefault(word, len(index)))\nessay = list(map(stat, input().lower().split()))\nqueue = essay[:]\n\nsyn = defaultdict(list)\nfor i in range(int(input())):\n  word, rep = map(stat, input().lower().split())\n  syn[rep[2]].append(word[2])\n  queue.append(rep)\nqueue.sort(reverse=True)\nbest = {}\nwhile queue:\n  n_r, length, word = queue.pop()\n  if word in best:\n    continue\n  best[word] = n_r, length\n  for rep in syn[word]:\n    if rep not in best:\n      queue.append((n_r, length, rep))\nsum_n_r, sum_len = 0, 0\nfor n_r, length in map(lambda w: best[w[2]], essay):\n  sum_n_r += n_r\n  sum_len += length\nprint(sum_n_r, sum_len)", "pass": false}
{"task_id": "1349", "program": "def min_seconds_to_water_garden(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, k, taps = case\n        taps.sort()\n        max_distance = 0\n        \n        # Check the distance to the nearest tap for each bed\n        for i in range(1, n + 1):\n            min_distance = float('inf')\n            for tap in taps:\n                min_distance = min(min_distance, abs(tap - i) + 1)\n            max_distance = max(max_distance, min_distance)\n        \n        results.append(max_distance)\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, k = map(int, input().split())\n    taps = list(map(int, input().split()))\n    test_cases.append((n, k, taps))\n\n# Get results\nresults = min_seconds_to_water_garden(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)", "problem": "It is winter now, and Max decided it's about time he watered the garden.\n\nThe garden can be represented as n consecutive garden beds, numbered from 1 to n. k beds contain water taps (i-th tap is located in the bed x_{i}), which, if turned on, start delivering water to neighbouring beds. If the tap on the bed x_{i} is turned on, then after one second has passed, the bed x_{i} will be watered; after two seconds have passed, the beds from the segment [x_{i} - 1, x_{i} + 1] will be watered (if they exist); after j seconds have passed (j is an integer number), the beds from the segment [x_{i} - (j - 1), x_{i} + (j - 1)] will be watered (if they exist). Nothing changes during the seconds, so, for example, we can't say that the segment [x_{i} - 2.5, x_{i} + 2.5] will be watered after 2.5 seconds have passed; only the segment [x_{i} - 2, x_{i} + 2] will be watered at that moment.\n\n $\\left. \\begin{array}{|c|c|c|c|c|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline \\end{array} \\right.$ The garden from test 1. White colour denotes a garden bed without a tap, red colour \u2014 a garden bed with a tap. \n\n $\\left. \\begin{array}{|c|c|c|c|c|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline \\end{array} \\right.$ The garden from test 1 after 2 seconds have passed after turning on the tap. White colour denotes an unwatered garden bed, blue colour \u2014 a watered bed. \n\nMax wants to turn on all the water taps at the same moment, and now he wonders, what is the minimum number of seconds that have to pass after he turns on some taps until the whole garden is watered. Help him to find the answer!\n\n\n-----Input-----\n\nThe first line contains one integer t \u2014 the number of test cases to solve (1 \u2264 t \u2264 200).\n\nThen t test cases follow. The first line of each test case contains two integers n and k (1 \u2264 n \u2264 200, 1 \u2264 k \u2264 n) \u2014 the number of garden beds and water taps, respectively.\n\nNext line contains k integers x_{i} (1 \u2264 x_{i} \u2264 n) \u2014 the location of i-th water tap. It is guaranteed that for each $i \\in [ 2 ; k ]$ condition x_{i} - 1 < x_{i} holds.\n\nIt is guaranteed that the sum of n over all test cases doesn't exceed 200.\n\nNote that in hacks you have to set t = 1.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of seconds that have to pass after Max turns on some of the water taps, until the whole garden is watered.\n\n\n-----Example-----\nInput\n3\n5 1\n3\n3 3\n1 2 3\n4 1\n1\n\nOutput\n3\n1\n4\n\n\n\n-----Note-----\n\nThe first example consists of 3 tests:\n\n  There are 5 garden beds, and a water tap in the bed 3. If we turn it on, then after 1 second passes, only bed 3 will be watered; after 2 seconds pass, beds [1, 3] will be watered, and after 3 seconds pass, everything will be watered.  There are 3 garden beds, and there is a water tap in each one. If we turn all of them on, then everything will be watered after 1 second passes.  There are 4 garden beds, and only one tap in the bed 1. It will take 4 seconds to water, for example, bed 4.", "solution": "\n\nt = int(input())\n\nfor _ in range(t):\n    n, k = list(map(int, input().split()))\n    taps = [int(x) for x in input().split()]\n    result = 0\n    for i in range(1, n + 1):\n        best = n + 1\n        for x in taps:\n            best = min([best, abs(x - i)])\n        result = max([result, best])\n    print(result + 1)\n", "pass": true}
{"task_id": "1383", "program": "def find_min_x(n, m, a, b):\n    a.sort()\n    b.sort()\n    \n    def is_valid_x(x):\n        a_mod = [(a_i + x) % m for a_i in a]\n        a_mod.sort()\n        return a_mod == b\n    \n    min_x = float('inf')\n    for i in range(n):\n        x = (b[i] - a[0]) % m\n        if is_valid_x(x):\n            min_x = min(min_x, x)\n    \n    return min_x\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:2*n+2]))\n\n# Find and print the result\nprint(find_min_x(n, m, a, b))", "problem": "You are given a positive integer $m$ and two integer sequence: $a=[a_1, a_2, \\ldots, a_n]$ and $b=[b_1, b_2, \\ldots, b_n]$. Both of these sequence have a length $n$.\n\nPermutation is a sequence of $n$ different positive integers from $1$ to $n$. For example, these sequences are permutations: $[1]$, $[1,2]$, $[2,1]$, $[6,7,3,4,1,2,5]$. These are not: $[0]$, $[1,1]$, $[2,3]$.\n\nYou need to find the non-negative integer $x$, and increase all elements of $a_i$ by $x$, modulo $m$ (i.e. you want to change $a_i$ to $(a_i + x) \\bmod m$), so it would be possible to rearrange elements of $a$ to make it equal $b$, among them you need to find the smallest possible $x$.\n\nIn other words, you need to find the smallest non-negative integer $x$, for which it is possible to find some permutation $p=[p_1, p_2, \\ldots, p_n]$, such that for all $1 \\leq i \\leq n$, $(a_i + x) \\bmod m = b_{p_i}$, where $y \\bmod m$\u00a0\u2014 remainder of division of $y$ by $m$.\n\nFor example, if $m=3$, $a = [0, 0, 2, 1], b = [2, 0, 1, 1]$, you can choose $x=1$, and $a$ will be equal to $[1, 1, 0, 2]$ and you can rearrange it to make it equal $[2, 0, 1, 1]$, which is equal to $b$.\n\n\n-----Input-----\n\nThe first line contains two integers $n,m$ ($1 \\leq n \\leq 2000, 1 \\leq m \\leq 10^9$): number of elemens in arrays and $m$.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i < m$).\n\nThe third line contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($0 \\leq b_i < m$).\n\nIt is guaranteed that there exists some non-negative integer $x$, such that it would be possible to find some permutation $p_1, p_2, \\ldots, p_n$ such that $(a_i + x) \\bmod m = b_{p_i}$.\n\n\n-----Output-----\n\nPrint one integer, the smallest non-negative integer $x$, such that it would be possible to find some permutation $p_1, p_2, \\ldots, p_n$ such that $(a_i + x) \\bmod m = b_{p_i}$ for all $1 \\leq i \\leq n$.\n\n\n-----Examples-----\nInput\n4 3\n0 0 2 1\n2 0 1 1\n\nOutput\n1\n\nInput\n3 2\n0 0 0\n1 1 1\n\nOutput\n1\n\nInput\n5 10\n0 0 0 1 2\n2 1 0 0 0\n\nOutput\n0", "solution": "import sys\nimport math\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nalist=list(map(int,input().split()))\nblist=list(map(int,input().split()))\nalist.sort()\nblist.sort()\n\nminx=math.inf\nfor i in range(n):\n\tdiff=(blist[0]-alist[i]+m)%m\n\t# print(\"diff\",diff)\n\tarr=[]\n\tfor j in range(n):\n\t\tarr.append((alist[j]+diff)%m)\n\tarr.sort()\n\t# print(arr)\n\tflag=True\n\tfor j in range(n):\n\t\tif arr[j]!=blist[j]:\n\t\t\tflag=False\n\t\t\tbreak\n\tif flag:\n\t\tminx=min(minx,diff)\n\nprint(minx)", "pass": true}
{"task_id": "1405", "program": "def longest_fibonacciish_prefix(n, a):\n    a.sort()\n    max_len = 2\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            f0, f1 = a[i], a[j]\n            length = 2\n            while True:\n                f2 = f0 + f1\n                if f2 in a:\n                    length += 1\n                    f0, f1 = f1, f2\n                else:\n                    break\n            max_len = max(max_len, length)\n    \n    return max_len\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = longest_fibonacciish_prefix(n, a)\n\n# Print the result\nprint(result)", "problem": "Yash has recently learnt about the Fibonacci sequence and is very excited about it. He calls a sequence Fibonacci-ish if   the sequence consists of at least two elements  f_0 and f_1 are arbitrary  f_{n} + 2 = f_{n} + 1 + f_{n} for all n \u2265 0. \n\nYou are given some sequence of integers a_1, a_2, ..., a_{n}. Your task is rearrange elements of this sequence in such a way that its longest possible prefix is Fibonacci-ish sequence.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (2 \u2264 n \u2264 1000)\u00a0\u2014 the length of the sequence a_{i}.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (|a_{i}| \u2264 10^9).\n\n\n-----Output-----\n\nPrint the length of the longest possible Fibonacci-ish prefix of the given sequence after rearrangement.\n\n\n-----Examples-----\nInput\n3\n1 2 -1\n\nOutput\n3\n\nInput\n5\n28 35 7 14 21\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the first sample, if we rearrange elements of the sequence as  - 1, 2, 1, the whole sequence a_{i} would be Fibonacci-ish.\n\nIn the second sample, the optimal way to rearrange elements is $7$, $14$, $21$, $35$, 28.", "solution": "n = int(input())\nl = list(map(int,input().split()))\nd = {}\nfor i in l:\n\tif i not in d: d[i] = 0\n\td[i] += 1\nans = 0\nfor i in range(len(l)):\n\tfor j in range(len(l)):\n\t\tif i==j: continue\t\t\n\t\tn1,n2 = l[i],l[j]\n\t\tif n1==0 and n2==0: continue\n\t\tcurr = 2\n\t\td2 = {n1:1,n2:1}\n\t\twhile True:\n\t\t\tn1,n2 = n2,n1+n2\n\t\t\tans = max(ans, curr)\n\t\t\tif n2 in d and (d2[n2] if n2 in d2 else 0) < d[n2]:\n\t\t\t\tif n2 not in d2: d2[n2] = 0\n\t\t\t\td2[n2] += 1\n\t\t\t\tcurr += 1\n\t\t\telse: break\nprint(max(ans, (d[0] if 0 in d else -1)))\n", "pass": false}
{"task_id": "1446", "program": "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\nc = list(map(int, data[3:3 + k]))\n\nedges = []\nindex = 3 + k\nfor _ in range(m):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    x = int(data[index + 2])\n    edges.append((u, v, x))\n    index += 3\n\n# Determine the type of each bacteria\ntype_of_bacteria = [0] * n\ncurrent_index = 0\nfor i in range(k):\n    for j in range(c[i]):\n        type_of_bacteria[current_index] = i\n        current_index += 1\n\n# Check if each type is internally connected with zero cost\ndef is_connected_with_zero_cost(start, end):\n    visited = [False] * n\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            for u, v, x in edges:\n                if x == 0:\n                    if u == node and not visited[v]:\n                        stack.append(v)\n                    elif v == node and not visited[u]:\n                        stack.append(u)\n    return False\n\n# Check if each type is internally connected\nfor i in range(k):\n    start = sum(c[:i])\n    end = sum(c[:i + 1])\n    for j in range(start, end):\n        for l in range(j + 1, end):\n            if not is_connected_with_zero_cost(j, l):\n                print(\"No\")\n                sys.exit()\n\n# Use Dijkstra's algorithm to find the minimum cost between types\ndef dijkstra(start_type):\n    dist = [float('inf')] * n\n    pq = []\n    start_index = sum(c[:start_type])\n    end_index = sum(c[:start_type + 1])\n    for i in range(start_index, end_index):\n        dist[i] = 0\n        heapq.heappush(pq, (0, i))\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    \n    return dist\n\n# Build the graph\ngraph = [[] for _ in range(n)]\nfor u, v, x in edges:\n    graph[u].append((v, x))\n    graph[v].append((u, x))\n\n# Calculate the minimum cost matrix\nd = [[float('inf')] * k for _ in range(k)]\nfor i in range(k):\n    dist = dijkstra(i)\n    for j in range(k):\n        start_index = sum(c[:j])\n        end_index = sum(c[:j + 1])\n        min_cost = min(dist[start_index:end_index])\n        if min_cost == float('inf'):\n            d[i][j] = -1\n        else:\n            d[i][j] = min_cost\n\n# Print the result\nprint(\"Yes\")\nfor row in d:\n    print(\" \".join(map(str, row)))", "problem": "Dima took up the biology of bacteria, as a result of his experiments, he invented k types of bacteria. Overall, there are n bacteria at his laboratory right now, and the number of bacteria of type i equals c_{i}. For convenience, we will assume that all the bacteria are numbered from 1 to n. The bacteria of type c_{i} are numbered from $(\\sum_{k = 1}^{i - 1} c_{k}) + 1$ to $\\sum_{k = 1}^{i} c_{k}$.\n\nWith the help of special equipment Dima can move energy from some bacteria into some other one. Of course, the use of such equipment is not free. Dima knows m ways to move energy from some bacteria to another one. The way with number i can be described with integers u_{i}, v_{i} and x_{i} mean that this way allows moving energy from bacteria with number u_{i} to bacteria with number v_{i} or vice versa for x_{i} dollars.\n\nDima's Chef (Inna) calls the type-distribution correct if there is a way (may be non-direct) to move energy from any bacteria of the particular type to any other bacteria of the same type (between any two bacteria of the same type) for zero cost.\n\nAs for correct type-distribution the cost of moving the energy depends only on the types of bacteria help Inna to determine is the type-distribution correct? If it is, print the matrix d with size k \u00d7 k. Cell d[i][j] of this matrix must be equal to the minimal possible cost of energy-moving from bacteria with type i to bacteria with type j.\n\n\n-----Input-----\n\nThe first line contains three integers n, m, k (1 \u2264 n \u2264 10^5;\u00a00 \u2264 m \u2264 10^5;\u00a01 \u2264 k \u2264 500). The next line contains k integers c_1, c_2, ..., c_{k} (1 \u2264 c_{i} \u2264 n). Each of the next m lines contains three integers u_{i}, v_{i}, x_{i} (1 \u2264 u_{i}, v_{i} \u2264 10^5;\u00a00 \u2264 x_{i} \u2264 10^4). It is guaranteed that $\\sum_{i = 1}^{k} c_{i} = n$.\n\n\n-----Output-----\n\nIf Dima's type-distribution is correct, print string \u00abYes\u00bb, and then k lines: in the i-th line print integers d[i][1], d[i][2], ..., d[i][k] (d[i][i] = 0). If there is no way to move energy from bacteria i to bacteria j appropriate d[i][j] must equal to -1. If the type-distribution isn't correct print \u00abNo\u00bb.\n\n\n-----Examples-----\nInput\n4 4 2\n1 3\n2 3 0\n3 4 0\n2 4 1\n2 1 2\n\nOutput\nYes\n0 2\n2 0\n\nInput\n3 1 2\n2 1\n1 2 0\n\nOutput\nYes\n0 -1\n-1 0\n\nInput\n3 2 2\n2 1\n1 2 0\n2 3 1\n\nOutput\nYes\n0 1\n1 0\n\nInput\n3 0 2\n1 2\n\nOutput\nNo", "solution": "#!/usr/bin/env python3\nfrom sys import stdin\nfrom bisect import bisect_left, bisect_right\n    \nINF = int(1e9)\n\ndef find(par, a):\n    if par[a] == a:\n        return a\n    par[a] = find(par, par[a])\n    return par[a]\n\ndef union(par, rnk, a, b):\n    a = find(par,a)\n    b = find(par,b)\n    if a==b:\n        return\n    \n    if rnk[a]<rnk[b]:\n        par[a] = b\n    else:\n        par[b] = a\n        if rnk[a]==rnk[b]:\n            rnk[a] += 1\n    \ndef solve():\n    n, m, k = map(int, stdin.readline().split())\n    cnts = list(map(int, stdin.readline().split()))\n    for i in range(1,k):\n        cnts[i] += cnts[i-1]\n    \n    group = list(range(n))\n    rnk = [0 for i in range(n)]\n    adj = [[INF for j in range(k)] for i in range(k)]\n    for i in range(m):\n        u, v, x = map(int, stdin.readline().split())\n        if x==0:\n            union(group, rnk, u-1, v-1)\n        tu = bisect_left(cnts, u)\n        tv = bisect_left(cnts, v)\n        adj[tu][tv] = min(adj[tu][tv], x)\n        adj[tv][tu] = min(adj[tv][tu], x)\n    \n    p = 0\n    for i in range(k):\n        cur = group[p]\n        while p<cnts[i]:\n            if group[p]!=cur:\n                print(\"No\")\n                return\n            p += 1\n    print(\"Yes\")\n    \n    for p in range(k):\n        for i in range(k):\n            for j in range(k):\n                adj[i][j] = min(adj[i][j], adj[i][p]+adj[p][j])\n    \n    for i in range(k):\n        adj[i][i] = 0\n        for j in range(k):\n            if adj[i][j] == INF:\n                adj[i][j] = -1\n    \n    for i in range(k):\n        print(' '.join(map(lambda x: str(x), adj[i])))\n    \n    \nsolve()", "pass": true}
{"task_id": "1453", "program": "import heapq\n\ndef min_sugar_penalty(n, m, a):\n    a.sort()\n    penalties = [0] * n\n    current_penalty = 0\n    heap = []\n    \n    for i in range(n):\n        heapq.heappush(heap, a[i])\n        if len(heap) > m:\n            current_penalty += heapq.heappop(heap)\n        current_penalty += a[i]\n        penalties[i] = current_penalty\n    \n    return penalties\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = min_sugar_penalty(n, m, a)\nprint(\" \".join(map(str, result)))", "problem": "Tsumugi brought $n$ delicious sweets to the Light Music Club. They are numbered from $1$ to $n$, where the $i$-th sweet has a sugar concentration described by an integer $a_i$.\n\nYui loves sweets, but she can eat at most $m$ sweets each day for health reasons.\n\nDays are $1$-indexed (numbered $1, 2, 3, \\ldots$). Eating the sweet $i$ at the $d$-th day will cause a sugar penalty of $(d \\cdot a_i)$, as sweets become more sugary with time. A sweet can be eaten at most once.\n\nThe total sugar penalty will be the sum of the individual penalties of each sweet eaten.\n\nSuppose that Yui chooses exactly $k$ sweets, and eats them in any order she wants. What is the minimum total sugar penalty she can get?\n\nSince Yui is an undecided girl, she wants you to answer this question for every value of $k$ between $1$ and $n$.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le m \\le n \\le 200\\ 000$).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 200\\ 000$).\n\n\n-----Output-----\n\nYou have to output $n$ integers $x_1, x_2, \\ldots, x_n$ on a single line, separed by spaces, where $x_k$ is the minimum total sugar penalty Yui can get if she eats exactly $k$ sweets.\n\n\n-----Examples-----\nInput\n9 2\n6 19 3 4 4 2 6 7 8\n\nOutput\n2 5 11 18 30 43 62 83 121\n\nInput\n1 1\n7\n\nOutput\n7\n\n\n\n-----Note-----\n\nLet's analyze the answer for $k = 5$ in the first example. Here is one of the possible ways to eat $5$ sweets that minimize total sugar penalty:  Day $1$: sweets $1$ and $4$  Day $2$: sweets $5$ and $3$  Day $3$ : sweet $6$ \n\nTotal penalty is $1 \\cdot a_1 + 1 \\cdot a_4 + 2 \\cdot a_5 + 2 \\cdot a_3 + 3 \\cdot a_6 = 6 + 4 + 8 + 6 + 6 = 30$. We can prove that it's the minimum total sugar penalty Yui can achieve if she eats $5$ sweets, hence $x_5 = 30$.", "solution": "N, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA.sort()\nAns = []\nans = 0\ncumA = A[:]\nfor i in range(N):\n    j = i - M\n    if j>=0:\n        cumA[i] += cumA[j]\nfor a in cumA:\n    ans += a\n    Ans.append(ans)\nprint(\" \".join(map(str, Ans)))\n", "pass": false}
{"task_id": "1491", "program": "import math\nimport heapq\n\ndef is_square(x):\n    if x < 0:\n        return False\n    root = int(math.isqrt(x))\n    return root * root == x\n\ndef min_moves_to_balance(n, candies):\n    square_piles = []\n    non_square_piles = []\n    \n    for candy in candies:\n        if is_square(candy):\n            square_piles.append(candy)\n        else:\n            non_square_piles.append(candy)\n    \n    half_n = n // 2\n    if len(square_piles) == half_n and len(non_square_piles) == half_n:\n        return 0\n    \n    if len(square_piles) > half_n:\n        excess = len(square_piles) - half_n\n        moves = []\n        for candy in square_piles:\n            if candy == 0:\n                moves.append(2)\n            else:\n                root = int(math.isqrt(candy))\n                moves.append(min(candy - root * root, (root + 1) * (root + 1) - candy))\n        heapq.heapify(moves)\n        return sum(heapq.nsmallest(excess, moves))\n    \n    if len(non_square_piles) > half_n:\n        excess = len(non_square_piles) - half_n\n        moves = []\n        for candy in non_square_piles:\n            root = int(math.isqrt(candy))\n            moves.append(min(candy - root * root, (root + 1) * (root + 1) - candy))\n        heapq.heapify(moves)\n        return sum(heapq.nsmallest(excess, moves))\n    \n    deficit = half_n - len(square_piles)\n    moves = []\n    for candy in non_square_piles:\n        root = int(math.isqrt(candy))\n        moves.append(min(candy - root * root, (root + 1) * (root + 1) - candy))\n    heapq.heapify(moves)\n    return sum(heapq.nsmallest(deficit, moves))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\ncandies = list(map(int, data[1:]))\n\n# Output the result\nprint(min_moves_to_balance(n, candies))", "problem": "Ann and Borya have n piles with candies and n is even number. There are a_{i} candies in pile with number i.\n\nAnn likes numbers which are square of some integer and Borya doesn't like numbers which are square of any integer. During one move guys can select some pile with candies and add one candy to it (this candy is new and doesn't belong to any other pile) or remove one candy (if there is at least one candy in this pile). \n\nFind out minimal number of moves that is required to make exactly n / 2 piles contain number of candies that is a square of some integer and exactly n / 2 piles contain number of candies that is not a square of any integer.\n\n\n-----Input-----\n\nFirst line contains one even integer n (2 \u2264 n \u2264 200 000)\u00a0\u2014 number of piles with candies.\n\nSecond line contains sequence of integers a_1, a_2, ..., a_{n} (0 \u2264 a_{i} \u2264 10^9)\u00a0\u2014 amounts of candies in each pile.\n\n\n-----Output-----\n\nOutput minimal number of steps required to make exactly n / 2 piles contain number of candies that is a square of some integer and exactly n / 2 piles contain number of candies that is not a square of any integer. If condition is already satisfied output 0.\n\n\n-----Examples-----\nInput\n4\n12 14 30 4\n\nOutput\n2\n\nInput\n6\n0 0 0 0 0 0\n\nOutput\n6\n\nInput\n6\n120 110 23 34 25 45\n\nOutput\n3\n\nInput\n10\n121 56 78 81 45 100 1 0 54 78\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn first example you can satisfy condition in two moves. During each move you should add one candy to second pile. After it size of second pile becomes 16. After that Borya and Ann will have two piles with number of candies which is a square of integer (second and fourth pile) and two piles with number of candies which is not a square of any integer (first and third pile).\n\nIn second example you should add two candies to any three piles.", "solution": "import math\nn = int(input())\nnums = [int(i) for i in input().split()]\na = [1000000000] * n\nzero = 0\ns = 0\nfor i in range(n):\n    num = nums[i]\n    k = int(math.sqrt(num))\n    if k * k == num:\n        if num == 0:\n            zero += 1\n        s += 1\n    else:\n        a[i] = min(num - k * k, (k + 1) * (k + 1) - num)\nans = 0\nif s > n - s:\n    delta = (s - (n - s)) // 2\n    if delta <= s - zero:\n        ans += delta\n    else:\n        ans += 2 * (delta - (s - zero)) + (s - zero)\nelse:\n    delta = ((n - s) - s) // 2\n    a.sort()\n    ans = sum(a[:delta])\nprint(ans)\n        \n", "pass": false}
{"task_id": "1524", "program": "S = input().strip()\nN = len(S)\n\n# Initialize the result array with zeros\nresult = [0] * N\n\n# Process the string to find the positions where children will end up\ni = 0\nwhile i < N:\n    if S[i] == 'R':\n        # Find the next 'L' after a sequence of 'R's\n        j = i\n        while S[j] != 'L':\n            j += 1\n        # Now S[i:j] is a sequence of 'R's followed by 'L's\n        # Calculate the number of children ending up at positions j-1 and j\n        r_count = j - i\n        l_count = 1\n        result[j-1] += (r_count + 1) // 2\n        result[j] += r_count // 2\n        result[j-1] += l_count // 2\n        result[j] += (l_count + 1) // 2\n        # Move to the next segment\n        i = j + 1\n    else:\n        i += 1\n\nprint(' '.join(map(str, result)))", "problem": "Given is a string S consisting of L and R.\nLet N be the length of S. There are N squares arranged from left to right, and the i-th character of S from the left is written on the i-th square from the left.\nThe character written on the leftmost square is always R, and the character written on the rightmost square is always L.\nInitially, one child is standing on each square.\nEach child will perform the move below 10^{100} times:\n - Move one square in the direction specified by the character written in the square on which the child is standing. L denotes left, and R denotes right.\nFind the number of children standing on each square after the children performed the moves.\n\n-----Constraints-----\n - S is a string of length between 2 and 10^5 (inclusive).\n - Each character of S is L or R.\n - The first and last characters of S are R and L, respectively.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nS\n\n-----Output-----\nPrint the number of children standing on each square after the children performed the moves, in order from left to right.\n\n-----Sample Input-----\nRRLRL\n\n-----Sample Output-----\n0 1 2 1 1\n\n - After each child performed one move, the number of children standing on each square is 0, 2, 1, 1, 1 from left to right.\n - After each child performed two moves, the number of children standing on each square is 0, 1, 2, 1, 1 from left to right.\n - After each child performed 10^{100} moves, the number of children standing on each square is 0, 1, 2, 1, 1 from left to right.", "solution": "s = input()\nList = list(s)+['R']\nn=len(List)\nR = 0\nL = 0\nans = [0]*n\nfor i in range(n):\n  if List[i]=='R':\n    R += 1\n    if L > 0:\n      ans[i-L] += (L+1)//2\n      ans[i-L-1] += L//2\n      L = 0\n  else:\n    L += 1\n    if R > 0:\n      ans[i] +=R//2\n      ans[i-1] += (R+1) //2\n      R = 0\nprint(*ans[:-1])", "pass": false}
{"task_id": "1603", "program": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    v = list(map(int, data[1:n+1]))\n    m = int(data[n+1])\n    queries = data[n+2:]\n    \n    # Precompute prefix sums for original and sorted arrays\n    prefix_sum_v = [0] * (n + 1)\n    sorted_v = sorted(v)\n    prefix_sum_u = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix_sum_v[i] = prefix_sum_v[i - 1] + v[i - 1]\n        prefix_sum_u[i] = prefix_sum_u[i - 1] + sorted_v[i - 1]\n    \n    result = []\n    for i in range(m):\n        type_query = int(queries[3 * i])\n        l = int(queries[3 * i + 1])\n        r = int(queries[3 * i + 2])\n        \n        if type_query == 1:\n            result.append(prefix_sum_v[r] - prefix_sum_v[l - 1])\n        else:\n            result.append(prefix_sum_u[r] - prefix_sum_u[l - 1])\n    \n    print(\"\\n\".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()", "problem": "Kuriyama Mirai has killed many monsters and got many (namely n) stones. She numbers the stones from 1 to n. The cost of the i-th stone is v_{i}. Kuriyama Mirai wants to know something about these stones so she will ask you two kinds of questions:  She will tell you two numbers, l and r\u00a0(1 \u2264 l \u2264 r \u2264 n), and you should tell her $\\sum_{i = l}^{r} v_{i}$.  Let u_{i} be the cost of the i-th cheapest stone (the cost that will be on the i-th place if we arrange all the stone costs in non-decreasing order). This time she will tell you two numbers, l and r\u00a0(1 \u2264 l \u2264 r \u2264 n), and you should tell her $\\sum_{i = l}^{r} u_{i}$. \n\nFor every question you should give the correct answer, or Kuriyama Mirai will say \"fuyukai desu\" and then become unhappy.\n\n\n-----Input-----\n\nThe first line contains an integer n\u00a0(1 \u2264 n \u2264 10^5). The second line contains n integers: v_1, v_2, ..., v_{n}\u00a0(1 \u2264 v_{i} \u2264 10^9) \u2014 costs of the stones. \n\nThe third line contains an integer m\u00a0(1 \u2264 m \u2264 10^5) \u2014 the number of Kuriyama Mirai's questions. Then follow m lines, each line contains three integers type, l and r\u00a0(1 \u2264 l \u2264 r \u2264 n;\u00a01 \u2264 type \u2264 2), describing a question. If type equal to 1, then you should output the answer for the first question, else you should output the answer for the second one.\n\n\n-----Output-----\n\nPrint m lines. Each line must contain an integer \u2014 the answer to Kuriyama Mirai's question. Print the answers to the questions in the order of input.\n\n\n-----Examples-----\nInput\n6\n6 4 2 7 2 7\n3\n2 3 6\n1 3 4\n1 1 6\n\nOutput\n24\n9\n28\n\nInput\n4\n5 5 2 3\n10\n1 2 4\n2 1 4\n1 1 1\n2 1 4\n2 1 2\n1 1 1\n1 3 3\n1 1 3\n1 4 4\n1 2 2\n\nOutput\n10\n15\n5\n15\n5\n5\n2\n12\n3\n5\n\n\n\n-----Note-----\n\nPlease note that the answers to the questions may overflow 32-bit integer type.", "solution": "n = int(input().strip())\nv = list(map(int, input().split()))\nm = int(input().strip())\nf1 = [0] * n\nf2 = [0] * n\nu = sorted(v)\nfor i in range(n):\n    f1[i] = v[i]\n    if i > 0:\n        f1[i] += f1[i - 1]\n        \nfor i in range(n):\n    f2[i] = u[i]\n    if i > 0:\n        f2[i] += f2[i - 1]        \n\nans = []\n\nfor i in range(m):\n    t, l, r = map(int, input().split())\n    l -= 1\n    r -= 1\n    if t == 1:\n        an = f1[r]\n        if l > 0:\n            an -= f1[l - 1]\n        ans.append(an)\n    else:\n        an = f2[r]\n        if l > 0:\n            an -= f2[l - 1]\n        ans.append(an)\n        \nprint(*ans, sep = '\\n')", "pass": false}
{"task_id": "1662", "program": "def find_max_stairs(m, cards):\n    from collections import Counter\n\n    # Count the frequency of each card\n    card_count = Counter(cards)\n    \n    # Find the maximum number of cards that can be used to form a stair sequence\n    unique_cards = sorted(card_count.keys())\n    \n    # Create the increasing part of the stairs\n    increasing_part = []\n    for card in unique_cards:\n        if card_count[card] > 0:\n            increasing_part.append(card)\n            card_count[card] -= 1\n    \n    # Create the decreasing part of the stairs\n    decreasing_part = []\n    for card in reversed(unique_cards):\n        if card_count[card] > 0:\n            decreasing_part.append(card)\n            card_count[card] -= 1\n    \n    # Combine the increasing and decreasing parts\n    stairs = increasing_part + decreasing_part\n    \n    return len(stairs), stairs\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nm = int(data[0])\ncards = list(map(int, data[1:]))\n\n# Find the maximum number of cards that can be used to form a stair sequence\nlength, stairs = find_max_stairs(m, cards)\n\n# Print the result\nprint(length)\nprint(\" \".join(map(str, stairs)))", "problem": "Sereja loves integer sequences very much. He especially likes stairs.\n\nSequence a_1, a_2, ..., a_{|}a| (|a| is the length of the sequence) is stairs if there is such index i (1 \u2264 i \u2264 |a|), that the following condition is met: a_1 < a_2 < ... < a_{i} - 1 < a_{i} > a_{i} + 1 > ... > a_{|}a| - 1 > a_{|}a|.\n\nFor example, sequences [1, 2, 3, 2] and [4, 2] are stairs and sequence [3, 1, 2] isn't.\n\nSereja has m cards with numbers. He wants to put some cards on the table in a row to get a stair sequence. What maximum number of cards can he put on the table?\n\n\n-----Input-----\n\nThe first line contains integer m (1 \u2264 m \u2264 10^5) \u2014 the number of Sereja's cards. The second line contains m integers b_{i} (1 \u2264 b_{i} \u2264 5000) \u2014 the numbers on the Sereja's cards.\n\n\n-----Output-----\n\nIn the first line print the number of cards you can put on the table. In the second line print the resulting stairs.\n\n\n-----Examples-----\nInput\n5\n1 2 3 4 5\n\nOutput\n5\n5 4 3 2 1\n\nInput\n6\n1 1 2 2 3 3\n\nOutput\n5\n1 2 3 2 1", "solution": "from itertools import chain\n\n\ndef main():\n    input()\n    lb, la = [], []\n    a = b = -1\n    it = iter(sorted(map(int, input().split())))\n    try:\n        while True:\n            c = next(it)\n            if a != c:\n                a = c\n                la.append(a)\n            c = next(it)\n            if b != c:\n                b = c\n                lb.append(b)\n            pass\n    except StopIteration:\n        if a == b:\n            del lb[-1]\n    print(len(la) + len(lb))\n    print(' '.join(map(str, chain(la, lb[::-1]))))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "pass": false}
{"task_id": "1668", "program": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        pins = data[index:index + n]\n        index += n\n        \n        changes = 0\n        seen = set()\n        new_pins = []\n        \n        for pin in pins:\n            if pin in seen:\n                for i in range(4):\n                    for d in range(10):\n                        new_pin = pin[:i] + str(d) + pin[i+1:]\n                        if new_pin not in seen:\n                            new_pins.append(new_pin)\n                            seen.add(new_pin)\n                            changes += 1\n                            break\n                    else:\n                        continue\n                    break\n            else:\n                new_pins.append(pin)\n                seen.add(pin)\n        \n        results.append(f\"{changes}\")\n        results.extend(new_pins)\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()", "problem": "A PIN code is a string that consists of exactly $4$ digits. Examples of possible PIN codes: 7013, 0000 and 0990. Please note that the PIN code can begin with any digit, even with 0.\n\nPolycarp has $n$ ($2 \\le n \\le 10$) bank cards, the PIN code of the $i$-th card is $p_i$.\n\nPolycarp has recently read a recommendation that it is better to set different PIN codes on different cards. Thus he wants to change the minimal number of digits in the PIN codes of his cards so that all $n$ codes would become different.\n\nFormally, in one step, Polycarp picks $i$-th card ($1 \\le i \\le n$), then in its PIN code $p_i$ selects one position (from $1$ to $4$), and changes the digit in this position to any other. He needs to change the minimum number of digits so that all PIN codes become different.\n\nPolycarp quickly solved this problem. Can you solve it?\n\n\n-----Input-----\n\nThe first line contains integer $t$ ($1 \\le t \\le 100$) \u2014 the number of test cases in the input. Then test cases follow.\n\nThe first line of each of $t$ test sets contains a single integer $n$ ($2 \\le n \\le 10$) \u2014 the number of Polycarp's bank cards. The next $n$ lines contain the PIN codes $p_1, p_2, \\dots, p_n$ \u2014 one per line. The length of each of them is $4$. All PIN codes consist of digits only.\n\n\n-----Output-----\n\nPrint the answers to $t$ test sets. The answer to each set should consist of a $n + 1$ lines\n\nIn the first line print $k$ \u2014 the least number of changes to make all PIN codes different. In the next $n$ lines output the changed PIN codes in the order corresponding to their appearance in the input. If there are several optimal answers, print any of them.\n\n\n-----Example-----\nInput\n3\n2\n1234\n0600\n2\n1337\n1337\n4\n3139\n3139\n3139\n3139\n\nOutput\n0\n1234\n0600\n1\n1337\n1237\n3\n3139\n3138\n3939\n6139", "solution": "from math import *\nfrom collections import *\nimport sys\nsys.setrecursionlimit(10**9)\n\nt = int(input())\nfor y in range(t):\n\tn = int(input())\n\ta = []\n\tfor i in range(n):\n\t\ta.append(list(input()))\n\t\n\tch = 0\n\tfor i in range(n):\n\t\tkey = 0\n\t\tfor j in range(n):\n\t\t\tif(j == i): continue\n\t\t\tif(a[i] == a[j]):\n\t\t\t\tkey = 1\n\t\t\t\tbreak\n\t\tif(key == 1):\n\t\t\t#print(a[i])\n\t\t\tfor j in range(4):\n\t\t\t\tb = a[i][::]\n\t\t\t\tflag = 0\n\t\t\t\tfor k in range(10):\n\t\t\t\t\tb[j] = str(k)\n\t\t\t\t\tif(b not in a):\n\t\t\t\t\t\tch += 1\n\t\t\t\t\t\ta[i][::] = b\n\t\t\t\t\t\tflag = 1 \n\t\t\t\t\t\tbreak\n\t\t\t\tif(flag == 1):\n\t\t\t\t\tbreak\n\tprint(ch)\n\tfor i in a:\n\t\tprint(\"\".join(i))\n", "pass": false}
{"task_id": "1759", "program": "def find_completion_times(m, n, times):\n    # Initialize the completion times for each painter\n    completion_times = [[0] * n for _ in range(m)]\n    \n    # Set the completion time for the first painter\n    for i in range(m):\n        if i == 0:\n            completion_times[i][0] = times[i][0]\n        else:\n            completion_times[i][0] = completion_times[i-1][0] + times[i][0]\n    \n    # Calculate the completion times for the rest of the painters\n    for j in range(1, n):\n        for i in range(m):\n            if i == 0:\n                completion_times[i][j] = completion_times[i][j-1] + times[i][j]\n            else:\n                completion_times[i][j] = max(completion_times[i-1][j], completion_times[i][j-1]) + times[i][j]\n    \n    # Extract the completion times for the last painter\n    result = [completion_times[i][n-1] for i in range(m)]\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nm = int(data[0])\nn = int(data[1])\ntimes = []\n\nindex = 2\nfor i in range(m):\n    times.append([int(data[index + j]) for j in range(n)])\n    index += n\n\n# Find the completion times\nresult = find_completion_times(m, n, times)\n\n# Print the result\nprint(\" \".join(map(str, result)))", "problem": "A well-known art union called \"Kalevich is Alive!\" manufactures objects d'art (pictures). The union consists of n painters who decided to organize their work as follows.\n\nEach painter uses only the color that was assigned to him. The colors are distinct for all painters. Let's assume that the first painter uses color 1, the second one uses color 2, and so on. Each picture will contain all these n colors. Adding the j-th color to the i-th picture takes the j-th painter t_{ij} units of time.\n\nOrder is important everywhere, so the painters' work is ordered by the following rules:  Each picture is first painted by the first painter, then by the second one, and so on. That is, after the j-th painter finishes working on the picture, it must go to the (j + 1)-th painter (if j < n);  each painter works on the pictures in some order: first, he paints the first picture, then he paints the second picture and so on;  each painter can simultaneously work on at most one picture. However, the painters don't need any time to have a rest;  as soon as the j-th painter finishes his part of working on the picture, the picture immediately becomes available to the next painter. \n\nGiven that the painters start working at time 0, find for each picture the time when it is ready for sale.\n\n\n-----Input-----\n\nThe first line of the input contains integers m, n (1 \u2264 m \u2264 50000, 1 \u2264 n \u2264 5), where m is the number of pictures and n is the number of painters. Then follow the descriptions of the pictures, one per line. Each line contains n integers t_{i}1, t_{i}2, ..., t_{in} (1 \u2264 t_{ij} \u2264 1000), where t_{ij} is the time the j-th painter needs to work on the i-th picture.\n\n\n-----Output-----\n\nPrint the sequence of m integers r_1, r_2, ..., r_{m}, where r_{i} is the moment when the n-th painter stopped working on the i-th picture.\n\n\n-----Examples-----\nInput\n5 1\n1\n2\n3\n4\n5\n\nOutput\n1 3 6 10 15 \nInput\n4 2\n2 5\n3 1\n5 3\n10 1\n\nOutput\n7 8 13 21", "solution": "m,n=map(int, input().split())\na=[0]*8\nfor i in range(m):\n    x=list(map(int, input().split()))\n    for j in range(1,n+1):\n        a[j]=max(a[j], a[j-1])+x[j-1]\n    print(a[n],end=' ')", "pass": true}
{"task_id": "1778", "program": "def optimal_game_difference(n, a, b):\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    \n    a_score = 0\n    b_score = 0\n    turn = 0  # 0 for A's turn, 1 for B's turn\n    \n    while a or b:\n        if turn == 0:  # A's turn\n            if not a:\n                b.pop(0)\n            elif not b:\n                a_score += a.pop(0)\n            elif a[0] >= b[0]:\n                a_score += a.pop(0)\n            else:\n                b.pop(0)\n        else:  # B's turn\n            if not b:\n                a.pop(0)\n            elif not a:\n                b_score += b.pop(0)\n            elif b[0] >= a[0]:\n                b_score += b.pop(0)\n            else:\n                a.pop(0)\n        \n        turn = 1 - turn  # switch turns\n    \n    return a_score - b_score\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nb = list(map(int, data[n+1:2*n+1]))\n\n# Calculate and print the result\nprint(optimal_game_difference(n, a, b))", "problem": "Two players A and B have a list of $n$ integers each. They both want to maximize the subtraction between their score and their opponent's score. \n\nIn one turn, a player can either add to his score any element from his list (assuming his list is not empty), the element is removed from the list afterward. Or remove an element from his opponent's list (assuming his opponent's list is not empty).\n\nNote, that in case there are equal elements in the list only one of them will be affected in the operations above. For example, if there are elements $\\{1, 2, 2, 3\\}$ in a list and you decided to choose $2$ for the next turn, only a single instance of $2$ will be deleted (and added to the score, if necessary). \n\nThe player A starts the game and the game stops when both lists are empty. Find the difference between A's score and B's score at the end of the game, if both of the players are playing optimally.\n\nOptimal play between two players means that both players choose the best possible strategy to achieve the best possible outcome for themselves. In this problem, it means that each player, each time makes a move, which maximizes the final difference between his score and his opponent's score, knowing that the opponent is doing the same.\n\n\n-----Input-----\n\nThe first line of input contains an integer $n$ ($1 \\le n \\le 100\\,000$)\u00a0\u2014 the sizes of the list.\n\nThe second line contains $n$ integers $a_i$ ($1 \\le a_i \\le 10^6$), describing the list of the player A, who starts the game.\n\nThe third line contains $n$ integers $b_i$ ($1 \\le b_i \\le 10^6$), describing the list of the player B.\n\n\n-----Output-----\n\nOutput the difference between A's score and B's score ($A-B$) if both of them are playing optimally.\n\n\n-----Examples-----\nInput\n2\n1 4\n5 1\n\nOutput\n0\nInput\n3\n100 100 100\n100 100 100\n\nOutput\n0\nInput\n2\n2 1\n5 6\n\nOutput\n-3\n\n\n-----Note-----\n\nIn the first example, the game could have gone as follows:   A removes $5$ from B's list.  B removes $4$ from A's list.  A takes his $1$.  B takes his $1$. \n\nHence, A's score is $1$, B's score is $1$ and difference is $0$.\n\nThere is also another optimal way of playing:  A removes $5$ from B's list.  B removes $4$ from A's list.  A removes $1$ from B's list.  B removes $1$ from A's list. \n\nThe difference in the scores is still $0$.\n\nIn the second example, irrespective of the moves the players make, they will end up with the same number of numbers added to their score, so the difference will be $0$.", "solution": "n=int(input())\ns=input().split()\nla=[int(s[i]) for i in range(n)]\ns=input().split()\nlb=[int(s[i]) for i in range(n)]\nla.sort()\nlb.sort()\nsa=0\nsb=0\nfor i in range(n):\n    if len(la)==0:\n        if len(lb)>0:\n            del(lb[-1])\n        else:\n            break\n    elif len(lb)==0:\n        sa+=la[-1]\n        del(la[-1])\n    elif la[-1]>lb[-1]:\n        sa+=la[-1]\n        del(la[-1])\n    else:\n        del(lb[-1])\n    \n    if len(lb)==0:\n        if len(la)>0:\n            del(la[-1])\n        else:\n            break\n    elif len(la)==0:\n        sb+=lb[-1]\n        del(lb[-1])\n    elif lb[-1]>la[-1]:\n        sb+=lb[-1]\n        del(lb[-1])\n    else:\n        del(la[-1])\nprint(sa-sb)", "pass": true}
{"task_id": "1850", "program": "def best_possible_ranking(N, D, S, P):\n    # Current points of the astronaut of interest\n    current_points = S[D-1]\n    \n    # Points if the astronaut wins the next race\n    max_points = current_points + P[0]\n    \n    # Calculate the best possible ranking\n    best_rank = 1\n    for i in range(N):\n        if i != D-1 and S[i] + P[-1] > max_points:\n            best_rank += 1\n    \n    return best_rank\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nD = int(data[1])\nS = list(map(int, data[2:N+2]))\nP = list(map(int, data[N+2:]))\n\n# Calculate and print the best possible ranking\nprint(best_possible_ranking(N, D, S, P))", "problem": "Formula 1 officials decided to introduce new competition. Cars are replaced by space ships and number of points awarded can differ per race.\n\nGiven the current ranking in the competition and points distribution for the next race, your task is to calculate the best possible ranking for a given astronaut after the next race. It's guaranteed that given astronaut will have unique number of points before the race.\n\n\n-----Input-----\n\nThe first line contains two integer numbers $N$ ($1 \\leq N \\leq 200000$) representing number of F1 astronauts, and current position of astronaut $D$ ($1 \\leq D \\leq N$) you want to calculate best ranking for (no other competitor will have the same number of points before the race).\n\nThe second line contains $N$ integer numbers $S_k$ ($0 \\leq S_k \\leq 10^8$, $k=1...N$), separated by a single space, representing current ranking of astronauts. Points are sorted in non-increasing order.\n\nThe third line contains $N$ integer numbers $P_k$ ($0 \\leq P_k \\leq 10^8$, $k=1...N$), separated by a single space, representing point awards for the next race. Points are sorted in non-increasing order, so winner of the race gets the maximum number of points.\n\n\n-----Output-----\n\nOutput contains one integer number \u2014 the best possible ranking for astronaut after the race. If multiple astronauts have the same score after the race, they all share the best ranking.\n\n\n-----Example-----\nInput\n4 3\n50 30 20 10\n15 10 7 3\n\nOutput\n2\n\n\n\n-----Note-----\n\nIf the third ranked astronaut wins the race, he will have 35 points. He cannot take the leading position, but he can overtake the second position if the second ranked astronaut finishes the race at the last position.", "solution": "n,d=list(map(int,input().split()))\nsk = list(map(int,input().split()))\npk=list(map(int,input().split()))\n\nsk[d-1] += pk[0]\npk.pop(0)\nrank=1\n\nfor i in range(d-1):\n    if sk[i]+pk[-1]>sk[d-1]:\n        rank+=1\n    elif sk[i]+pk[-1]==sk[d-1]:\n        pk.pop()\n        \n    else:\n        j=len(pk)-1\n        pk.pop(j)            \n    \n\nprint(rank)\n\n    \n", "pass": false}
{"task_id": "1859", "program": "def smallest_prime_divisor(n):\n    if n % 2 == 0:\n        return 2\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return i\n    return n\n\ndef count_subtractions(n):\n    count = 0\n    while n > 0:\n        d = smallest_prime_divisor(n)\n        n -= d\n        count += 1\n    return count\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(count_subtractions(n))", "problem": "You are given an integer number $n$. The following algorithm is applied to it:\n\n  if $n = 0$, then end algorithm;  find the smallest prime divisor $d$ of $n$;  subtract $d$ from $n$ and go to step $1$. \n\nDetermine the number of subtrations the algorithm will make.\n\n\n-----Input-----\n\nThe only line contains a single integer $n$ ($2 \\le n \\le 10^{10}$).\n\n\n-----Output-----\n\nPrint a single integer \u2014 the number of subtractions the algorithm will make.\n\n\n-----Examples-----\nInput\n5\n\nOutput\n1\n\nInput\n4\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first example $5$ is the smallest prime divisor, thus it gets subtracted right away to make a $0$.\n\nIn the second example $2$ is the smallest prime divisor at both steps.", "solution": "n = int(input())\nif n % 2 == 0:\n    print(n // 2)\n    return\n\nfor x in range(2, int(n**0.5 + 1)):\n    if n % x == 0:\n        print(1 + (n - x) // 2)\n        return\nprint(1)\n", "pass": false}
{"task_id": "1916", "program": "def min_or(n, m, a, b):\n    min_result = float('inf')\n    \n    for mask in range(1 << 9):\n        valid = True\n        for ai in a:\n            found = False\n            for bj in b:\n                if (ai & bj) | mask == mask:\n                    found = True\n                    break\n            if not found:\n                valid = False\n                break\n        if valid:\n            min_result = min(min_result, mask)\n    \n    return min_result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:n+2+m]))\n\n# Compute and print the result\nprint(min_or(n, m, a, b))", "problem": "Boboniu likes bit operations. He wants to play a game with you.\n\nBoboniu gives you two sequences of non-negative integers $a_1,a_2,\\ldots,a_n$ and $b_1,b_2,\\ldots,b_m$.\n\nFor each $i$ ($1\\le i\\le n$), you're asked to choose a $j$ ($1\\le j\\le m$) and let $c_i=a_i\\& b_j$, where $\\&$ denotes the bitwise AND operation. Note that you can pick the same $j$ for different $i$'s.\n\nFind the minimum possible $c_1 | c_2 | \\ldots | c_n$, where $|$ denotes the bitwise OR operation.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1\\le n,m\\le 200$).\n\nThe next line contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($0\\le a_i < 2^9$).\n\nThe next line contains $m$ integers $b_1,b_2,\\ldots,b_m$ ($0\\le b_i < 2^9$).\n\n\n-----Output-----\n\nPrint one integer: the minimum possible $c_1 | c_2 | \\ldots | c_n$.\n\n\n-----Examples-----\nInput\n4 2\n2 6 4 0\n2 4\n\nOutput\n2\nInput\n7 6\n1 9 1 9 8 1 0\n1 1 4 5 1 4\n\nOutput\n0\nInput\n8 5\n179 261 432 162 82 43 10 38\n379 357 202 184 197\n\nOutput\n147\n\n\n-----Note-----\n\nFor the first example, we have $c_1=a_1\\& b_2=0$, $c_2=a_2\\& b_1=2$, $c_3=a_3\\& b_1=0$, $c_4 = a_4\\& b_1=0$.Thus $c_1 | c_2 | c_3 |c_4 =2$, and this is the minimal answer we can get.", "solution": "n,m = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\nc=0\nfor i in range(0,513):\n    c=1\n    for j in a:\n        u = 0\n        for k in b:\n            if(i|(j&k)==i):\n                u = 1\n                break\n        if(u==0):\n            c=0\n            break\n    if(c==1):\n        print(i)\n        break", "pass": true}
{"task_id": "1971", "program": "def find_q_from_p(n, p):\n    # Create an array to store the inverse of p\n    inv_p = [0] * n\n    for i in range(n):\n        inv_p[p[i] - 1] = i + 1\n\n    # Create an array to store q\n    q = [0] * n\n    for i in range(n):\n        q[i] = inv_p[inv_p[i] - 1]\n\n    # Verify if q^2 equals p\n    for i in range(n):\n        if p[i] != q[q[i] - 1]:\n            return -1\n\n    return q\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Find q from p\nresult = find_q_from_p(n, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))", "problem": "A permutation of length n is an array containing each integer from 1 to n exactly once. For example, q = [4, 5, 1, 2, 3] is a permutation. For the permutation q the square of permutation is the permutation p that p[i] = q[q[i]] for each i = 1... n. For example, the square of q = [4, 5, 1, 2, 3] is p = q^2 = [2, 3, 4, 5, 1].\n\nThis problem is about the inverse operation: given the permutation p you task is to find such permutation q that q^2 = p. If there are several such q find any of them.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 10^6) \u2014 the number of elements in permutation p.\n\nThe second line contains n distinct integers p_1, p_2, ..., p_{n} (1 \u2264 p_{i} \u2264 n) \u2014 the elements of permutation p.\n\n\n-----Output-----\n\nIf there is no permutation q such that q^2 = p print the number \"-1\".\n\nIf the answer exists print it. The only line should contain n different integers q_{i} (1 \u2264 q_{i} \u2264 n) \u2014 the elements of the permutation q. If there are several solutions print any of them.\n\n\n-----Examples-----\nInput\n4\n2 1 4 3\n\nOutput\n3 4 2 1\n\nInput\n4\n2 1 3 4\n\nOutput\n-1\n\nInput\n5\n2 3 4 5 1\n\nOutput\n4 5 1 2 3", "solution": "import math\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\na = [int(_) - 1 for _ in input().split()]\nvis = [False] * n\ncycles = [[] for _ in range(n + 1)]\nfor i in range(n):\n    if vis[i]: continue\n    cur = i\n    cycle = []\n    while not vis[cur]:\n        vis[cur] = True\n        cycle.append(cur)\n        cur = a[cur]\n    cycles[len(cycle)].append(cycle)\np = [0] * n\nfor i in range(n + 1):\n    if i % 2 == 1:\n        for j in cycles[i]:\n            for k in range(i):\n                p[j[k]] = j[(k + (i + 1) // 2) % i]\n    else:\n        if len(cycles[i]) % 2 == 1:\n            print(-1)\n            return\n        for j in range(0, len(cycles[i]), 2):\n            for k in range(i):\n                p[cycles[i][j][k]] = cycles[i][j + 1][k] \n                p[cycles[i][j + 1][k]] = cycles[i][j][(k + 1) % i]\nprint(' '.join([str(i + 1) for i in p]))\n", "pass": false}
{"task_id": "1999", "program": "def process_array(n, arr):\n    from collections import Counter\n    import heapq\n\n    # Create a counter for the array elements\n    counter = Counter(arr)\n    \n    # Create a min-heap for elements that occur 2 or more times\n    heap = []\n    for key, value in counter.items():\n        if value >= 2:\n            heapq.heappush(heap, key)\n    \n    # Process the array\n    i = 0\n    while heap:\n        # Get the smallest element that occurs 2 or more times\n        x = heapq.heappop(heap)\n        \n        # Find the first two occurrences of x\n        first = -1\n        second = -1\n        for j in range(i, n):\n            if arr[j] == x:\n                if first == -1:\n                    first = j\n                else:\n                    second = j\n                    break\n        \n        # If we found two occurrences, perform the operation\n        if first != -1 and second != -1:\n            arr[first] = 0  # Mark the first occurrence for removal\n            arr[second] = 2 * x  # Replace the second occurrence with 2 * x\n            \n            # Update the counter\n            counter[x] -= 2\n            counter[2 * x] += 1\n            \n            # If 2 * x now occurs 2 or more times, add it to the heap\n            if counter[2 * x] == 2:\n                heapq.heappush(heap, 2 * x)\n            \n            # If x still occurs 2 or more times, add it back to the heap\n            if counter[x] >= 2:\n                heapq.heappush(heap, x)\n    \n    # Remove all marked elements (0s) from the array\n    result = [num for num in arr if num != 0]\n    \n    # Print the result\n    print(len(result))\n    print(\" \".join(map(str, result)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\narr = list(map(int, data[1:]))\n\n# Process the array\nprocess_array(n, arr)", "problem": "You are given an array of positive integers. While there are at least two equal elements, we will perform the following operation. We choose the smallest value $x$ that occurs in the array $2$ or more times. Take the first two occurrences of $x$ in this array (the two leftmost occurrences). Remove the left of these two occurrences, and the right one is replaced by the sum of this two values (that is, $2 \\cdot x$).\n\nDetermine how the array will look after described operations are performed.\n\nFor example, consider the given array looks like $[3, 4, 1, 2, 2, 1, 1]$. It will be changed in the following way: $[3, 4, 1, 2, 2, 1, 1]~\\rightarrow~[3, 4, 2, 2, 2, 1]~\\rightarrow~[3, 4, 4, 2, 1]~\\rightarrow~[3, 8, 2, 1]$.\n\nIf the given array is look like $[1, 1, 3, 1, 1]$ it will be changed in the following way: $[1, 1, 3, 1, 1]~\\rightarrow~[2, 3, 1, 1]~\\rightarrow~[2, 3, 2]~\\rightarrow~[3, 4]$.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($2 \\le n \\le 150\\,000$) \u2014 the number of elements in the array.\n\nThe second line contains a sequence from $n$ elements $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^{9}$) \u2014 the elements of the array.\n\n\n-----Output-----\n\nIn the first line print an integer $k$ \u2014 the number of elements in the array after all the performed operations. In the second line print $k$ integers \u2014 the elements of the array after all the performed operations.\n\n\n-----Examples-----\nInput\n7\n3 4 1 2 2 1 1\n\nOutput\n4\n3 8 2 1 \n\nInput\n5\n1 1 3 1 1\n\nOutput\n2\n3 4 \n\nInput\n5\n10 40 20 50 30\n\nOutput\n5\n10 40 20 50 30 \n\n\n\n-----Note-----\n\nThe first two examples were considered in the statement.\n\nIn the third example all integers in the given array are distinct, so it will not change.", "solution": "n=int(input())\nns=[int(x) for x in input().split()]\nind={}\nfor i in range(n):\n    ni=ns[i]\n    while ni in ind:\n        ns[ind[ni]]=None\n        ind.pop(ni, None)\n        ni*=2\n    ns[i]=ni\n    ind[ni]=i\nans=[str(x) for x in ns if x!=None]\nprint(len(ans))\nprint(' '.join(ans))", "pass": true}
{"task_id": "2075", "program": "MOD = 10**9 + 7\n\ndef count_valid_sequences(n, m, s):\n    # Calculate the balance and minimum balance of the given string s\n    balance = 0\n    min_balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        min_balance = min(min_balance, balance)\n    \n    # If the string s itself is invalid, return 0\n    if balance < 0:\n        return 0\n    \n    # Precompute factorials and inverse factorials for binomial coefficients\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    def binom(x, y):\n        if x < 0 or y < 0 or x < y:\n            return 0\n        return fact[x] * inv_fact[y] % MOD * inv_fact[x - y] % MOD\n    \n    # Count valid pairs (p, q)\n    result = 0\n    for p_len in range(n - m + 1):\n        q_len = n - m - p_len\n        for p_balance in range(-min_balance, p_len + 1):\n            if p_balance + balance <= q_len:\n                result = (result + binom(p_len, p_balance) * binom(q_len, p_balance + balance)) % MOD\n    \n    return result\n\n# Read input\nn, m = map(int, input().split())\ns = input().strip()\n\n# Calculate and print the result\nprint(count_valid_sequences(n, m, s))", "problem": "As Famil Door\u2019s birthday is coming, some of his friends (like Gabi) decided to buy a present for him. His friends are going to buy a string consisted of round brackets since Famil Door loves string of brackets of length n more than any other strings!\n\nThe sequence of round brackets is called valid if and only if:   the total number of opening brackets is equal to the total number of closing brackets;  for any prefix of the sequence, the number of opening brackets is greater or equal than the number of closing brackets. \n\nGabi bought a string s of length m (m \u2264 n) and want to complete it to obtain a valid sequence of brackets of length n. He is going to pick some strings p and q consisting of round brackets and merge them in a string p + s + q, that is add the string p at the beginning of the string s and string q at the end of the string s.\n\nNow he wonders, how many pairs of strings p and q exists, such that the string p + s + q is a valid sequence of round brackets. As this number may be pretty large, he wants to calculate it modulo 10^9 + 7.\n\n\n-----Input-----\n\nFirst line contains n and m (1 \u2264 m \u2264 n \u2264 100 000, n - m \u2264 2000)\u00a0\u2014 the desired length of the string and the length of the string bought by Gabi, respectively.\n\nThe second line contains string s of length m consisting of characters '(' and ')' only.\n\n\n-----Output-----\n\nPrint the number of pairs of string p and q such that p + s + q is a valid sequence of round brackets modulo 10^9 + 7.\n\n\n-----Examples-----\nInput\n4 1\n(\n\nOutput\n4\n\nInput\n4 4\n(())\n\nOutput\n1\n\nInput\n4 3\n(((\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first sample there are four different valid pairs:   p = \"(\", q = \"))\"  p = \"()\", q = \")\"  p = \"\", q = \"())\"  p = \"\", q = \")()\" \n\nIn the second sample the only way to obtain a desired string is choose empty p and q.\n\nIn the third sample there is no way to get a valid sequence of brackets.", "solution": "n, m = list(map(int, input().split()))\ns = input()\nmod = 10 ** 9 + 7\nc, b, ans, d, k = 0, 0, 0, [[1]], n - m\nfor i in s:\n    c += (i == '(') * 2 - 1\n    b = min(c, b)\nfor i in range(n - m):\n    nd = d[-1][1:] + [0] * 2\n    for j in range(1, i + 2):\n        nd[j] = (nd[j] + d[-1][j - 1]) % mod\n    d.append(nd)\nfor i in range(k + 1):\n    for j in range(-b, min(k - i - c, i) + 1):\n        ans = (ans + d[i][j] * d[k - i][j + c]) % mod\nprint(ans)\n", "pass": false}
{"task_id": "2094", "program": "MOD = 998244353\n\ndef solve(n, k, h):\n    # Calculate the number of valid answer suits\n    total_suits = pow(k, n, MOD)\n    invalid_suits = 1\n    for i in range(n):\n        if h[i] == h[(i + 1) % n]:\n            invalid_suits = (invalid_suits * k) % MOD\n    valid_suits = (total_suits - invalid_suits + MOD) % MOD\n    return valid_suits\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\nh = list(map(int, data[2:]))\n\n# Output the result\nprint(solve(n, k, h))", "problem": "Your program fails again. This time it gets \"Wrong answer on test 233\".\n\nThis is the harder version of the problem. In this version, $1 \\le n \\le 2\\cdot10^5$. You can hack this problem if you locked it. But you can hack the previous problem only if you locked both problems.\n\nThe problem is to finish $n$ one-choice-questions. Each of the questions contains $k$ options, and only one of them is correct. The answer to the $i$-th question is $h_{i}$, and if your answer of the question $i$ is $h_{i}$, you earn $1$ point, otherwise, you earn $0$ points for this question. The values $h_1, h_2, \\dots, h_n$ are known to you in this problem.\n\nHowever, you have a mistake in your program. It moves the answer clockwise! Consider all the $n$ answers are written in a circle. Due to the mistake in your program, they are shifted by one cyclically.\n\nFormally, the mistake moves the answer for the question $i$ to the question $i \\bmod n + 1$. So it moves the answer for the question $1$ to question $2$, the answer for the question $2$ to the question $3$, ..., the answer for the question $n$ to the question $1$.\n\nWe call all the $n$ answers together an answer suit. There are $k^n$ possible answer suits in total.\n\nYou're wondering, how many answer suits satisfy the following condition: after moving clockwise by $1$, the total number of points of the new answer suit is strictly larger than the number of points of the old one. You need to find the answer modulo $998\\,244\\,353$.\n\nFor example, if $n = 5$, and your answer suit is $a=[1,2,3,4,5]$, it will submitted as $a'=[5,1,2,3,4]$ because of a mistake. If the correct answer suit is $h=[5,2,2,3,4]$, the answer suit $a$ earns $1$ point and the answer suite $a'$ earns $4$ points. Since $4 > 1$, the answer suit $a=[1,2,3,4,5]$ should be counted.\n\n\n-----Input-----\n\nThe first line contains two integers $n$, $k$ ($1 \\le n \\le 2\\cdot10^5$, $1 \\le k \\le 10^9$)\u00a0\u2014 the number of questions and the number of possible answers to each question.\n\nThe following line contains $n$ integers $h_1, h_2, \\dots, h_n$, ($1 \\le h_{i} \\le k)$\u00a0\u2014 answers to the questions.\n\n\n-----Output-----\n\nOutput one integer: the number of answers suits satisfying the given condition, modulo $998\\,244\\,353$.\n\n\n-----Examples-----\nInput\n3 3\n1 3 1\n\nOutput\n9\n\nInput\n5 5\n1 1 4 2 2\n\nOutput\n1000\n\nInput\n6 2\n1 1 2 2 1 1\n\nOutput\n16\n\n\n\n-----Note-----\n\nFor the first example, valid answer suits are $[2,1,1], [2,1,2], [2,1,3], [3,1,1], [3,1,2], [3,1,3], [3,2,1], [3,2,2], [3,2,3]$.", "solution": "def main():\n    M=998244353\n    n,k,*h=map(int,open(0).read().split())\n    m=sum(i!=j for i,j in zip(h,h[1:]+h[:1]))\n    f=[0]*(m+1)\n    f[0]=b=1\n    for i in range(1,m+1):f[i]=b=b*i%M\n    inv=[0]*(m+1)\n    inv[m]=b=pow(f[m],M-2,M)\n    for i in range(m,0,-1):inv[i-1]=b=b*i%M\n    comb=lambda n,k:f[n]*inv[n-k]*inv[k]%M\n    print((pow(k,m,M)-sum(comb(m,i)*comb(m-i,i)*pow(k-2,m-i-i,M)for i in range(m//2+1)))*pow(k,n-m,M)*pow(2,M-2,M)%M)\nmain()", "pass": false}
{"task_id": "2106", "program": "def min_time_to_reach_city_n(m, k, d, s):\n    time = 0\n    fuel = s[0]\n    \n    for i in range(m):\n        if fuel < d[i]:\n            additional_fuel_needed = d[i] - fuel\n            wait_time = (additional_fuel_needed + s[i] - 1) // s[i] * k\n            time += wait_time\n            fuel += (wait_time // k) * s[i]\n        \n        time += d[i]\n        fuel -= d[i]\n        \n        if i < m - 1:\n            fuel += s[i + 1]\n    \n    return time\n\n# Read input\nm, k = map(int, input().split())\nd = list(map(int, input().split()))\ns = list(map(int, input().split()))\n\n# Calculate and print the minimum time\nprint(min_time_to_reach_city_n(m, k, d, s))", "problem": "There are n cities in the country where the Old Peykan lives. These cities are located on a straight line, we'll denote them from left to right as c_1, c_2, ..., c_{n}. The Old Peykan wants to travel from city c_1 to c_{n} using roads. There are (n - 1) one way roads, the i-th road goes from city c_{i} to city c_{i} + 1 and is d_{i} kilometers long.\n\nThe Old Peykan travels 1 kilometer in 1 hour and consumes 1 liter of fuel during this time.\n\nEach city c_{i} (except for the last city c_{n}) has a supply of s_{i} liters of fuel which immediately transfers to the Old Peykan if it passes the city or stays in it. This supply refreshes instantly k hours after it transfers. The Old Peykan can stay in a city for a while and fill its fuel tank many times. \n\nInitially (at time zero) the Old Peykan is at city c_1 and s_1 liters of fuel is transferred to it's empty tank from c_1's supply. The Old Peykan's fuel tank capacity is unlimited. Old Peykan can not continue its travel if its tank is emptied strictly between two cities.\n\nFind the minimum time the Old Peykan needs to reach city c_{n}.\n\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers m and k (1 \u2264 m, k \u2264 1000). The value m specifies the number of roads between cities which is equal to n - 1.\n\nThe next line contains m space-separated integers d_1, d_2, ..., d_{m} (1 \u2264 d_{i} \u2264 1000) and the following line contains m space-separated integers s_1, s_2, ..., s_{m} (1 \u2264 s_{i} \u2264 1000).\n\n\n-----Output-----\n\nIn the only line of the output print a single integer \u2014 the minimum time required for The Old Peykan to reach city c_{n} from city c_1.\n\n\n-----Examples-----\nInput\n4 6\n1 2 5 2\n2 3 3 4\n\nOutput\n10\n\nInput\n2 3\n5 6\n5 5\n\nOutput\n14\n\n\n\n-----Note-----\n\nIn the second sample above, the Old Peykan stays in c_1 for 3 hours.", "solution": "from math import ceil\n\nX = list(map(int, input().split()))\nDistance = list(map(int, input().split()))\nFuel = list(map(int, input().split()))\nTank, Time, Max = 0, 0, 0\nfor i in range(X[0]):\n    Tank += Fuel[i]\n    Max = max(Max, Fuel[i])\n    Stay = max(0, ceil((Distance[i] - Tank) / Max))\n    Time += Stay * X[1] + Distance[i]\n    Tank += Stay * Max - Distance[i]\nprint(Time)\n\n# Hope the best for Ravens\n# Never give up\n", "pass": false}
{"task_id": "2138", "program": "def construct_graph(n, degrees):\n    max_degree = degrees[-1]\n    num_vertices = max_degree + 1\n    edges = []\n\n    # Create a list of vertices for each degree\n    degree_vertices = {d: [] for d in degrees}\n    for i in range(1, num_vertices + 1):\n        for d in degrees:\n            if len(degree_vertices[d]) < d:\n                degree_vertices[d].append(i)\n                break\n\n    # Connect vertices to form the required degrees\n    for d in degrees:\n        vertices = degree_vertices[d]\n        for i in range(len(vertices)):\n            for j in range(i + 1, len(vertices)):\n                edges.append((vertices[i], vertices[j]))\n\n    return edges\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\ndegrees = list(map(int, data[1:]))\n\n# Construct the graph\nedges = construct_graph(n, degrees)\n\n# Output the result\nprint(len(edges))\nfor edge in edges:\n    print(edge[0], edge[1])", "problem": "You are given a sequence of n positive integers d_1, d_2, ..., d_{n} (d_1 < d_2 < ... < d_{n}). Your task is to construct an undirected graph such that:\n\n  there are exactly d_{n} + 1 vertices;  there are no self-loops;  there are no multiple edges;  there are no more than 10^6 edges;  its degree set is equal to d. \n\nVertices should be numbered 1 through (d_{n} + 1).\n\nDegree sequence is an array a with length equal to the number of vertices in a graph such that a_{i} is the number of vertices adjacent to i-th vertex.\n\nDegree set is a sorted in increasing order sequence of all distinct values from the degree sequence.\n\nIt is guaranteed that there exists such a graph that all the conditions hold, and it contains no more than 10^6 edges.\n\nPrint the resulting graph.\n\n\n-----Input-----\n\nThe first line contains one integer n (1 \u2264 n \u2264 300) \u2014 the size of the degree set.\n\nThe second line contains n integers d_1, d_2, ..., d_{n} (1 \u2264 d_{i} \u2264 1000, d_1 < d_2 < ... < d_{n}) \u2014 the degree set.\n\n\n-----Output-----\n\nIn the first line print one integer m (1 \u2264 m \u2264 10^6) \u2014 the number of edges in the resulting graph. It is guaranteed that there exists such a graph that all the conditions hold and it contains no more than 10^6 edges.\n\nEach of the next m lines should contain two integers v_{i} and u_{i} (1 \u2264 v_{i}, u_{i} \u2264 d_{n} + 1) \u2014 the description of the i-th edge.\n\n\n-----Examples-----\nInput\n3\n2 3 4\n\nOutput\n8\n3 1\n4 2\n4 5\n2 5\n5 1\n3 2\n2 1\n5 3\n\nInput\n3\n1 2 3\n\nOutput\n4\n1 2\n1 3\n1 4\n2 3", "solution": "# python3\n\n\ndef readline(): return list(map(int, input().split()))\n\n\ndef solve(d):\n    while d:\n        dn = d.pop()\n        if not d:\n            for i in range(1, dn + 1):\n                for j in range(i, dn + 1):\n                    yield i, j + 1\n            return\n        else:\n            d1 = d.pop(0)\n            for i in range(1, dn + 1):\n                for j in range(max(dn - d1 + 1, i), dn + 1):\n                    yield i, j + 1\n\n            d = [di - d1 for di in d]\n\n\ndef main():\n    n, = readline()\n    d = readline()\n\n    assert len(d) == n\n\n    edges = list(solve(d))\n    print(len(edges))\n    print(\"\\n\".join(map(\"{0[0]} {0[1]}\".format, edges)))\n\n\nmain()\n", "pass": false}
{"task_id": "2149", "program": "MOD = 998244353\n\ndef solve(n, k, h):\n    # Calculate the number of valid answer suits\n    # We need to count the number of answer suits where the shifted version scores more points than the original\n\n    # Precompute factorials and inverse factorials for binomial coefficients\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\n    def binom(x, y):\n        if x < y or y < 0:\n            return 0\n        return fact[x] * inv_fact[y] % MOD * inv_fact[x - y] % MOD\n\n    # Count the number of valid answer suits\n    result = 0\n    for i in range(1, n + 1):\n        result = (result + binom(n, i) * pow(k - 1, n - i, MOD)) % MOD\n\n    result = result * (k - 1) % MOD\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\nh = list(map(int, data[2:]))\n\n# Output the result\nprint(solve(n, k, h))", "problem": "Your program fails again. This time it gets \"Wrong answer on test 233\".\n\nThis is the easier version of the problem. In this version $1 \\le n \\le 2000$. You can hack this problem only if you solve and lock both problems.\n\nThe problem is about a test containing $n$ one-choice-questions. Each of the questions contains $k$ options, and only one of them is correct. The answer to the $i$-th question is $h_{i}$, and if your answer of the question $i$ is $h_{i}$, you earn $1$ point, otherwise, you earn $0$ points for this question. The values $h_1, h_2, \\dots, h_n$ are known to you in this problem.\n\nHowever, you have a mistake in your program. It moves the answer clockwise! Consider all the $n$ answers are written in a circle. Due to the mistake in your program, they are shifted by one cyclically.\n\nFormally, the mistake moves the answer for the question $i$ to the question $i \\bmod n + 1$. So it moves the answer for the question $1$ to question $2$, the answer for the question $2$ to the question $3$, ..., the answer for the question $n$ to the question $1$.\n\nWe call all the $n$ answers together an answer suit. There are $k^n$ possible answer suits in total.\n\nYou're wondering, how many answer suits satisfy the following condition: after moving clockwise by $1$, the total number of points of the new answer suit is strictly larger than the number of points of the old one. You need to find the answer modulo $998\\,244\\,353$.\n\nFor example, if $n = 5$, and your answer suit is $a=[1,2,3,4,5]$, it will submitted as $a'=[5,1,2,3,4]$ because of a mistake. If the correct answer suit is $h=[5,2,2,3,4]$, the answer suit $a$ earns $1$ point and the answer suite $a'$ earns $4$ points. Since $4 > 1$, the answer suit $a=[1,2,3,4,5]$ should be counted.\n\n\n-----Input-----\n\nThe first line contains two integers $n$, $k$ ($1 \\le n \\le 2000$, $1 \\le k \\le 10^9$)\u00a0\u2014 the number of questions and the number of possible answers to each question.\n\nThe following line contains $n$ integers $h_1, h_2, \\dots, h_n$, ($1 \\le h_{i} \\le k)$\u00a0\u2014 answers to the questions.\n\n\n-----Output-----\n\nOutput one integer: the number of answers suits satisfying the given condition, modulo $998\\,244\\,353$.\n\n\n-----Examples-----\nInput\n3 3\n1 3 1\n\nOutput\n9\n\nInput\n5 5\n1 1 4 2 2\n\nOutput\n1000\n\n\n\n-----Note-----\n\nFor the first example, valid answer suits are $[2,1,1], [2,1,2], [2,1,3], [3,1,1], [3,1,2], [3,1,3], [3,2,1], [3,2,2], [3,2,3]$.", "solution": "M=998244353\nclass Factorial:\n    def __init__(self,n):\n        self.f=f=[0]*(n+1)\n        f[0]=b=1\n        for i in range(1,n+1):f[i]=b=b*i%M\n        self.inv=inv=[0]*(n+1)\n        inv[n]=b=pow(self.f[n],M-2,M)\n        for i in range(n,0,-1):inv[i-1]=b=b*i%M\n    def factorial(self,i):\n        return self.f[i]\n    def ifactorial(self,i):\n        return self.inv[i]\n    def comb(self,n,k):\n        if n>=k:return self.f[n]*self.inv[n-k]*self.inv[k]%M\n        else:return 0\ndef main():\n    n,k,*h=map(int,open(0).read().split())\n    m=sum(i!=j for i,j in zip(h,h[1:]+h[:1]))\n    comb=Factorial(m).comb\n    print((pow(k,m,M)-sum(comb(m,i)*comb(m-i,i)*pow(k-2,m-i-i,M)for i in range(m//2+1)))*pow(k,n-m,M)*pow(2,M-2,M)%M)\nmain()", "pass": false}
{"task_id": "2165", "program": "def max_water_amount(n, T, a, t):\n    # Separate taps into three categories\n    less_than_T = []\n    equal_to_T = []\n    greater_than_T = []\n    \n    for i in range(n):\n        if t[i] < T:\n            less_than_T.append((a[i], t[i]))\n        elif t[i] == T:\n            equal_to_T.append((a[i], t[i]))\n        else:\n            greater_than_T.append((a[i], t[i]))\n    \n    # If there are taps with temperature exactly T, use them first\n    total_water = sum(a for a, _ in equal_to_T)\n    total_temp = T * total_water\n    \n    # Sort the taps with temperature less than T in descending order of temperature\n    less_than_T.sort(key=lambda x: x[1], reverse=True)\n    # Sort the taps with temperature greater than T in ascending order of temperature\n    greater_than_T.sort(key=lambda x: x[1])\n    \n    # Add water from taps with temperature less than T\n    for amount, temp in less_than_T:\n        if total_temp / total_water >= T:\n            break\n        total_water += amount\n        total_temp += amount * temp\n    \n    # Add water from taps with temperature greater than T\n    for amount, temp in greater_than_T:\n        if total_temp / total_water <= T:\n            break\n        total_water += amount\n        total_temp += amount * temp\n    \n    # Adjust the total water to exactly match the desired temperature T\n    if total_temp / total_water != T:\n        if total_temp / total_water < T:\n            for amount, temp in greater_than_T:\n                if total_temp / total_water >= T:\n                    break\n                needed = (T * total_water - total_temp) / (temp - T)\n                if needed <= amount:\n                    total_water += needed\n                    total_temp += needed * temp\n                    break\n                total_water += amount\n                total_temp += amount * temp\n        else:\n            for amount, temp in less_than_T:\n                if total_temp / total_water <= T:\n                    break\n                needed = (total_temp - T * total_water) / (T - temp)\n                if needed <= amount:\n                    total_water += needed\n                    total_temp += needed * temp\n                    break\n                total_water += amount\n                total_temp += amount * temp\n    \n    return total_water\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nT = int(data[1])\na = list(map(int, data[2:n+2]))\nt = list(map(int, data[n+2:2*n+2]))\n\n# Calculate and print the result\nresult = max_water_amount(n, T, a, t)\nprint(f\"{result:.12f}\")", "problem": "Consider a system of n water taps all pouring water into the same container. The i-th water tap can be set to deliver any amount of water from 0 to a_{i} ml per second (this amount may be a real number). The water delivered by i-th tap has temperature t_{i}.\n\nIf for every $i \\in [ 1, n ]$ you set i-th tap to deliver exactly x_{i} ml of water per second, then the resulting temperature of water will be $\\frac{\\sum_{i = 1}^{n} x_{i} t_{i}}{\\sum_{i = 1}^{n} x_{i}}$ (if $\\sum_{i = 1}^{n} x_{i} = 0$, then to avoid division by zero we state that the resulting water temperature is 0).\n\nYou have to set all the water taps in such a way that the resulting temperature is exactly T. What is the maximum amount of water you may get per second if its temperature has to be T?\n\n\n-----Input-----\n\nThe first line contains two integers n and T (1 \u2264 n \u2264 200000, 1 \u2264 T \u2264 10^6) \u2014 the number of water taps and the desired temperature of water, respectively.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^6) where a_{i} is the maximum amount of water i-th tap can deliver per second.\n\nThe third line contains n integers t_1, t_2, ..., t_{n} (1 \u2264 t_{i} \u2264 10^6) \u2014 the temperature of water each tap delivers.\n\n\n-----Output-----\n\nPrint the maximum possible amount of water with temperature exactly T you can get per second (if it is impossible to obtain water with such temperature, then the answer is considered to be 0).\n\nYour answer is considered correct if its absolute or relative error doesn't exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n2 100\n3 10\n50 150\n\nOutput\n6.000000000000000\n\nInput\n3 9\n5 5 30\n6 6 10\n\nOutput\n40.000000000000000\n\nInput\n2 12\n1 3\n10 15\n\nOutput\n1.666666666666667", "solution": "rd = lambda: list(map(int, input().split()))\nn, t = rd()\na = list(rd())\nb = list(rd())\nx = [[b[i], a[i]] for i in range(n)]\nx.sort()\ntot, val = sum(a), 0\nfor i in range(n):\n    val += (t - x[i][0]) * x[i][1]\nif val < 0:\n    for i in range(n - 1, -1, -1):\n        if val - x[i][1] * (t - x[i][0]) >= 0:\n            tot -= val / (t - x[i][0])\n            val = 0\n            break\n        tot -= x[i][1]\n        val -= (t - x[i][0]) * x[i][1]\nif val > 0:\n    for i in range(n):\n        if val - x[i][1] * (t - x[i][0]) <= 0:\n            tot -= val / (t - x[i][0])\n            val = 0\n            break\n        tot -= x[i][1]\n        val -= (t - x[i][0]) * x[i][1]\nprint('%.12f' % tot)\n\n", "pass": false}
{"task_id": "2229", "program": "def find_minimal_lexicographical_array(n, a):\n    # List of first 100,000 prime numbers\n    primes = []\n    is_prime = [True] * 100001\n    for i in range(2, 100001):\n        if is_prime[i]:\n            primes.append(i)\n            for j in range(i * i, 100001, i):\n                is_prime[j] = False\n\n    b = []\n    prime_index = 0\n\n    for num in a:\n        while primes[prime_index] < num:\n            prime_index += 1\n        b.append(primes[prime_index])\n        prime_index += 1\n\n    return b\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Find the minimal lexicographical array\nresult = find_minimal_lexicographical_array(n, a)\n\n# Print the result\nprint(\" \".join(map(str, result)))", "problem": "Mahmoud has an array a consisting of n integers. He asked Ehab to find another array b of the same length such that:\n\n  b is lexicographically greater than or equal to a.  b_{i} \u2265 2.  b is pairwise coprime: for every 1 \u2264 i < j \u2264 n, b_{i} and b_{j} are coprime, i.\u00a0e. GCD(b_{i}, b_{j}) = 1, where GCD(w, z) is the greatest common divisor of w and z. \n\nEhab wants to choose a special array so he wants the lexicographically minimal array between all the variants. Can you find it?\n\nAn array x is lexicographically greater than an array y if there exists an index i such than x_{i} > y_{i} and x_{j} = y_{j} for all 1 \u2264 j < i. An array x is equal to an array y if x_{i} = y_{i} for all 1 \u2264 i \u2264 n.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5), the number of elements in a and b.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (2 \u2264 a_{i} \u2264 10^5), the elements of a.\n\n\n-----Output-----\n\nOutput n space-separated integers, the i-th of them representing b_{i}.\n\n\n-----Examples-----\nInput\n5\n2 3 5 4 13\n\nOutput\n2 3 5 7 11 \nInput\n3\n10 3 7\n\nOutput\n10 3 7 \n\n\n-----Note-----\n\nNote that in the second sample, the array is already pairwise coprime so we printed it.", "solution": "# -*- coding: UTF-8 -*-\n\nMAX_NUM = 2000000\n\nprime_str = ('2      3      5      7     11     13     17     19     23     29 '\n        +   '31     37     41     43     47     53     59     61     67     71 '\n        +   '73     79     83     89     97    101    103    107    109    113 '\n        +  '127    131    137    139    149    151    157    163    167    173 '\n        +  '179    181    191    193    197    199    211    223    227    229 '\n        +  '233    239    241    251    257    263    269    271    277    281 '\n        +  '283    293    307    311    313    317 '\n)\nprime_list = [int(p) for p in prime_str.split()]\nused = [False] * MAX_NUM\n\nn = int(input())\na = list(map(int, input().split()))\n\n\ndef record(x):\n    t = []\n    for p in prime_list:\n        if x % p == 0:\n            while x % p == 0:\n                x = x // p\n            t.append(p)\n            if x == 1:\n                break\n    if x != 1:\n        t.append(x)\n\n    for ti in t:\n        for i in range(ti, MAX_NUM, ti):\n            used[i] = True\n\n\nb = []\nfor ai in a:\n    if not used[ai]:\n        b.append(ai)\n        record(ai)\n    else:\n        tmp = ai + 1\n        while used[tmp]:\n            tmp += 1\n        b.append(tmp)\n        record(tmp)\n        break\n\ntmp = 2\nwhile len(b) < len(a):\n    while used[tmp]:\n        tmp += 1\n    b.append(tmp)\n    record(tmp)\n\nprint(' '.join(str(x) for x in b))\n", "pass": false}
{"task_id": "2233", "program": "def can_make_equal_with_one_swap(k, test_cases):\n    results = []\n    for case in test_cases:\n        n, s, t = case\n        diff = []\n        for i in range(n):\n            if s[i] != t[i]:\n                diff.append(i)\n        \n        if len(diff) == 2:\n            i, j = diff\n            if s[i] == t[j] and s[j] == t[i]:\n                results.append(\"Yes\")\n            else:\n                results.append(\"No\")\n        else:\n            results.append(\"No\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nk = int(data[0])\nindex = 1\ntest_cases = []\nfor _ in range(k):\n    n = int(data[index])\n    s = data[index + 1]\n    t = data[index + 2]\n    test_cases.append((n, s, t))\n    index += 3\n\n# Get results\nresults = can_make_equal_with_one_swap(k, test_cases)\n\n# Print results\nfor result in results:\n    print(result)", "problem": "This problem is different from the hard version. In this version Ujan makes exactly one exchange. You can hack this problem only if you solve both problems.\n\nAfter struggling and failing many times, Ujan decided to try to clean up his house again. He decided to get his strings in order first.\n\nUjan has two distinct strings $s$ and $t$ of length $n$ consisting of only of lowercase English characters. He wants to make them equal. Since Ujan is lazy, he will perform the following operation exactly once: he takes two positions $i$ and $j$ ($1 \\le i,j \\le n$, the values $i$ and $j$ can be equal or different), and swaps the characters $s_i$ and $t_j$. Can he succeed?\n\nNote that he has to perform this operation exactly once. He has to perform this operation.\n\n\n-----Input-----\n\nThe first line contains a single integer $k$ ($1 \\leq k \\leq 10$), the number of test cases.\n\nFor each of the test cases, the first line contains a single integer $n$ ($2 \\leq n \\leq 10^4$), the length of the strings $s$ and $t$. \n\nEach of the next two lines contains the strings $s$ and $t$, each having length exactly $n$. The strings consist only of lowercase English letters. It is guaranteed that strings are different.\n\n\n-----Output-----\n\nFor each test case, output \"Yes\" if Ujan can make the two strings equal and \"No\" otherwise.\n\nYou can print each letter in any case (upper or lower).\n\n\n-----Example-----\nInput\n4\n5\nsouse\nhouhe\n3\ncat\ndog\n2\naa\naz\n3\nabc\nbca\n\nOutput\nYes\nNo\nNo\nNo\n\n\n\n-----Note-----\n\nIn the first test case, Ujan can swap characters $s_1$ and $t_4$, obtaining the word \"house\".\n\nIn the second test case, it is not possible to make the strings equal using exactly one swap of $s_i$ and $t_j$.", "solution": "for _ in range(int(input())):\n\tn = int(input())\n\ts, t = input(), input()\n\ti, j, ans = -1, -1, 0\n\tfor k in range(n):\n\t\tif s[k] != t[k]:\n\t\t\tif ans:\n\t\t\t\tj = k\n\t\t\telse:\n\t\t\t\ti = k\n\t\t\tans += 1\n\tif ans == 2 and (t[i] == t[j] and s[j] == s[i]):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")\n", "pass": false}
{"task_id": "2272", "program": "class IntervalGraph:\n    def __init__(self):\n        self.intervals = []\n        self.graph = []\n\n    def add_interval(self, x, y):\n        self.intervals.append((x, y))\n        self.graph.append([])\n\n        for i in range(len(self.intervals) - 1):\n            a, b = self.intervals[i]\n            if (x < a < y) or (x < b < y):\n                self.graph[-1].append(i)\n            if (a < x < b) or (a < y < b):\n                self.graph[i].append(len(self.intervals) - 1)\n\n    def can_reach(self, start, end):\n        visited = [False] * len(self.intervals)\n        return self.dfs(start - 1, end - 1, visited)\n\n    def dfs(self, current, target, visited):\n        if current == target:\n            return True\n        visited[current] = True\n        for neighbor in self.graph[current]:\n            if not visited[neighbor]:\n                if self.dfs(neighbor, target, visited):\n                    return True\n        return False\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nqueries = data[1:]\n\ninterval_graph = IntervalGraph()\noutput = []\n\ni = 0\nwhile i < len(queries):\n    if queries[i] == '1':\n        x = int(queries[i + 1])\n        y = int(queries[i + 2])\n        interval_graph.add_interval(x, y)\n        i += 3\n    elif queries[i] == '2':\n        a = int(queries[i + 1])\n        b = int(queries[i + 2])\n        if interval_graph.can_reach(a, b):\n            output.append(\"YES\")\n        else:\n            output.append(\"NO\")\n        i += 3\n\nprint(\"\\n\".join(output))", "problem": "In this problem at each moment you have a set of intervals. You can move from interval (a, b) from our set to interval (c, d) from our set if and only if c < a < d or c < b < d. Also there is a path from interval I_1 from our set to interval I_2 from our set if there is a sequence of successive moves starting from I_1 so that we can reach I_2.\n\nYour program should handle the queries of the following two types:  \"1 x y\" (x < y) \u2014 add the new interval (x, y) to the set of intervals. The length of the new interval is guaranteed to be strictly greater than all the previous intervals. \"2 a b\" (a \u2260 b) \u2014 answer the question: is there a path from a-th (one-based) added interval to b-th (one-based) added interval? \n\nAnswer all the queries. Note, that initially you have an empty set of intervals.\n\n\n-----Input-----\n\nThe first line of the input contains integer n denoting the number of queries, (1 \u2264 n \u2264 100). Each of the following lines contains a query as described above. All numbers in the input are integers and don't exceed 10^9 by their absolute value.\n\nIt's guaranteed that all queries are correct.\n\n\n-----Output-----\n\nFor each query of the second type print \"YES\" or \"NO\" on a separate line depending on the answer.\n\n\n-----Examples-----\nInput\n5\n1 1 5\n1 5 11\n2 1 2\n1 2 9\n2 1 2\n\nOutput\nNO\nYES", "solution": "flag=False;\ndef main():\n    intset=[]\n    qr=int(input())\n    for i in range(qr):\n        qqss=str(input())\n        qqss=qqss.split(\" \")\n        if qqss[0]==\"1\":\n            a=int(qqss[1])\n            b=int(qqss[2])\n            intset.append([a,b]);\n        else:\n            si=int(qqss[1])\n            fi=int(qqss[2])\n            si-=1\n            fi-=1\n            v=[False for x in range(len(intset))]\n            printIsPath(intset,si,fi,v)\n\ndef printIsPath(iset,a,b,v):\n    ast=iset[a][0]\n    aen=iset[a][1]\n    bst=iset[b][0]\n    ben=iset[b][1]\n    if bst < ast < ben or bst < aen < ben:\n        print (\"YES\")\n        return;\n    v[a]=True\n    nonlocal flag;\n    flag=False\n    for i in range(len(iset)):\n        mst=iset[i][0]\n        men=iset[i][1]\n        if  (mst < ast < men or mst < aen < men) and not v[i]:\n            if searchFinal(iset,i,b,v):\n                return;\n    if not flag:\n        print (\"NO\")\n\ndef searchFinal(iset,i,f,v):\n    v[i]=True;\n    if i==f:\n        print (\"YES\")\n        nonlocal flag;\n        flag=True;\n        return True\n    ist=iset[i][0]\n    ien=iset[i][1]\n    for j in range(len(iset)):\n        jst=iset[j][0]\n        jen=iset[j][1]\n        if not v[j] and (jst < ist < jen or jst < ien < jen):\n            searchFinal(iset,j,f,v)\n\nmain()", "pass": true}
{"task_id": "2333", "program": "def count_subpermutations(n, a):\n    from collections import defaultdict\n\n    count = 0\n    left = 0\n    freq = defaultdict(int)\n    unique_count = 0\n\n    for right in range(n):\n        if a[right] <= n:\n            if freq[a[right]] == 0:\n                unique_count += 1\n            freq[a[right]] += 1\n\n        while unique_count == right - left + 1:\n            count += 1\n            if a[left] <= n:\n                freq[a[left]] -= 1\n                if freq[a[left]] == 0:\n                    unique_count -= 1\n            left += 1\n\n    return count\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the number of subpermutations\nprint(count_subpermutations(n, a))", "problem": "You have an array $a_1, a_2, \\dots, a_n$. \n\nLet's call some subarray $a_l, a_{l + 1}, \\dots , a_r$ of this array a subpermutation if it contains all integers from $1$ to $r-l+1$ exactly once. For example, array $a = [2, 2, 1, 3, 2, 3, 1]$ contains $6$ subarrays which are subpermutations: $[a_2 \\dots a_3]$, $[a_2 \\dots a_4]$, $[a_3 \\dots a_3]$, $[a_3 \\dots a_5]$, $[a_5 \\dots a_7]$, $[a_7 \\dots a_7]$.\n\nYou are asked to calculate the number of subpermutations.\n\n\n-----Input-----\n\nThe first line contains one integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots , a_n$ ($1 \\le a_i \\le n$). \n\nThis array can contain the same integers.\n\n\n-----Output-----\n\nPrint the number of subpermutations of the array $a$.\n\n\n-----Examples-----\nInput\n8\n2 4 1 3 4 2 1 2\n\nOutput\n7\n\nInput\n5\n1 1 2 1 2\n\nOutput\n6\n\n\n\n-----Note-----\n\nThere are $7$ subpermutations in the first test case. Their segments of indices are $[1, 4]$, $[3, 3]$, $[3, 6]$, $[4, 7]$, $[6, 7]$, $[7, 7]$ and $[7, 8]$.\n\nIn the second test case $6$ subpermutations exist: $[1, 1]$, $[2, 2]$, $[2, 3]$, $[3, 4]$, $[4, 4]$ and $[4, 5]$.", "solution": "import  sys\nimport  math\ninput=sys.stdin.readline\n#sys.setrecursionlimit(1000000)\nmod=int(1000000007)\ni=lambda :map(int,input().split())\nn=int(input())\na=[int(x) for x in input().split()]\nt=[[0]*21 for i in range(300005)]\nfor i in range(n):\n    t[i][0]=a[i]\n\ndef build(n):\n    for j in range(1,20):\n        for i in range(n):\n            if i+(1<<j)-1>n-1:\n                break;\n            t[i][j]=max(t[i][j-1],t[i+(1<<(j-1))][j-1])\n\ndef query(p,q):\n    p,q=int(p),int(q)\n    log=int(math.log2(q-p+1))\n    m=t[p][log]\n    n=t[q-(1<<log)+1][log]\n    return max(m,n)\n\nb=[-1]*(n+2)\nbuild(n)\nmax1=-1\nans=0\nfor i in range(n):\n    max1=max(max1,b[a[i]])\n    b[a[i]]=i\n    x=b[1]\n    while x>max1:\n        if x<=max1:\n            break\n        p=query(x,i)\n        if p==i-x+1:\n            ans+=1\n            x=b[p+1]\n        else:\n            x=i-p+1\nprint(ans)", "pass": false}
{"task_id": "2436", "program": "def max_grannies(t, test_cases):\n    results = []\n    for i in range(t):\n        n = test_cases[i][0]\n        a = sorted(test_cases[i][1])\n        max_grannies = 1  # Maria is already in the courtyard\n        for j in range(n):\n            if a[j] <= j + 1:\n                max_grannies = j + 2  # +1 for 0-based index, +1 for Maria\n        results.append(max_grannies)\n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\ntest_cases = []\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1:index + 1 + n]))\n    test_cases.append((n, a))\n    index += 1 + n\n\n# Get results\nresults = max_grannies(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)", "problem": "Maria is the most active old lady in her house. She was tired of sitting at home. She decided to organize a ceremony against the coronavirus.\n\nShe has $n$ friends who are also grannies (Maria is not included in this number). The $i$-th granny is ready to attend the ceremony, provided that at the time of her appearance in the courtyard there will be at least $a_i$ other grannies there. Note that grannies can come into the courtyard at the same time. Formally, the granny $i$ agrees to come if the number of other grannies who came earlier or at the same time with her is greater than or equal to $a_i$.\n\nGrannies gather in the courtyard like that.  Initially, only Maria is in the courtyard (that is, the initial number of grannies in the courtyard is $1$). All the remaining $n$ grannies are still sitting at home. On each step Maria selects a subset of grannies, none of whom have yet to enter the courtyard. She promises each of them that at the time of her appearance there will be at least $a_i$ other grannies (including Maria) in the courtyard. Maria can call several grannies at once. In this case, the selected grannies will go out into the courtyard at the same moment of time. She cannot deceive grannies, that is, the situation when the $i$-th granny in the moment of appearing in the courtyard, finds that now there are strictly less than $a_i$ other grannies (except herself, but including Maria), is prohibited. Please note that if several grannies appeared in the yard at the same time, then each of them sees others at the time of appearance. \n\nYour task is to find what maximum number of grannies (including herself) Maria can collect in the courtyard for the ceremony. After all, the more people in one place during quarantine, the more effective the ceremony!\n\nConsider an example: if $n=6$ and $a=[1,5,4,5,1,9]$, then:  at the first step Maria can call grannies with numbers $1$ and $5$, each of them will see two grannies at the moment of going out into the yard (note that $a_1=1 \\le 2$ and $a_5=1 \\le 2$);  at the second step, Maria can call grannies with numbers $2$, $3$ and $4$, each of them will see five grannies at the moment of going out into the yard (note that $a_2=5 \\le 5$, $a_3=4 \\le 5$ and $a_4=5 \\le 5$);  the $6$-th granny cannot be called into the yard \u00a0\u2014 therefore, the answer is $6$ (Maria herself and another $5$ grannies). \n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases in the input. Then test cases follow.\n\nThe first line of a test case contains a single integer $n$ ($1 \\le n \\le 10^5$) \u2014 the number of grannies (Maria is not included in this number).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 2\\cdot10^5$).\n\nIt is guaranteed that the sum of the values $n$ over all test cases of the input does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print a single integer $k$ ($1 \\le k \\le n + 1$) \u2014 the maximum possible number of grannies in the courtyard.\n\n\n-----Example-----\nInput\n4\n5\n1 1 2 2 1\n6\n2 3 4 5 6 7\n6\n1 5 4 5 1 9\n5\n1 2 3 5 6\n\nOutput\n6\n1\n6\n4\n\n\n\n-----Note-----\n\nIn the first test case in the example, on the first step Maria can call all the grannies. Then each of them will see five grannies when they come out. Therefore, Maria and five other grannies will be in the yard.\n\nIn the second test case in the example, no one can be in the yard, so Maria will remain there alone.\n\nThe third test case in the example is described in the details above.\n\nIn the fourth test case in the example, on the first step Maria can call grannies with numbers $1$, $2$ and $3$. If on the second step Maria calls $4$ or $5$ (one of them), then when a granny appears in the yard, she will see only four grannies (but it is forbidden). It means that Maria can't call the $4$-th granny or the $5$-th granny separately (one of them). If she calls both: $4$ and $5$, then when they appear, they will see $4+1=5$ grannies. Despite the fact that it is enough for the $4$-th granny, the $5$-th granny is not satisfied. So, Maria cannot call both the $4$-th granny and the $5$-th granny at the same time. That is, Maria and three grannies from the first step will be in the yard in total.", "solution": "# When angry, count to four; when very angry, swear. Mark Twain\n# by : Blue Edge - Create some chaos\n\nfor _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    a.sort()\n    i=1\n    ans=0\n    for x in a:\n        if x<=i:\n            ans=i\n        i+=1\n    print(ans+1)\n", "pass": true}
{"task_id": "2471", "program": "def count_black_cells_in_subrectangles(H, W, N, painted_cells):\n    from collections import defaultdict\n\n    # Dictionary to count the number of black cells in each 3x3 subrectangle\n    subrect_count = defaultdict(int)\n\n    # Iterate over each painted cell\n    for a, b in painted_cells:\n        # Check all 3x3 subrectangles that this cell can be a part of\n        for i in range(max(1, a - 2), min(H - 2, a) + 1):\n            for j in range(max(1, b - 2), min(W - 2, b) + 1):\n                subrect_count[(i, j)] += 1\n\n    # Initialize the result array\n    result = [0] * 10\n\n    # Count the number of subrectangles with each possible number of black cells\n    for count in subrect_count.values():\n        result[count] += 1\n\n    # Calculate the total number of 3x3 subrectangles\n    total_subrectangles = (H - 2) * (W - 2)\n\n    # Calculate the number of subrectangles with 0 black cells\n    result[0] = total_subrectangles - sum(result[1:])\n\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nH = int(data[0])\nW = int(data[1])\nN = int(data[2])\n\npainted_cells = []\nfor i in range(N):\n    a = int(data[3 + 2 * i])\n    b = int(data[4 + 2 * i])\n    painted_cells.append((a, b))\n\n# Get the result\nresult = count_black_cells_in_subrectangles(H, W, N, painted_cells)\n\n# Print the result\nfor count in result:\n    print(count)", "problem": "We have a grid with H rows and W columns. At first, all cells were painted white.\nSnuke painted N of these cells. The i-th ( 1 \\leq i \\leq N ) cell he painted is the cell at the a_i-th row and b_i-th column.\nCompute the following:\n - For each integer j ( 0 \\leq j \\leq 9 ), how many subrectangles of size 3\u00d73 of the grid contains exactly j black cells, after Snuke painted N cells?\n\n-----Constraints-----\n - 3 \\leq H \\leq 10^9\n - 3 \\leq W \\leq 10^9\n - 0 \\leq N \\leq min(10^5,H\u00d7W)\n - 1 \\leq a_i \\leq H (1 \\leq i \\leq N)\n - 1 \\leq b_i \\leq W (1 \\leq i \\leq N)\n - (a_i, b_i) \\neq (a_j, b_j) (i \\neq j)\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nH W N\na_1 b_1\n:\na_N b_N\n\n-----Output-----\nPrint 10 lines.\nThe (j+1)-th ( 0 \\leq j \\leq 9 ) line should contain the number of the subrectangles of size 3\u00d73 of the grid that contains exactly j black cells.\n\n-----Sample Input-----\n4 5 8\n1 1\n1 4\n1 5\n2 3\n3 1\n3 2\n3 4\n4 4\n\n-----Sample Output-----\n0\n0\n0\n2\n4\n0\n0\n0\n0\n0\n\n\nThere are six subrectangles of size 3\u00d73. Two of them contain three black cells each, and the remaining four contain four black cells each.", "solution": "from collections import defaultdict\nfrom collections import Counter\n\nH, W, N = list(map(int, input().split()))\n\n# 3*3\u30de\u30b9\u306e\u51e6\u7406\u7528\u30ea\u30b9\u30c8\ndir = [[0, 0], [1, 0], [1, 1], [0, 1], [-1, 1],\n       [-1, 0], [-1, -1], [0, -1], [1, -1]]\n\n# \u305d\u306e\u30de\u30b9\u3092\u4e2d\u5fc3\u3068\u3059\u308b3*3\u30b0\u30ea\u30c3\u30c9\u306b\u542b\u307e\u308c\u308b\u9ed2\u30de\u30b9\u306e\u6570\ndict = defaultdict(int)\n\nfor i in range(N):\n    a, b = list(map(int, input().split()))\n    for dy, dx in dir:\n        # 3*3\u30b0\u30ea\u30c3\u30c9\u306f\u3001H*W\u306e\u4e2d\u306b\u5b8c\u5168\u306b\u542b\u307e\u308c\u3066\u3044\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3053\u3068\u306b\u6ce8\u610f\n        if 2 <= a + dy <= H - 1 and 2 <= b + dx <= W - 1:\n            dict[(a + dy, b + dx)] += 1\n\nc = Counter(list(dict.values()))\nans = [0 for _ in range(10)]\n\n# ans[1], ans[2], ..., ans[9]\u3092\u78ba\u5b9a\u3055\u305b\u308b\uff08ans[0]\u306f\u5f8c\u8ff0\uff09\nfor k, v in list(c.items()):\n    if v > 0:\n        ans[k] = v\n\n# \u5168\u4f53\u3067\u4f5c\u308c\u308b3*3\u30b0\u30ea\u30c3\u30c9\u306f(H-2)*(W-2)\u500b\n# ans[1],...,ans[9]\u306e\u7dcf\u548c\u3092\u5f15\u304f\u3068ans[0]\u306b\u306a\u308b\nans[0] = (H - 2) * (W - 2) - sum(ans[1:])\n\nfor i in range(10):\n    print((ans[i]))\n", "pass": true}
{"task_id": "2475", "program": "import sys\nimport heapq\n\ndef max_score(N, s):\n    # Initialize the dp array with a very large negative number\n    dp = [-float('inf')] * N\n    dp[0] = 0  # Starting point\n\n    # Priority queue to store the maximum score at each position\n    pq = []\n    heapq.heappush(pq, (0, 0))  # (score, position)\n\n    while pq:\n        current_score, x = heapq.heappop(pq)\n        current_score = -current_score  # Convert back to positive\n\n        # Try moving forward\n        for A in range(1, N - x):\n            y = x + A\n            if y >= N:\n                break\n            if y == N - 1:\n                return current_score\n            new_score = current_score + s[y]\n            if new_score > dp[y]:\n                dp[y] = new_score\n                heapq.heappush(pq, (-new_score, y))\n\n        # Try moving backward\n        for B in range(1, x + 1):\n            y = x - B\n            if y < 0:\n                break\n            if y == N - 1:\n                return current_score\n            new_score = current_score + s[y]\n            if new_score > dp[y]:\n                dp[y] = new_score\n                heapq.heappush(pq, (-new_score, y))\n\n    return dp[N - 1]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\ns = list(map(int, data[1:]))\n\n# Calculate and print the result\nprint(max_score(N, s))", "problem": "There is an infinitely large pond, which we consider as a number line.\nIn this pond, there are N lotuses floating at coordinates 0, 1, 2, ..., N-2 and N-1.\nOn the lotus at coordinate i, an integer s_i is written.\nYou are standing on the lotus at coordinate 0. You will play a game that proceeds as follows:\n - 1. Choose positive integers A and B. Your score is initially 0.\n - 2. Let x be your current coordinate, and y = x+A. The lotus at coordinate x disappears, and you move to coordinate y.\n - If y = N-1, the game ends.\n - If y \\neq N-1 and there is a lotus floating at coordinate y, your score increases by s_y.\n - If y \\neq N-1 and there is no lotus floating at coordinate y, you drown. Your score decreases by 10^{100} points, and the game ends.\n - 3. Let x be your current coordinate, and y = x-B. The lotus at coordinate x disappears, and you move to coordinate y.\n - If y = N-1, the game ends.\n - If y \\neq N-1 and there is a lotus floating at coordinate y, your score increases by s_y.\n - If y \\neq N-1 and there is no lotus floating at coordinate y, you drown. Your score decreases by 10^{100} points, and the game ends.\n - 4. Go back to step 2.\nYou want to end the game with as high a score as possible.\nWhat is the score obtained by the optimal choice of A and B?\n\n-----Constraints-----\n - 3 \\leq N \\leq 10^5\n - -10^9 \\leq s_i \\leq 10^9\n - s_0=s_{N-1}=0\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\ns_0 s_1 ...... s_{N-1}\n\n-----Output-----\nPrint the score obtained by the optimal choice of A and B.\n\n-----Sample Input-----\n5\n0 2 5 1 0\n\n-----Sample Output-----\n3\n\nIf you choose A = 3 and B = 2, the game proceeds as follows:\n - Move to coordinate 0 + 3 = 3. Your score increases by s_3 = 1.\n - Move to coordinate 3 - 2 = 1. Your score increases by s_1 = 2.\n - Move to coordinate 1 + 3 = 4. The game ends with a score of 3.\nThere is no way to end the game with a score of 4 or higher, so the answer is 3. Note that you cannot land the lotus at coordinate 2 without drowning later.", "solution": "import sys\ninput = sys.stdin.readline\n\nN=int(input())\nS=list(map(int,input().split()))\n\nANS=0\n\nfor i in range(1,N//2):\n    s=0\n    l=N-1\n    SCORE=0\n\n    if (N-1)%i==0:\n        while l>s and l>i:\n\n            SCORE+=S[s]+S[l]\n            ANS=max(ANS,SCORE)\n            s+=i\n            l-=i\n        #print(SCORE,i,l,s)\n    else:\n        while l!=s and l>i:\n\n            SCORE+=S[s]+S[l]\n            ANS=max(ANS,SCORE)\n            s+=i\n            l-=i\n\n        #print(SCORE,i,l,s)\n\nprint(ANS)", "pass": false}
{"task_id": "2505", "program": "MOD = 998244353\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    points = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)]\n    \n    points.sort()\n    \n    x_sorted = sorted(points)\n    y_sorted = sorted(points, key=lambda p: p[1])\n    \n    x_pos = {p: i for i, p in enumerate(x_sorted)}\n    y_pos = {p: i for i, p in enumerate(y_sorted)}\n    \n    def sum_of_powers(n):\n        return (pow(2, n, MOD) - 1) % MOD\n    \n    x_contrib = [0] * N\n    y_contrib = [0] * N\n    \n    for i in range(N):\n        x_contrib[i] = (sum_of_powers(i) + sum_of_powers(N - 1 - i)) % MOD\n        y_contrib[i] = (sum_of_powers(i) + sum_of_powers(N - 1 - i)) % MOD\n    \n    total_sum = 0\n    \n    for x, y in points:\n        xi = x_pos[(x, y)]\n        yi = y_pos[(x, y)]\n        total_sum = (total_sum + x_contrib[xi] + y_contrib[yi]) % MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    solve()", "problem": "We have a set S of N points in a two-dimensional plane. The coordinates of the i-th point are (x_i, y_i). The N points have distinct x-coordinates and distinct y-coordinates.\nFor a non-empty subset T of S, let f(T) be the number of points contained in the smallest rectangle, whose sides are parallel to the coordinate axes, that contains all the points in T. More formally, we define f(T) as follows:\n - f(T) :=  (the number of integers i (1 \\leq i \\leq N) such that a \\leq x_i \\leq b and c \\leq y_i \\leq d, where a, b, c, and d are the minimum x-coordinate, the maximum x-coordinate, the minimum y-coordinate, and the maximum y-coordinate of the points in T)\nFind the sum of f(T) over all non-empty subset T of S. Since it can be enormous, print the sum modulo 998244353.\n\n-----Constraints-----\n - 1 \\leq N \\leq 2 \\times 10^5\n - -10^9 \\leq x_i, y_i \\leq 10^9\n - x_i \\neq x_j (i \\neq j)\n - y_i \\neq y_j (i \\neq j)\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nx_1 y_1\n:\nx_N y_N\n\n-----Output-----\nPrint the sum of f(T) over all non-empty subset T of S, modulo 998244353.\n\n-----Sample Input-----\n3\n-1 3\n2 1\n3 -2\n\n-----Sample Output-----\n13\n\nLet the first, second, and third points be P_1, P_2, and P_3, respectively. S = \\{P_1, P_2, P_3\\} has seven non-empty subsets, and f has the following values for each of them:\n - f(\\{P_1\\}) = 1\n - f(\\{P_2\\}) = 1\n - f(\\{P_3\\}) = 1\n - f(\\{P_1, P_2\\}) = 2\n - f(\\{P_2, P_3\\}) = 2\n - f(\\{P_3, P_1\\}) = 3\n - f(\\{P_1, P_2, P_3\\}) = 3\nThe sum of these is 13.", "solution": "import sys\nimport array\n\nfrom operator import itemgetter\n\ndef main():\n\n\n\n\tinput = sys.stdin.readline\n\n\n\tmd = 998244353\n\tn = int(input())\n\ttl=n+1\n\t\n\tft=[0]*tl\n\n\txy = [[0]*2 for _ in range(n)]\n\tfor i in range(n):\n\t\txy[i] = [int(item) for item in input().split()]\n\txy.sort(key=itemgetter(0))\n\tyxi = [y for x, y in xy]\n\n\t*YS, = set(yxi)\n\tYS.sort()\n\tyxi= list(map({e: i for i, e in enumerate(YS)}.__getitem__, yxi))\n\n\tct=[0]*(n+1)\n\tct[0]=1\n\tfor i in range(1,n+1):\n\t\tct[i]=ct[i-1]*2%md\n\n\tcnt=tuple(ct)\n\n\tdef upd(i):\n\t\ti+=1\n\t\twhile(i<=n):\n\t\t\tft[i]+=1\n\t\t\ti+=i&-i\n\n\tdef get(i):\n\t\ti+=1\n\t\tret=0\n\t\twhile(i!=0):\n\t\t    ret+=ft[i]\n\t\t    i-=i&-i\n\t\treturn ret\n\n\tdef calc(get,upd):\n\t\tfor i, y in enumerate(yxi):\n\t\t\tv = get(y); upd(y)\n\t\t\tp1 = cnt[v]; p0 = cnt[y - v]\n\t\t\tq1 = cnt[i - v]; q0 = cnt[(n - y - 1) - (i - v)]\n\t\t\tyield (p0 + p1 + q0 + q1 - (p0 + q1) * (p1 + q0)) % md\n\n\n\tprint(((sum(calc(get,upd))+n*cnt[n] - n)%md))\n\nmain()\n", "pass": false}
{"task_id": "2581", "program": "def max_dollars(n, board):\n    # Create two dictionaries to store the sum of values on each diagonal\n    diag1 = {}\n    diag2 = {}\n\n    # Calculate the sum of values on each diagonal\n    for i in range(n):\n        for j in range(n):\n            if i + j not in diag1:\n                diag1[i + j] = 0\n            if i - j not in diag2:\n                diag2[i - j] = 0\n            diag1[i + j] += board[i][j]\n            diag2[i - j] += board[i][j]\n\n    # Find the maximum sum of values for two bishops on different diagonals\n    max_sum = 0\n    pos1 = (0, 0)\n    pos2 = (0, 0)\n\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                for l in range(n):\n                    if (i + j != k + l) and (i - j != k - l):\n                        current_sum = diag1[i + j] + diag2[i - j] + diag1[k + l] + diag2[k - l] - board[i][j] - board[k][l]\n                        if current_sum > max_sum:\n                            max_sum = current_sum\n                            pos1 = (i + 1, j + 1)\n                            pos2 = (k + 1, l + 1)\n\n    return max_sum, pos1, pos2\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nboard = []\nindex = 1\nfor i in range(n):\n    row = []\n    for j in range(n):\n        row.append(int(data[index]))\n        index += 1\n    board.append(row)\n\n# Get the result\nmax_sum, pos1, pos2 = max_dollars(n, board)\n\n# Print the result\nprint(max_sum)\nprint(pos1[0], pos1[1], pos2[0], pos2[1])", "problem": "Gargari is jealous that his friend Caisa won the game from the previous problem. He wants to prove that he is a genius.\n\nHe has a n \u00d7 n chessboard. Each cell of the chessboard has a number written on it. Gargari wants to place two bishops on the chessboard in such a way that there is no cell that is attacked by both of them. Consider a cell with number x written on it, if this cell is attacked by one of the bishops Gargari will get x dollars for it. Tell Gargari, how to place bishops on the chessboard to get maximum amount of money.\n\nWe assume a cell is attacked by a bishop, if the cell is located on the same diagonal with the bishop (the cell, where the bishop is, also considered attacked by it).\n\n\n-----Input-----\n\nThe first line contains a single integer n (2 \u2264 n \u2264 2000). Each of the next n lines contains n integers a_{ij} (0 \u2264 a_{ij} \u2264 10^9) \u2014 description of the chessboard.\n\n\n-----Output-----\n\nOn the first line print the maximal number of dollars Gargari will get. On the next line print four integers: x_1, y_1, x_2, y_2 (1 \u2264 x_1, y_1, x_2, y_2 \u2264 n), where x_{i} is the number of the row where the i-th bishop should be placed, y_{i} is the number of the column where the i-th bishop should be placed. Consider rows are numbered from 1 to n from top to bottom, and columns are numbered from 1 to n from left to right.\n\nIf there are several optimal solutions, you can print any of them.\n\n\n-----Examples-----\nInput\n4\n1 1 1 1\n2 1 1 0\n1 1 1 0\n1 0 0 1\n\nOutput\n12\n2 2 3 2", "solution": "\nfrom sys import stdin\ninput = stdin.buffer.readline\nn = int(input())\nans = []\n\nfor _ in range(n):\n    arr = list(map(int,input().split()))\n    ans.append(arr)\n\ntopLeft, bottomLeft = {}, {}\n\nfor i in range(n):\n    for j in range(n):\n        topLeft[i-j] = topLeft.get(i-j, 0) + ans[i][j]\n        bottomLeft[i+j] = bottomLeft.get(i+j, 0) + ans[i][j]\n\nmx1, mx2, pos1, pos2 = -1, -1, [-1,-1], [-1,-1]\n\nfor i in range(n):\n    for j in range(n):\n        if (i+j) & 1:\n            if mx1 < topLeft[i-j] + bottomLeft[i+j] - ans[i][j]:\n                mx1, pos1 = topLeft[i-j] + bottomLeft[i+j] - ans[i][j], [i+1,j+1]\n        else:\n            if mx2 < topLeft[i - j] + bottomLeft[i + j] - ans[i][j]:\n                mx2, pos2 = topLeft[i - j] + bottomLeft[i + j] - ans[i][j], [i+1, j+1]\n\nprint(mx1+mx2)\nprint(pos1[0], pos1[1], pos2[0], pos2[1])", "pass": false}
{"task_id": "2621", "program": "def can_win_game(n, m, k, heights):\n    for i in range(n - 1):\n        if heights[i] < heights[i + 1] - k:\n            needed_blocks = heights[i + 1] - k - heights[i]\n            if needed_blocks > m:\n                return \"NO\"\n            m -= needed_blocks\n        else:\n            m += heights[i] - max(0, heights[i + 1] - k)\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        results.append(can_win_game(n, m, k, heights))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "problem": "Gildong is playing a video game called Block Adventure. In Block Adventure, there are $n$ columns of blocks in a row, and the columns are numbered from $1$ to $n$. All blocks have equal heights. The height of the $i$-th column is represented as $h_i$, which is the number of blocks stacked in the $i$-th column.\n\nGildong plays the game as a character that can stand only on the top of the columns. At the beginning, the character is standing on the top of the $1$-st column. The goal of the game is to move the character to the top of the $n$-th column.\n\nThe character also has a bag that can hold infinitely many blocks. When the character is on the top of the $i$-th column, Gildong can take one of the following three actions as many times as he wants:   if there is at least one block on the column, remove one block from the top of the $i$-th column and put it in the bag;  if there is at least one block in the bag, take one block out of the bag and place it on the top of the $i$-th column;  if $i < n$ and $|h_i - h_{i+1}| \\le k$, move the character to the top of the $i+1$-st column. $k$ is a non-negative integer given at the beginning of the game. Note that it is only possible to move to the next column. \n\nIn actions of the first two types the character remains in the $i$-th column, and the value $h_i$ changes.\n\nThe character initially has $m$ blocks in the bag. Gildong wants to know if it is possible to win the game. Help Gildong find the answer to his question.\n\n\n-----Input-----\n\nEach test contains one or more test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). Description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, and $k$ ($1 \\le n \\le 100$, $0 \\le m \\le 10^6$, $0 \\le k \\le 10^6$) \u2014 the number of columns in the game, the number of blocks in the character's bag at the beginning, and the non-negative integer $k$ described in the statement.\n\nThe second line of each test case contains $n$ integers. The $i$-th integer is $h_i$ ($0 \\le h_i \\le 10^6$), the initial height of the $i$-th column.\n\n\n-----Output-----\n\nFor each test case, print \"YES\" if it is possible to win the game. Otherwise, print \"NO\".\n\nYou can print each letter in any case (upper or lower).\n\n\n-----Example-----\nInput\n5\n3 0 1\n4 3 5\n3 1 2\n1 4 7\n4 10 0\n10 20 10 20\n2 5 5\n0 11\n1 9 9\n99\n\nOutput\nYES\nNO\nYES\nNO\nYES\n\n\n\n-----Note-----\n\nIn the first case, Gildong can take one block from the $1$-st column, move to the $2$-nd column, put the block on the $2$-nd column, then move to the $3$-rd column.\n\nIn the second case, Gildong has to put the block in his bag on the $1$-st column to get to the $2$-nd column. But it is impossible to get to the $3$-rd column because $|h_2 - h_3| = 3 > k$ and there is no way to decrease the gap.\n\nIn the fifth case, the character is already on the $n$-th column from the start so the game is won instantly.", "solution": "t = int(input())\nfor i in range(t):\n    n, m, k = list(map(int, input().split()))\n    columns = list(map(int, input().split()))\n    bag = m\n    ok = True\n    for i in range(n - 1):\n        if columns[i + 1] - columns[i] > k:\n            bag -= (columns[i + 1] - columns[i]) - k\n            if bag < 0:\n                ok = False\n                break\n        else:\n            bag += columns[i] - max(0, columns[i + 1] - k)\n    print('YES' if ok else 'NO')\n", "pass": false}
{"task_id": "2623", "program": "This code reads multiple test cases, sorts the string for each test case, and then determines the minimal possible value of the lexicographically maximum string among the distributed strings. The results are collected and printed at the end.", "problem": "Phoenix has a string $s$ consisting of lowercase Latin letters. He wants to distribute all the letters of his string into $k$ non-empty strings $a_1, a_2, \\dots, a_k$ such that every letter of $s$ goes to exactly one of the strings $a_i$. The strings $a_i$ do not need to be substrings of $s$. Phoenix can distribute letters of $s$ and rearrange the letters within each string $a_i$ however he wants.\n\nFor example, if $s = $ baba and $k=2$, Phoenix may distribute the letters of his string in many ways, such as:   ba and ba  a and abb  ab and ab  aa and bb \n\nBut these ways are invalid:   baa and ba  b and ba  baba and empty string ($a_i$ should be non-empty) \n\nPhoenix wants to distribute the letters of his string $s$ into $k$ strings $a_1, a_2, \\dots, a_k$ to minimize the lexicographically maximum string among them, i.\u00a0e. minimize $max(a_1, a_2, \\dots, a_k)$. Help him find the optimal distribution and print the minimal possible value of $max(a_1, a_2, \\dots, a_k)$.\n\nString $x$ is lexicographically less than string $y$ if either $x$ is a prefix of $y$ and $x \\ne y$, or there exists an index $i$ ($1 \\le i \\le min(|x|, |y|))$ such that $x_i$ < $y_i$ and for every $j$ $(1 \\le j < i)$ $x_j = y_j$. Here $|x|$ denotes the length of the string $x$.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases. Each test case consists of two lines.\n\nThe first line of each test case consists of two integers $n$ and $k$ ($1 \\le k \\le n \\le 10^5$)\u00a0\u2014 the length of string $s$ and the number of non-empty strings, into which Phoenix wants to distribute letters of $s$, respectively.\n\nThe second line of each test case contains a string $s$ of length $n$ consisting only of lowercase Latin letters.\n\nIt is guaranteed that the sum of $n$ over all test cases is $\\le 10^5$.\n\n\n-----Output-----\n\nPrint $t$ answers\u00a0\u2014 one per test case. The $i$-th answer should be the minimal possible value of $max(a_1, a_2, \\dots, a_k)$ in the $i$-th test case.\n\n\n-----Example-----\nInput\n6\n4 2\nbaba\n5 2\nbaacb\n5 3\nbaacb\n5 3\naaaaa\n6 4\naaxxzz\n7 1\nphoenix\n\nOutput\nab\nabbc\nb\naa\nx\nehinopx\n\n\n\n-----Note-----\n\nIn the first test case, one optimal solution is to distribute baba into ab and ab. \n\nIn the second test case, one optimal solution is to distribute baacb into abbc and a.\n\nIn the third test case, one optimal solution is to distribute baacb into ac, ab, and b.\n\nIn the fourth test case, one optimal solution is to distribute aaaaa into aa, aa, and a.\n\nIn the fifth test case, one optimal solution is to distribute aaxxzz into az, az, x, and x.\n\nIn the sixth test case, one optimal solution is to distribute phoenix into ehinopx.", "solution": "q = int(input())\nfor _ in range(q):\n\tn,k = list(map(int,input().split()))\n\ts = list(input())\n\ts.sort()\n\tslowo = [[] for i in range(k)]\n\tif s[0] != s[k-1]:\n\t\tprint(s[k-1])\n\telse:\n\t\tif k == n:\n\t\t\tprint(s[n-1])\n\t\telse:\n\t\t\tdl = (n-1)//k\n\t\t\tif s[k] == s[-1]:\n\t\t\t\todp = [s[0]] + [s[k]]*dl\n\t\t\telse:\n\t\t\t\todp = [s[0]] + s[k:]\n\t\t\tprint(\"\".join(odp))\n", "pass": false}
{"task_id": "2638", "program": "class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        if not triangle:\n            return 0\n        \n        # Start from the second last row and move upwards\n        for row in range(len(triangle) - 2, -1, -1):\n            for col in range(len(triangle[row])):\n                # Update the current element to be the sum of itself and the minimum of the two elements directly below it\n                triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n        \n        # The top element now contains the minimum path sum\n        return triangle[0][0]", "problem": "Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.\n\nFor example, given the following triangle\n\n\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n\n\nThe minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).\n\nNote:\n\nBonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.", "solution": "class Solution:\n     def minimumTotal(self, triangle):\n         mini = 100000000\n         level =0 \n         while level < (len(triangle)-1):\n             for i in range(len(triangle[level+1])):\n                 if i==0 :\n                     triangle[level+1][i] += triangle[level][i]\n                 elif i == len(triangle[level]):\n                     triangle[level+1][i] += triangle[level][i-1]\n                 else :\n                     triangle[level+1][i] += min(triangle[level][i-1], triangle[level][i])\n                     \n             level +=1\n         \n         return  min(triangle[len(triangle)-1])\n             \n         \n \n         \"\"\"\n         :type triangle: List[List[int]]\n         :rtype: int\n         \"\"\"\n", "pass": true}
{"task_id": "2884", "program": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        def backtrack(start, target, path):\n            if target == 0:\n                res.append(path)\n                return\n            if target < 0:\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i - 1]:\n                    continue\n                backtrack(i + 1, target - candidates[i], path + [candidates[i]])\n\n        candidates.sort()\n        res = []\n        backtrack(0, target, [])\n        return res", "problem": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates\u00a0where the candidate numbers sums to target.\n\nEach number in candidates\u00a0may only be used once in the combination.\n\nNote:\n\n\n       All numbers (including target) will be positive integers.\n       The solution set must not contain duplicate combinations.\n\n\nExample 1:\n\n\nInput: candidates =\u00a0[10,1,2,7,6,1,5], target =\u00a08,\nA solution set is:\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n\n\nExample 2:\n\n\nInput: candidates =\u00a0[2,5,2,1,2], target =\u00a05,\nA solution set is:\n[\n\u00a0 [1,2,2],\n\u00a0 [5]\n]", "solution": "class Solution:\n     def combinationSum2(self, candidates, target):\n         \"\"\"\n         :type candidates: List[int]\n         :type target: int\n         :rtype: List[List[int]]\n         \"\"\"\n         res = []\n         candidates.sort()\n         self.dfs(candidates,target,0,[],res)\n         return res\n #60%\n     \n     def dfs(self,nums,target,index,path,res):\n         if target<0:\n             return \n         if target == 0:\n             res.append(path)\n             return \n         for i in range(index,len(nums)):\n             if i>index and nums[i] == nums[i-1]:\n                 continue\n             if nums[i] > target:    #   \u63d0\u5347\u523093%\n                 break\n             self.dfs(nums,target-nums[i],i+1,path+[nums[i]],res)", "pass": false}
{"task_id": "3768", "program": "def find_sequence(x, y):\n    if x == y:\n        return \"Impossible\"\n    \n    result = []\n    while x != 0 and y != 0:\n        if x > y:\n            times = x // y\n            result.append(f\"{times}A\")\n            x %= y\n        else:\n            times = y // x\n            result.append(f\"{times}B\")\n            y %= x\n    \n    return ''.join(result)\n\n# Read input\nx, y = map(int, input().split())\n\n# Find and print the sequence\nprint(find_sequence(x, y))", "problem": "Alice and Bob decided to eat some fruit. In the kitchen they found a large bag of oranges and apples. Alice immediately took an orange for herself, Bob took an apple. To make the process of sharing the remaining fruit more fun, the friends decided to play a game. They put multiple cards and on each one they wrote a letter, either 'A', or the letter 'B'. Then they began to remove the cards one by one from left to right, every time they removed a card with the letter 'A', Alice gave Bob all the fruits she had at that moment and took out of the bag as many apples and as many oranges as she had before. Thus the number of oranges and apples Alice had, did not change. If the card had written letter 'B', then Bob did the same, that is, he gave Alice all the fruit that he had, and took from the bag the same set of fruit. After the last card way removed, all the fruit in the bag were over.\n\nYou know how many oranges and apples was in the bag at first. Your task is to find any sequence of cards that Alice and Bob could have played with.\n\n\n-----Input-----\n\nThe first line of the input contains two integers, x, y (1 \u2264 x, y \u2264 10^18, xy > 1) \u2014 the number of oranges and apples that were initially in the bag.\n\n\n-----Output-----\n\nPrint any sequence of cards that would meet the problem conditions as a compressed string of characters 'A' and 'B. That means that you need to replace the segments of identical consecutive characters by the number of repetitions of the characters and the actual character. For example, string AAABAABBB should be replaced by string 3A1B2A3B, but cannot be replaced by 2A1A1B2A3B or by 3AB2A3B. See the samples for clarifications of the output format. The string that you print should consist of at most 10^6 characters. It is guaranteed that if the answer exists, its compressed representation exists, consisting of at most 10^6 characters. If there are several possible answers, you are allowed to print any of them.\n\nIf the sequence of cards that meet the problem statement does not not exist, print a single word Impossible.\n\n\n-----Examples-----\nInput\n1 4\n\nOutput\n3B\n\nInput\n2 2\n\nOutput\nImpossible\n\nInput\n3 2\n\nOutput\n1A1B\n\n\n\n-----Note-----\n\nIn the first sample, if the row contained three cards with letter 'B', then Bob should give one apple to Alice three times. So, in the end of the game Alice has one orange and three apples, and Bob has one apple, in total it is one orange and four apples.\n\nIn second sample, there is no answer since one card is not enough for game to finish, and two cards will produce at least three apples or three oranges.\n\nIn the third sample, cards contain letters 'AB', so after removing the first card Bob has one orange and one apple, and after removal of second card Alice has two oranges and one apple. So, in total it is three oranges and two apples.", "solution": "import fractions\ndef solve(x, y):\n    if fractions.gcd(x, y) > 1: return 'Impossible'\n    turn = x > y\n    if not turn: x, y = y, x\n    ans = []\n    while x != 0 and y != 0:\n        ans.append((x//y, 'A' if turn else 'B'))\n        x, y = y, x%y\n        turn = not turn\n    ans[-1] = (ans[-1][0]-1, ans[-1][1])\n    return ''.join(str(n) + l for n, l in ans)\n\nx, y = [int(x) for x in input().split()]\nprint(solve(x, y))\n", "pass": false}
{"task_id": "3807", "program": "def max_blocks_and_volume(m):\n    # Precompute cubes up to the largest possible cube less than or equal to m\n    cubes = []\n    i = 1\n    while i**3 <= m:\n        cubes.append(i**3)\n        i += 1\n\n    # Function to find the maximum number of blocks and the corresponding volume\n    def find_max_blocks(m):\n        volume = 0\n        count = 0\n        for cube in reversed(cubes):\n            while volume + cube <= m:\n                volume += cube\n                count += 1\n        return count, volume\n\n    max_count, max_volume = find_max_blocks(m)\n    print(max_count, max_volume)\n\n# Read input\nm = int(input().strip())\nmax_blocks_and_volume(m)", "problem": "Limak is a little polar bear. He plays by building towers from blocks. Every block is a cube with positive integer length of side. Limak has infinitely many blocks of each side length.\n\nA block with side a has volume a^3. A tower consisting of blocks with sides a_1, a_2, ..., a_{k} has the total volume a_1^3 + a_2^3 + ... + a_{k}^3.\n\nLimak is going to build a tower. First, he asks you to tell him a positive integer X\u00a0\u2014 the required total volume of the tower. Then, Limak adds new blocks greedily, one by one. Each time he adds the biggest block such that the total volume doesn't exceed X.\n\nLimak asks you to choose X not greater than m. Also, he wants to maximize the number of blocks in the tower at the end (however, he still behaves greedily). Secondarily, he wants to maximize X.\n\nCan you help Limak? Find the maximum number of blocks his tower can have and the maximum X \u2264 m that results this number of blocks.\n\n\n-----Input-----\n\nThe only line of the input contains one integer m (1 \u2264 m \u2264 10^15), meaning that Limak wants you to choose X between 1 and m, inclusive.\n\n\n-----Output-----\n\nPrint two integers\u00a0\u2014 the maximum number of blocks in the tower and the maximum required total volume X, resulting in the maximum number of blocks.\n\n\n-----Examples-----\nInput\n48\n\nOutput\n9 42\n\nInput\n6\n\nOutput\n6 6\n\n\n\n-----Note-----\n\nIn the first sample test, there will be 9 blocks if you choose X = 23 or X = 42. Limak wants to maximize X secondarily so you should choose 42.\n\nIn more detail, after choosing X = 42 the process of building a tower is:  Limak takes a block with side 3 because it's the biggest block with volume not greater than 42. The remaining volume is 42 - 27 = 15.  The second added block has side 2, so the remaining volume is 15 - 8 = 7.  Finally, Limak adds 7 blocks with side 1, one by one. \n\nSo, there are 9 blocks in the tower. The total volume is is 3^3 + 2^3 + 7\u00b71^3 = 27 + 8 + 7 = 42.", "solution": "MAX = 100005\n\ndef big_pow3(n):\n    l = 0; p = MAX\n    while p-l != 1:\n        mid = (p+l+1)//2\n        if (mid*mid*mid <= n):\n            l = mid\n        else:\n            p = mid\n    return l\n\ndef f(n):\n    if n < 8:\n        return [n, n]\n    a = int((n+ 0.5) ** 0.33333333333333333)\n    r1 = f(n-a**3)\n    r1 = [r1[0] + 1, r1[1] + a**3]\n    a -= 1\n    r2 = f(3*a*(a+1))\n    r2 = [r2[0] + 1, r2[1] + a**3]\n    return max(r1, r2)\n        \n\ndef __starting_point():\n    m = int(input()) \n    print(*f(m))\n\n__starting_point()", "pass": false}
{"task_id": "3838", "program": "def is_possible(n, k, q, s):\n    # Create the inverse of permutation q\n    q_inv = [0] * n\n    for i in range(n):\n        q_inv[q[i] - 1] = i + 1\n\n    # Start with the initial permutation\n    p = list(range(1, n + 1))\n\n    # Function to apply permutation q\n    def apply_q(p):\n        return [p[q[i] - 1] for i in range(n)]\n\n    # Function to apply inverse permutation q_inv\n    def apply_q_inv(p):\n        return [p[q_inv[i] - 1] for i in range(n)]\n\n    # Check if we can reach s in exactly k moves\n    for i in range(k + 1):\n        if i % 2 == 0:\n            if p == s:\n                return \"NO\"\n        else:\n            if p == s:\n                return \"YES\"\n        p = apply_q(p)\n\n    p = list(range(1, n + 1))\n    for i in range(k + 1):\n        if i % 2 == 0:\n            if p == s:\n                return \"NO\"\n        else:\n            if p == s:\n                return \"YES\"\n        p = apply_q_inv(p)\n\n    return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nq = list(map(int, input().split()))\ns = list(map(int, input().split()))\n\n# Output the result\nprint(is_possible(n, k, q, s))", "problem": "Little Petya likes permutations a lot. Recently his mom has presented him permutation q_1, q_2, ..., q_{n} of length n.\n\nA permutation a of length n is a sequence of integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 n), all integers there are distinct. \n\nThere is only one thing Petya likes more than permutations: playing with little Masha. As it turns out, Masha also has a permutation of length n. Petya decided to get the same permutation, whatever the cost may be. For that, he devised a game with the following rules:  Before the beginning of the game Petya writes permutation 1, 2, ..., n on the blackboard. After that Petya makes exactly k moves, which are described below.  During a move Petya tosses a coin. If the coin shows heads, he performs point 1, if the coin shows tails, he performs point 2.  Let's assume that the board contains permutation p_1, p_2, ..., p_{n} at the given moment. Then Petya removes the written permutation p from the board and writes another one instead: p_{q}_1, p_{q}_2, ..., p_{q}_{n}. In other words, Petya applies permutation q (which he has got from his mother) to permutation p.  All actions are similar to point 1, except that Petya writes permutation t on the board, such that: t_{q}_{i} = p_{i} for all i from 1 to n. In other words, Petya applies a permutation that is inverse to q to permutation p. \n\nWe know that after the k-th move the board contained Masha's permutation s_1, s_2, ..., s_{n}. Besides, we know that throughout the game process Masha's permutation never occurred on the board before the k-th move. Note that the game has exactly k moves, that is, throughout the game the coin was tossed exactly k times.\n\nYour task is to determine whether the described situation is possible or else state that Petya was mistaken somewhere. See samples and notes to them for a better understanding.\n\n\n-----Input-----\n\nThe first line contains two integers n and k (1 \u2264 n, k \u2264 100). The second line contains n space-separated integers q_1, q_2, ..., q_{n} (1 \u2264 q_{i} \u2264 n) \u2014 the permutation that Petya's got as a present. The third line contains Masha's permutation s, in the similar format.\n\nIt is guaranteed that the given sequences q and s are correct permutations.\n\n\n-----Output-----\n\nIf the situation that is described in the statement is possible, print \"YES\" (without the quotes), otherwise print \"NO\" (without the quotes).\n\n\n-----Examples-----\nInput\n4 1\n2 3 4 1\n1 2 3 4\n\nOutput\nNO\n\nInput\n4 1\n4 3 1 2\n3 4 2 1\n\nOutput\nYES\n\nInput\n4 3\n4 3 1 2\n3 4 2 1\n\nOutput\nYES\n\nInput\n4 2\n4 3 1 2\n2 1 4 3\n\nOutput\nYES\n\nInput\n4 1\n4 3 1 2\n2 1 4 3\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first sample Masha's permutation coincides with the permutation that was written on the board before the beginning of the game. Consequently, that violates the condition that Masha's permutation never occurred on the board before k moves were performed.\n\nIn the second sample the described situation is possible, in case if after we toss a coin, we get tails.\n\nIn the third sample the possible coin tossing sequence is: heads-tails-tails.\n\nIn the fourth sample the possible coin tossing sequence is: heads-heads.", "solution": "import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\nn, k = mints()\nq = list(mints())\nfor i in range(n):\n\tq[i] -= 1\ns = list(mints())\na = [i for i in range(1,n+1)]\nd = [0]*n\nb = [False]*(k+1)\nc = [False]*(k+1)\ne = [10000]*2\nf = [10000]*2\nfor i in range(k+1):\n\t#print(a)\n\tb[i] = (a == s)\n\tif b[i]:\n\t\te[i%2] = min(e[i%2], i)\n\tfor j in range(n):\n\t\td[j] = a[q[j]]\n\ta,d = d,a\n#print('====')\na = [i for i in range(1,n+1)]\nfor i in range(k+1):\n\t#print(a)\n\tc[i] = (a == s)\n\tif c[i]:\n\t\tf[i%2] = min(f[i%2], i)\n\tfor j in range(n):\n\t\td[q[j]] = a[j]\n\ta,d = d,a\n#print('====')\n#print(e)\n#print(f)\nif e[0] == 0:\n\tprint('NO')\nelif e[1] == 1:\n\tif f[1] == 1 and k > 1:\n\t\tprint('NO')\n\telif k%2 == 1 or f[k%2] <= k:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nelif f[1] == 1:\n\tif k%2 == 1 or e[k%2] <= k:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nelse:\n\tif e[k%2] <= k or f[k%2] <= k:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n", "pass": false}
{"task_id": "3920", "program": "# Read input\na1, a2, a3, a4, a5, a6 = map(int, input().split())\n\n# Calculate the number of 1 cm side triangles\n# The formula for the number of triangles in such a hexagon is:\n# T = (a1 + a2 + a3)^2 - a1^2 - a3^2 - a5^2\n\n# Calculate the sum of a1, a2, and a3\nsum_a1_a2_a3 = a1 + a2 + a3\n\n# Calculate the number of triangles\nnum_triangles = sum_a1_a2_a3**2 - a1**2 - a3**2 - a5**2\n\n# Print the result\nprint(num_triangles)", "problem": "Gerald got a very curious hexagon for his birthday. The boy found out that all the angles of the hexagon are equal to $120^{\\circ}$. Then he measured the length of its sides, and found that each of them is equal to an integer number of centimeters. There the properties of the hexagon ended and Gerald decided to draw on it.\n\nHe painted a few lines, parallel to the sides of the hexagon. The lines split the hexagon into regular triangles with sides of 1 centimeter. Now Gerald wonders how many triangles he has got. But there were so many of them that Gerald lost the track of his counting. Help the boy count the triangles.\n\n\n-----Input-----\n\nThe first and the single line of the input contains 6 space-separated integers a_1, a_2, a_3, a_4, a_5 and a_6 (1 \u2264 a_{i} \u2264 1000) \u2014 the lengths of the sides of the hexagons in centimeters in the clockwise order. It is guaranteed that the hexagon with the indicated properties and the exactly such sides exists.\n\n\n-----Output-----\n\nPrint a single integer \u2014 the number of triangles with the sides of one 1 centimeter, into which the hexagon is split.\n\n\n-----Examples-----\nInput\n1 1 1 1 1 1\n\nOutput\n6\n\nInput\n1 2 1 2 1 2\n\nOutput\n13\n\n\n\n-----Note-----\n\nThis is what Gerald's hexagon looks like in the first sample:\n\n$\\theta$\n\nAnd that's what it looks like in the second sample:\n\n$A$", "solution": "from math import radians, cos, sin, atan2, sqrt, floor, acos\n\ndef rotate(point, alpha):\n    x = point[0]\n    y = point[1]\n    return (x * cos(alpha) - y * sin(alpha), x * sin(alpha) + y * cos(alpha))\n\ndef crs(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef m(end, start):\n    return (end[0] - start[0], end[1] - start[1])\n\ndef area(poly):\n    ret = 0\n    n = len(poly)\n\n    for i in range(n):\n        j = (i + 1) % n\n        ret += crs(poly[i], poly[j])\n\n    return abs(ret) / 2.0\n\ndef dist(a, b):\n    return sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)\n\ndef get_next_point(p0, p1, x, y):\n    r = ((p1[0] - p0[0]) / x * y, (p1[1] - p0[1]) / x * y)\n    r = rotate(r, radians(60))\n\n    return (p1[0] + r[0], p1[1] + r[1])\n\n\na = list(map(int, input().split()))\n\n\npnt = [(0, 0), (a[0], 0)]\n\nfor i in range(1, len(a)):\n    pnt.append(get_next_point(pnt[-2], pnt[-1], a[i - 1], a[i]))\n    assert((dist(pnt[-2], pnt[-1]) - a[i]) <= 1e-7)\n\n\nret = area(pnt) * 4 / sqrt(3)\nfor i in range(floor(ret), floor(ret) + 3):\n    if abs(ret - i) < 1e-7:\n        ret = i\n\nprint(ret)\n", "pass": true}
{"task_id": "3942", "program": "def make_beautiful(s):\n    n = len(s)\n    open_count = s.count('(')\n    close_count = s.count(')')\n    hash_count = s.count('#')\n    \n    # The number of ')' we need to balance the '('\n    needed_closes = open_count - close_count\n    \n    # If we need more ')' than we have '#', it's impossible\n    if needed_closes < hash_count:\n        print(-1)\n        return\n    \n    # We will replace each '#' with at least 1 ')'\n    result = [1] * hash_count\n    needed_closes -= hash_count\n    \n    # Distribute the remaining needed_closes to the last '#'\n    result[-1] += needed_closes\n    \n    # Now we need to check if this distribution makes the string beautiful\n    balance = 0\n    hash_index = 0\n    \n    for char in s:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        elif char == '#':\n            balance -= result[hash_index]\n            hash_index += 1\n        \n        if balance < 0:\n            print(-1)\n            return\n    \n    if balance != 0:\n        print(-1)\n        return\n    \n    for num in result:\n        print(num)\n\n# Read input\nimport sys\ninput = sys.stdin.read().strip()\nmake_beautiful(input)", "problem": "Malek has recently found a treasure map. While he was looking for a treasure he found a locked door. There was a string s written on the door consisting of characters '(', ')' and '#'. Below there was a manual on how to open the door. After spending a long time Malek managed to decode the manual and found out that the goal is to replace each '#' with one or more ')' characters so that the final string becomes beautiful. \n\nBelow there was also written that a string is called beautiful if for each i (1 \u2264 i \u2264 |s|) there are no more ')' characters than '(' characters among the first i characters of s and also the total number of '(' characters is equal to the total number of ')' characters. \n\nHelp Malek open the door by telling him for each '#' character how many ')' characters he must replace it with.\n\n\n-----Input-----\n\nThe first line of the input contains a string s (1 \u2264 |s| \u2264 10^5). Each character of this string is one of the characters '(', ')' or '#'. It is guaranteed that s contains at least one '#' character.\n\n\n-----Output-----\n\nIf there is no way of replacing '#' characters which leads to a beautiful string print  - 1. Otherwise for each character '#' print a separate line containing a positive integer, the number of ')' characters this character must be replaced with.\n\nIf there are several possible answers, you may output any of them.\n\n\n-----Examples-----\nInput\n(((#)((#)\n\nOutput\n1\n2\n\nInput\n()((#((#(#()\n\nOutput\n2\n2\n1\nInput\n#\n\nOutput\n-1\n\nInput\n(#)\n\nOutput\n-1\n\n\n\n-----Note-----\n\n|s| denotes the length of the string s.", "solution": "def needs_trailing(segment):\n    open_parens = 0\n    for i in segment:\n        if i == '(':\n            open_parens += 1\n        elif i == ')' or i == '#':\n            open_parens -= 1\n\n        if open_parens < 0:\n            return -1\n    return open_parens\n\n\nline = input()\nextra_parens = needs_trailing(line)\nlast_segment_needs = needs_trailing(line.split('#')[-1])\n\nif extra_parens < 0:  # too many ) already in string\n    print(-1)\nelif last_segment_needs > 0:  # end block isn't beautiful, can't fix\n    print(-1)\nelse:\n    outputs = [1 for i in range(line.count('#'))]\n    outputs[-1] += needs_trailing(line)  # if valid, add all extras to the last space\n    new_str = line.rpartition('#')[0].replace('#', ')') + outputs[-1] * ')' + line.rpartition('#')[-1]\n    if needs_trailing(new_str) != 0:\n        print(-1)\n    else:\n        for output in outputs:\n            print(output)\n\n", "pass": true}
{"task_id": "3987", "program": "def max_non_decreasing_subsequence_length(n, a):\n    # Calculate the length of the longest non-decreasing subsequence\n    # without any reversal\n    def longest_non_decreasing_subsequence_length(arr):\n        dp = [1] * len(arr)\n        for i in range(1, len(arr)):\n            for j in range(i):\n                if arr[i] >= arr[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    # Calculate the prefix and suffix longest non-decreasing subsequence lengths\n    prefix = [0] * n\n    suffix = [0] * n\n\n    # Calculate prefix lengths\n    for i in range(n):\n        prefix[i] = longest_non_decreasing_subsequence_length(a[:i+1])\n\n    # Calculate suffix lengths\n    for i in range(n-1, -1, -1):\n        suffix[i] = longest_non_decreasing_subsequence_length(a[i:])\n\n    # Try reversing each possible subarray and calculate the maximum length\n    max_length = 0\n    for l in range(n):\n        for r in range(l, n):\n            # Reverse the subarray a[l:r+1]\n            reversed_subarray = a[:l] + a[l:r+1][::-1] + a[r+1:]\n            max_length = max(max_length, longest_non_decreasing_subsequence_length(reversed_subarray))\n\n    return max_length\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Get the result\nresult = max_non_decreasing_subsequence_length(n, a)\n\n# Print the result\nprint(result)", "problem": "A dragon symbolizes wisdom, power and wealth. On Lunar New Year's Day, people model a dragon with bamboo strips and clothes, raise them with rods, and hold the rods high and low to resemble a flying dragon.\n\nA performer holding the rod low is represented by a 1, while one holding it high is represented by a 2. Thus, the line of performers can be represented by a sequence a_1, a_2, ..., a_{n}.\n\nLittle Tommy is among them. He would like to choose an interval [l, r] (1 \u2264 l \u2264 r \u2264 n), then reverse a_{l}, a_{l} + 1, ..., a_{r} so that the length of the longest non-decreasing subsequence of the new sequence is maximum.\n\nA non-decreasing subsequence is a sequence of indices p_1, p_2, ..., p_{k}, such that p_1 < p_2 < ... < p_{k} and a_{p}_1 \u2264 a_{p}_2 \u2264 ... \u2264 a_{p}_{k}. The length of the subsequence is k.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 2000), denoting the length of the original sequence.\n\nThe second line contains n space-separated integers, describing the original sequence a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 2, i = 1, 2, ..., n).\n\n\n-----Output-----\n\nPrint a single integer, which means the maximum possible length of the longest non-decreasing subsequence of the new sequence.\n\n\n-----Examples-----\nInput\n4\n1 2 1 2\n\nOutput\n4\n\nInput\n10\n1 1 2 2 2 1 1 2 2 1\n\nOutput\n9\n\n\n\n-----Note-----\n\nIn the first example, after reversing [2, 3], the array will become [1, 1, 2, 2], where the length of the longest non-decreasing subsequence is 4.\n\nIn the second example, after reversing [3, 7], the array will become [1, 1, 1, 1, 2, 2, 2, 2, 2, 1], where the length of the longest non-decreasing subsequence is 9.", "solution": "input()\na = list(map(int, input().split()))\n\np1,p2,p3,p4=0,0,0,0\n\nfor n in a:\n    if n == 1:\n        p1 += 1\n        p3 = max(p3 + 1, p2 + 1)\n    else:\n        p2 = max(p2 + 1, p1 + 1)\n        p4 = max(p4 + 1, p3 + 1)\nprint(max(p1,p2,p3,p4))", "pass": false}
{"task_id": "3992", "program": "import math\nfrom functools import reduce\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef min_seconds_to_make_alice_happy(n, chocolates):\n    if n == 1:\n        return -1 if chocolates[0] == 1 else 0\n    \n    gcd_all = find_gcd_of_list(chocolates)\n    \n    if gcd_all == 1:\n        return -1\n    \n    return 0\n\n# Read input\nn = int(input().strip())\nchocolates = list(map(int, input().strip().split()))\n\n# Calculate and print the result\nprint(min_seconds_to_make_alice_happy(n, chocolates))", "problem": "This is the harder version of the problem. In this version, $1 \\le n \\le 10^6$ and $0 \\leq a_i \\leq 10^6$. You can hack this problem if you locked it. But you can hack the previous problem only if you locked both problems\n\nChristmas is coming, and our protagonist, Bob, is preparing a spectacular present for his long-time best friend Alice. This year, he decides to prepare $n$ boxes of chocolate, numbered from $1$ to $n$. Initially, the $i$-th box contains $a_i$ chocolate pieces.\n\nSince Bob is a typical nice guy, he will not send Alice $n$ empty boxes. In other words, at least one of $a_1, a_2, \\ldots, a_n$ is positive. Since Alice dislikes coprime sets, she will be happy only if there exists some integer $k > 1$ such that the number of pieces in each box is divisible by $k$. Note that Alice won't mind if there exists some empty boxes. \n\nCharlie, Alice's boyfriend, also is Bob's second best friend, so he decides to help Bob by rearranging the chocolate pieces. In one second, Charlie can pick up a piece in box $i$ and put it into either box $i-1$ or box $i+1$ (if such boxes exist). Of course, he wants to help his friend as quickly as possible. Therefore, he asks you to calculate the minimum number of seconds he would need to make Alice happy.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 10^6$)\u00a0\u2014 the number of chocolate boxes.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^6$)\u00a0\u2014 the number of chocolate pieces in the $i$-th box.\n\nIt is guaranteed that at least one of $a_1, a_2, \\ldots, a_n$ is positive.\n\n\n-----Output-----\n\nIf there is no way for Charlie to make Alice happy, print $-1$.\n\nOtherwise, print a single integer $x$\u00a0\u2014 the minimum number of seconds for Charlie to help Bob make Alice happy.\n\n\n-----Examples-----\nInput\n3\n4 8 5\n\nOutput\n9\n\nInput\n5\n3 10 2 1 5\n\nOutput\n2\n\nInput\n4\n0 5 15 10\n\nOutput\n0\n\nInput\n1\n1\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first example, Charlie can move all chocolate pieces to the second box. Each box will be divisible by $17$.\n\nIn the second example, Charlie can move a piece from box $2$ to box $3$ and a piece from box $4$ to box $5$. Each box will be divisible by $3$.\n\nIn the third example, each box is already divisible by $5$.\n\nIn the fourth example, since Charlie has no available move, he cannot help Bob make Alice happy.", "solution": "# \u7d20\u56e0\u6570\u5206\u89e3\ndef prime_decomposition(n):\n    i = 2\n    table = []\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            table.append(i)\n        i += 1\n    if n > 1:\n        table.append(n)\n    return table\nimport sys\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int, input().split()))\n# \u304b\u3051\u3089\u3092\u79fb\u52d5\u3055\u305b\u3066\u5171\u901a\u56e0\u6570\u3092\u6301\u3064\u3088\u3046\u306b\u3059\u308b\nsu = sum(A)\nif su == 1:\n    print(-1)\n    return\nprimes = sorted(set(prime_decomposition(su)))\nans = 10**18\n\nfor p in primes:\n    an = 0\n    half = p >> 1\n    cnt = 0\n    for a in A:\n        a %= p\n        cnt += a\n        if cnt <= half:\n            an += cnt\n        else:\n            if cnt < p:\n                an += p - cnt\n            else:\n                cnt -= p\n                if cnt <= half:\n                    an += cnt\n                else:\n                    an += p - cnt\n        if ans <= an:\n            break\n    else:\n        ans = min(ans, an)\nprint(ans)\n", "pass": false}
{"task_id": "4059", "program": "N = int(input())\n\ncount = 0\n\nfor A in range(1, N):\n    for B in range(1, (N // A) + 1):\n        C = N - A * B\n        if C > 0:\n            count += 1\n\nprint(count)", "problem": "Given is a positive integer N.\nHow many tuples (A,B,C) of positive integers satisfy A \\times B + C = N?\n\n-----Constraints-----\n -  2 \\leq N \\leq 10^6\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\n\n-----Output-----\nPrint the answer.\n\n-----Sample Input-----\n3\n\n-----Sample Output-----\n3\n\nThere are 3 tuples of integers that satisfy A \\times B + C = 3: (A, B, C) = (1, 1, 2), (1, 2, 1), (2, 1, 1).", "solution": "n = int(input())\nans = 0\nfor i in range(n-1):\n    ans += (n-1)//(i+1)\n\nprint(ans)", "pass": false}
{"task_id": "4098", "program": "def max_students_in_teams(n, k, skills):\n    skills.sort()\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = dp[i - 1][j]\n            l = i\n            while l > 0 and skills[i - 1] - skills[l - 1] <= 5:\n                l -= 1\n            dp[i][j] = max(dp[i][j], dp[l][j - 1] + (i - l))\n    \n    return max(dp[n])\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\nskills = list(map(int, data[2:]))\n\n# Get the result and print it\nresult = max_students_in_teams(n, k, skills)\nprint(result)", "problem": "You are a coach at your local university. There are $n$ students under your supervision, the programming skill of the $i$-th student is $a_i$.\n\nYou have to form $k$ teams for yet another new programming competition. As you know, the more students are involved in competition the more probable the victory of your university is! So you have to form no more than $k$ (and at least one) non-empty teams so that the total number of students in them is maximized. But you also know that each team should be balanced. It means that the programming skill of each pair of students in each team should differ by no more than $5$. Teams are independent from one another (it means that the difference between programming skills of two students from two different teams does not matter).\n\nIt is possible that some students not be included in any team at all.\n\nYour task is to report the maximum possible total number of students in no more than $k$ (and at least one) non-empty balanced teams.\n\nIf you are Python programmer, consider using PyPy instead of Python when you submit your code.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 5000$) \u2014 the number of students and the maximum number of teams, correspondingly.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is a programming skill of the $i$-th student.\n\n\n-----Output-----\n\nPrint one integer \u2014 the maximum possible total number of students in no more than $k$ (and at least one) non-empty balanced teams.\n\n\n-----Examples-----\nInput\n5 2\n1 2 15 15 15\n\nOutput\n5\n\nInput\n6 1\n36 4 1 25 9 16\n\nOutput\n2\n\nInput\n4 4\n1 10 100 1000\n\nOutput\n4", "solution": "# -*- coding: utf-8 -*-\n# @Time    : 2019/3/8 0:18\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : E. K Balanced Teams.py\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    a.sort()\n\n    cnt = [0] * n\n    for i in range(n):\n        while i + cnt[i] < n and a[i + cnt[i]] - a[i] <= 5:\n            cnt[i] += 1\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(k + 1):\n            dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])\n            if j + 1 <= k:\n                dp[i + cnt[i]][j + 1] = max(dp[i + cnt[i]][j + 1], dp[i][j] + cnt[i])\n\n    print(dp[n][k])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "pass": true}
{"task_id": "4132", "program": "import sys\nimport math\ninput = sys.stdin.read\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    result = A[0]\n    for i in range(1, N):\n        result = gcd(result, A[i])\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "problem": "There are N monsters, numbered 1, 2, ..., N.\nInitially, the health of Monster i is A_i.\nBelow, a monster with at least 1 health is called alive.\nUntil there is only one alive monster, the following is repeated:\n - A random alive monster attacks another random alive monster.\n - As a result, the health of the monster attacked is reduced by the amount equal to the current health of the monster attacking.\nFind the minimum possible final health of the last monster alive.\n\n-----Constraints-----\n - All values in input are integers.\n - 2 \\leq N \\leq 10^5\n - 1 \\leq A_i \\leq 10^9\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nA_1 A_2 ... A_N\n\n-----Output-----\nPrint the minimum possible final health of the last monster alive.\n\n-----Sample Input-----\n4\n2 10 8 40\n\n-----Sample Output-----\n2\n\nWhen only the first monster keeps on attacking, the final health of the last monster will be 2, which is minimum.", "solution": "import math\nfrom functools import reduce\nn=int(input())\na=list(map(int,input().split()))\n\ndef gcd(numbers):\n    return reduce(math.gcd, numbers)\n\nprint(gcd(a))", "pass": false}
{"task_id": "4175", "program": "def check_shiritori(N, words):\n    used_words = set()\n    last_char = words[0][0]\n    \n    for word in words:\n        if word in used_words or word[0] != last_char:\n            return \"No\"\n        used_words.add(word)\n        last_char = word[-1]\n    \n    return \"Yes\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nwords = data[1:]\n\n# Check the shiritori rules\nresult = check_shiritori(N, words)\nprint(result)", "problem": "Takahashi is practicing shiritori alone again today.\nShiritori is a game as follows:\n - In the first turn, a player announces any one word.\n - In the subsequent turns, a player announces a word that satisfies the following conditions:\n - That word is not announced before.\n - The first character of that word is the same as the last character of the last word announced.\nIn this game, he is practicing to announce as many words as possible in ten seconds.\nYou are given the number of words Takahashi announced, N, and the i-th word he announced, W_i, for each i. Determine if the rules of shiritori was observed, that is, every word announced by him satisfied the conditions.\n\n-----Constraints-----\n - N is an integer satisfying 2 \\leq N \\leq 100.\n - W_i is a string of length between 1 and 10 (inclusive) consisting of lowercase English letters.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nW_1\nW_2\n:\nW_N\n\n-----Output-----\nIf every word announced by Takahashi satisfied the conditions, print Yes; otherwise, print No.\n\n-----Sample Input-----\n4\nhoge\nenglish\nhoge\nenigma\n\n-----Sample Output-----\nNo\n\nAs hoge is announced multiple times, the rules of shiritori was not observed.", "solution": "n = int(input())\nseen = set()\ntmp = \"\"\nfor _ in range(n):\n    x = input()\n    if not tmp:\n        seen.add(x)\n        tmp = x[-1]\n        continue\n    elif x[0] != tmp or x in seen:\n        print(\"No\")\n        return\n    else:\n        seen.add(x)\n        tmp = x[-1]\nprint(\"Yes\")\n", "pass": true}
{"task_id": "4182", "program": "# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nX = int(data[2])\nY = int(data[3])\nx = list(map(int, data[4:4+N]))\ny = list(map(int, data[4+N:]))\n\n# Determine the maximum of x_i and the minimum of y_i\nmax_x = max(x)\nmin_y = min(y)\n\n# Check if there exists a Z that satisfies the conditions\nif X < min_y and max_x < min_y and X < Y:\n    print(\"No War\")\nelse:\n    print(\"War\")", "problem": "Our world is one-dimensional, and ruled by two empires called Empire A and Empire B.\nThe capital of Empire A is located at coordinate X, and that of Empire B is located at coordinate Y.\nOne day, Empire A becomes inclined to put the cities at coordinates x_1, x_2, ..., x_N under its control, and Empire B becomes inclined to put the cities at coordinates y_1, y_2, ..., y_M under its control.\nIf there exists an integer Z that satisfies all of the following three conditions, they will come to an agreement, but otherwise war will break out.\n - X < Z \\leq Y\n - x_1, x_2, ..., x_N < Z\n - y_1, y_2, ..., y_M \\geq Z\nDetermine if war will break out.\n\n-----Constraints-----\n - All values in input are integers.\n - 1 \\leq N, M \\leq 100\n - -100 \\leq X < Y \\leq 100\n - -100 \\leq x_i, y_i \\leq 100\n - x_1, x_2, ..., x_N \\neq X\n - x_i are all different.\n - y_1, y_2, ..., y_M \\neq Y\n - y_i are all different.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M X Y\nx_1 x_2 ... x_N\ny_1 y_2 ... y_M\n\n-----Output-----\nIf war will break out, print War; otherwise, print No War.\n\n-----Sample Input-----\n3 2 10 20\n8 15 13\n16 22\n\n-----Sample Output-----\nNo War\n\nThe choice Z = 16 satisfies all of the three conditions as follows, thus they will come to an agreement.\n - X = 10 < 16 \\leq 20 = Y\n - 8, 15, 13 < 16\n - 16, 22 \\geq 16", "solution": "n,m,x,y=list(map(int,input().split()))\nX=list(map(int,input().split()))\nY=list(map(int,input().split()))\nmx=max(X)\nmy=min(Y)\nif mx<my:\n    for i in range(mx+1,my+1):\n        if x<i<=y:\n            print(\"No War\")\n            return\n    print(\"War\")\n    \n        \n    \n\nelse:\n    print(\"War\")\n\n\n            \n", "pass": false}
{"task_id": "4241", "program": "def min_changes_to_substring(S, T):\n    len_s = len(S)\n    len_t = len(T)\n    min_changes = float('inf')\n    \n    for i in range(len_s - len_t + 1):\n        current_changes = 0\n        for j in range(len_t):\n            if S[i + j] != T[j]:\n                current_changes += 1\n        min_changes = min(min_changes, current_changes)\n    \n    return min_changes\n\n# Read input\nS = input().strip()\nT = input().strip()\n\n# Calculate and print the minimum number of changes\nprint(min_changes_to_substring(S, T))", "problem": "Given are two strings S and T.\nLet us change some of the characters in S so that T will be a substring of S.\nAt least how many characters do we need to change?\nHere, a substring is a consecutive subsequence. For example, xxx is a substring of yxxxy, but not a substring of xxyxx.\n\n-----Constraints-----\n - The lengths of S and T are each at least 1 and at most 1000.\n - The length of T is at most that of S.\n - S and T consist of lowercase English letters.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nS\nT\n\n-----Output-----\nPrint the minimum number of characters in S that need to be changed.\n\n-----Sample Input-----\ncabacc\nabc\n\n-----Sample Output-----\n1\n\nFor example, changing the fourth character a in S to c will match the second through fourth characters in S to T.\nSince S itself does not have T as its substring, this number of changes - one - is the minimum needed.", "solution": "a=input()\nb=input()\nc = len(a)-len(b)\nd=[]\nfor i in range(len(a)-len(b)+1):\n    a[i:i+len(b)]\n    count = 0\n    for j in range(len(b)):\n        if a[i:i+len(b)][j] == b[j]:\n              count +=1\n    d.append(len(b)-count)\nprint(min(d))    ", "pass": true}
{"task_id": "4258", "program": "# Read input values\nA, B, T = map(int, input().split())\n\n# Calculate the number of multiples of A within T + 0.5 seconds\nnum_multiples = (T + 0.5) // A\n\n# Calculate the total number of biscuits produced\ntotal_biscuits = int(num_multiples) * B\n\n# Print the result\nprint(total_biscuits)", "problem": "A biscuit making machine produces B biscuits at the following moments: A seconds, 2A seconds, 3A seconds and each subsequent multiple of A seconds after activation.\nFind the total number of biscuits produced within T + 0.5 seconds after activation.\n\n-----Constraints-----\n - All values in input are integers.\n - 1 \\leq A, B, T \\leq 20\n\n-----Input-----\nInput is given from Standard Input in the following format:\nA B T\n\n-----Output-----\nPrint the total number of biscuits produced within T + 0.5 seconds after activation.\n\n-----Sample Input-----\n3 5 7\n\n-----Sample Output-----\n10\n\n - Five biscuits will be produced three seconds after activation.\n - Another five biscuits will be produced six seconds after activation.\n - Thus, a total of ten biscuits will be produced within 7.5 seconds after activation.", "solution": "a,b,t = list(map(int,input().split()))\n\nprint(((t//a) * b))\n", "pass": true}
{"task_id": "4386", "program": "a = int(input())\ns = input()\n\nif a >= 3200:\n    print(s)\nelse:\n    print(\"red\")", "problem": "You will be given an integer a and a string s consisting of lowercase English letters as input.\nWrite a program that prints s if a is not less than 3200 and prints red if a is less than 3200.\n\n-----Constraints-----\n - 2800 \\leq a < 5000\n - s is a string of length between 1 and 10 (inclusive).\n - Each character of s is a lowercase English letter.\n\n-----Input-----\nInput is given from Standard Input in the following format:\na\ns\n\n-----Output-----\nIf a is not less than 3200, print s; if a is less than 3200, print red.\n\n-----Sample Input-----\n3200\npink\n\n-----Sample Output-----\npink\n\na = 3200 is not less than 3200, so we print s = pink.", "solution": "a = int(input())\ns = str(input())\n \nif a >= 3200:\n    print(s)\nelse:\n    print('red')", "pass": true}
{"task_id": "4395", "program": "def min_recolors(n, s):\n    patterns = [\"RGB\", \"RBG\", \"GRB\", \"GBR\", \"BRG\", \"BGR\"]\n    min_recolors = float('inf')\n    best_pattern = \"\"\n    \n    for pattern in patterns:\n        recolors = 0\n        new_s = []\n        for i in range(n):\n            if s[i] != pattern[i % 3]:\n                recolors += 1\n            new_s.append(pattern[i % 3])\n        \n        if recolors < min_recolors:\n            min_recolors = recolors\n            best_pattern = ''.join(new_s)\n    \n    return min_recolors, best_pattern\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\ns = data[1]\n\n# Get the result\nrecolors, result = min_recolors(n, s)\n\n# Print the result\nprint(recolors)\nprint(result)", "problem": "You have a garland consisting of $n$ lamps. Each lamp is colored red, green or blue. The color of the $i$-th lamp is $s_i$ ('R', 'G' and 'B' \u2014 colors of lamps in the garland).\n\nYou have to recolor some lamps in this garland (recoloring a lamp means changing its initial color to another) in such a way that the obtained garland is nice.\n\nA garland is called nice if any two lamps of the same color have distance divisible by three between them. I.e. if the obtained garland is $t$, then for each $i, j$ such that $t_i = t_j$ should be satisfied $|i-j|~ mod~ 3 = 0$. The value $|x|$ means absolute value of $x$, the operation $x~ mod~ y$ means remainder of $x$ when divided by $y$.\n\nFor example, the following garlands are nice: \"RGBRGBRG\", \"GB\", \"R\", \"GRBGRBG\", \"BRGBRGB\". The following garlands are not nice: \"RR\", \"RGBG\".\n\nAmong all ways to recolor the initial garland to make it nice you have to choose one with the minimum number of recolored lamps. If there are multiple optimal solutions, print any of them.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of lamps.\n\nThe second line of the input contains the string $s$ consisting of $n$ characters 'R', 'G' and 'B' \u2014 colors of lamps in the garland.\n\n\n-----Output-----\n\nIn the first line of the output print one integer $r$ \u2014 the minimum number of recolors needed to obtain a nice garland from the given one.\n\nIn the second line of the output print one string $t$ of length $n$ \u2014 a nice garland obtained from the initial one with minimum number of recolors. If there are multiple optimal solutions, print any of them.\n\n\n-----Examples-----\nInput\n3\nBRB\n\nOutput\n1\nGRB\n\nInput\n7\nRGBGRBB\n\nOutput\n3\nRGBRGBR", "solution": "n = int(input())\ns = input()\nbest = -1\nans = 10 ** 6\nper = ['RGB', 'RBG', 'BRG', 'BGR', 'GBR', 'GRB']\nfor idx, p in enumerate(per):\n\ttmp = 0\n\tfor i in range(n):\n\t\tif s[i] != p[i % 3]:\n\t\t\ttmp += 1\n\tif tmp < ans:\n\t\tans = tmp\n\t\tbest = idx\nout = per[best] * (n // 3) + per[best][:(n % 3)]\nprint(ans)\nprint(out)", "pass": true}
{"task_id": "4446", "program": "def max_points(n, a, b, k, h):\n    # Calculate the number of hits needed for each monster\n    hits_needed = []\n    for hp in h:\n        # Calculate the total cycle damage\n        cycle_damage = a + b\n        # Calculate the remaining health after full cycles\n        remaining_health = hp % cycle_damage\n        if remaining_health == 0:\n            remaining_health = cycle_damage\n        \n        # Calculate the number of hits needed to kill the monster\n        if remaining_health <= a:\n            hits_needed.append(0)\n        else:\n            hits_needed.append((remaining_health - 1) // a)\n    \n    # Sort the hits needed in ascending order\n    hits_needed.sort()\n    \n    # Calculate the maximum points\n    points = 0\n    for hits in hits_needed:\n        if k >= hits:\n            k -= hits\n            points += 1\n        else:\n            break\n    \n    return points\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = int(data[1])\nb = int(data[2])\nk = int(data[3])\nh = list(map(int, data[4:]))\n\n# Calculate and print the result\nprint(max_points(n, a, b, k, h))", "problem": "There are $n$ monsters standing in a row numbered from $1$ to $n$. The $i$-th monster has $h_i$ health points (hp). You have your attack power equal to $a$ hp and your opponent has his attack power equal to $b$ hp.\n\nYou and your opponent are fighting these monsters. Firstly, you and your opponent go to the first monster and fight it till his death, then you and your opponent go the second monster and fight it till his death, and so on. A monster is considered dead if its hp is less than or equal to $0$.\n\nThe fight with a monster happens in turns.   You hit the monster by $a$ hp. If it is dead after your hit, you gain one point and you both proceed to the next monster.  Your opponent hits the monster by $b$ hp. If it is dead after his hit, nobody gains a point and you both proceed to the next monster. \n\nYou have some secret technique to force your opponent to skip his turn. You can use this technique at most $k$ times in total (for example, if there are two monsters and $k=4$, then you can use the technique $2$ times on the first monster and $1$ time on the second monster, but not $2$ times on the first monster and $3$ times on the second monster).\n\nYour task is to determine the maximum number of points you can gain if you use the secret technique optimally.\n\n\n-----Input-----\n\nThe first line of the input contains four integers $n, a, b$ and $k$ ($1 \\le n \\le 2 \\cdot 10^5, 1 \\le a, b, k \\le 10^9$) \u2014 the number of monsters, your attack power, the opponent's attack power and the number of times you can use the secret technique.\n\nThe second line of the input contains $n$ integers $h_1, h_2, \\dots, h_n$ ($1 \\le h_i \\le 10^9$), where $h_i$ is the health points of the $i$-th monster.\n\n\n-----Output-----\n\nPrint one integer \u2014 the maximum number of points you can gain if you use the secret technique optimally.\n\n\n-----Examples-----\nInput\n6 2 3 3\n7 10 50 12 1 8\n\nOutput\n5\n\nInput\n1 1 100 99\n100\n\nOutput\n1\n\nInput\n7 4 2 1\n1 3 5 4 2 7 6\n\nOutput\n6", "solution": "from math import *\n\nn, a, b, k = list(map(int, input().split()))\nh = [int(i) for i in input().split()]\n\nans = n\nnh = []\nfor m in h:\n    tr = max(0, (m - 1) // (a+b))\n    m -= tr*(a+b)\n    m -= a\n    if m > 0:\n        nh.append(m)\n        ans -= 1\n\nnh.sort()\ni = 0\nwhile k > 0 and i < len(nh):\n    k -= ceil(nh[i]/a)\n    if k < 0:\n        break\n    i += 1\n    ans += 1\n\nprint(ans)\n", "pass": true}
{"task_id": "4486", "program": "s = input().strip()\nresult = s[0::2]\nprint(result)", "problem": "You are given a string s consisting of lowercase English letters. Extract all the characters in the odd-indexed positions and print the string obtained by concatenating them. Here, the leftmost character is assigned the index 1.\n\n-----Constraints-----\n - Each character in s is a lowercase English letter.\n - 1\u2264|s|\u226410^5\n\n-----Input-----\nThe input is given from Standard Input in the following format:\ns\n\n-----Output-----\nPrint the string obtained by concatenating all the characters in the odd-numbered positions.\n\n-----Sample Input-----\natcoder\n\n-----Sample Output-----\nacdr\n\nExtract the first character a, the third character c, the fifth character d and the seventh character r to obtain acdr.", "solution": "s = input()\n# \u30ea\u30b9\u30c8\uff53\u30921\u3064\u304a\u304d\u306b\u30b9\u30e9\u30a4\u30b9\nprint(s[0::2])", "pass": true}
{"task_id": "4516", "program": "def calculate_f_values(n, m, x):\n    # Initialize the result array\n    f_values = [0] * n\n\n    # Calculate the initial distances for the identity permutation\n    for i in range(m - 1):\n        f_values[0] += abs(x[i] - x[i + 1])\n\n    # Calculate the distances for the other permutations\n    for i in range(1, n):\n        f_values[i] = f_values[0]\n        for j in range(m - 1):\n            if x[j] == i + 1:\n                f_values[i] -= abs(x[j] - x[j + 1])\n                f_values[i] += abs(1 - x[j + 1])\n            if x[j + 1] == i + 1:\n                f_values[i] -= abs(x[j] - x[j + 1])\n                f_values[i] += abs(x[j] - 1)\n\n    return f_values\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nx = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = calculate_f_values(n, m, x)\nprint(' '.join(map(str, result)))", "problem": "Let's define $p_i(n)$ as the following permutation: $[i, 1, 2, \\dots, i - 1, i + 1, \\dots, n]$. This means that the $i$-th permutation is almost identity (i.e. which maps every element to itself) permutation but the element $i$ is on the first position. Examples:  $p_1(4) = [1, 2, 3, 4]$;  $p_2(4) = [2, 1, 3, 4]$;  $p_3(4) = [3, 1, 2, 4]$;  $p_4(4) = [4, 1, 2, 3]$. \n\nYou are given an array $x_1, x_2, \\dots, x_m$ ($1 \\le x_i \\le n$).\n\nLet $pos(p, val)$ be the position of the element $val$ in $p$. So, $pos(p_1(4), 3) = 3, pos(p_2(4), 2) = 1, pos(p_4(4), 4) = 1$.\n\nLet's define a function $f(p) = \\sum\\limits_{i=1}^{m - 1} |pos(p, x_i) - pos(p, x_{i + 1})|$, where $|val|$ is the absolute value of $val$. This function means the sum of distances between adjacent elements of $x$ in $p$.\n\nYour task is to calculate $f(p_1(n)), f(p_2(n)), \\dots, f(p_n(n))$.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $m$ ($2 \\le n, m \\le 2 \\cdot 10^5$) \u2014 the number of elements in each permutation and the number of elements in $x$.\n\nThe second line of the input contains $m$ integers ($m$, not $n$) $x_1, x_2, \\dots, x_m$ ($1 \\le x_i \\le n$), where $x_i$ is the $i$-th element of $x$. Elements of $x$ can repeat and appear in arbitrary order.\n\n\n-----Output-----\n\nPrint $n$ integers: $f(p_1(n)), f(p_2(n)), \\dots, f(p_n(n))$.\n\n\n-----Examples-----\nInput\n4 4\n1 2 3 4\n\nOutput\n3 4 6 5 \n\nInput\n5 5\n2 1 5 3 5\n\nOutput\n9 8 12 6 8 \n\nInput\n2 10\n1 2 1 1 2 2 2 2 2 2\n\nOutput\n3 3 \n\n\n\n-----Note-----\n\nConsider the first example:\n\n$x = [1, 2, 3, 4]$, so  for the permutation $p_1(4) = [1, 2, 3, 4]$ the answer is $|1 - 2| + |2 - 3| + |3 - 4| = 3$;  for the permutation $p_2(4) = [2, 1, 3, 4]$ the answer is $|2 - 1| + |1 - 3| + |3 - 4| = 4$;  for the permutation $p_3(4) = [3, 1, 2, 4]$ the answer is $|2 - 3| + |3 - 1| + |1 - 4| = 6$;  for the permutation $p_4(4) = [4, 1, 2, 3]$ the answer is $|2 - 3| + |3 - 4| + |4 - 1| = 5$. \n\nConsider the second example:\n\n$x = [2, 1, 5, 3, 5]$, so  for the permutation $p_1(5) = [1, 2, 3, 4, 5]$ the answer is $|2 - 1| + |1 - 5| + |5 - 3| + |3 - 5| = 9$;  for the permutation $p_2(5) = [2, 1, 3, 4, 5]$ the answer is $|1 - 2| + |2 - 5| + |5 - 3| + |3 - 5| = 8$;  for the permutation $p_3(5) = [3, 1, 2, 4, 5]$ the answer is $|3 - 2| + |2 - 5| + |5 - 1| + |1 - 5| = 12$;  for the permutation $p_4(5) = [4, 1, 2, 3, 5]$ the answer is $|3 - 2| + |2 - 5| + |5 - 4| + |4 - 5| = 6$;  for the permutation $p_5(5) = [5, 1, 2, 3, 4]$ the answer is $|3 - 2| + |2 - 1| + |1 - 4| + |4 - 1| = 8$.", "solution": "f=[]\n\ndef mdy(l,r,x):\n\tf[l]+=x\n\tf[r+1]-=x\n\nn,m=map(int,input().split())\n\nP=list(range(n+2))\n\nfor i in range(n+5):\n\tf.append(0)\n\na=list(map(int,input().split()))\n\nfor i in range(m-1):\n\tl=a[i]\n\tr=a[i+1]\n\tif l==r:\n\t\tcontinue\n\tif l>r:\n\t\t(l,r)=(r,l)\n\tmdy(1,l-1,r-l)\n\tmdy(l,l,r-1)\n\tmdy(l+1,r-1,r-l-1)\n\tmdy(r,r,l)\n\tmdy(r+1,n,r-l)\n\nfor i in P[1:n+1]:\n\tf[i]+=f[i-1]\n\tprint(f[i],end=\" \")", "pass": false}
{"task_id": "4544", "program": "def maximize_count(N, a):\n    from collections import defaultdict\n\n    # Create a dictionary to count occurrences of each number and its neighbors\n    count = defaultdict(int)\n    \n    for num in a:\n        count[num] += 1\n        count[num - 1] += 1\n        count[num + 1] += 1\n    \n    # Find the maximum count\n    max_count = max(count.values())\n    \n    return max_count\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\na = list(map(int, data[1:]))\n\n# Get the result and print it\nresult = maximize_count(N, a)\nprint(result)", "problem": "You are given an integer sequence of length N, a_1,a_2,...,a_N.\nFor each 1\u2264i\u2264N, you have three choices: add 1 to a_i, subtract 1 from a_i or do nothing.\nAfter these operations, you select an integer X and count the number of i such that a_i=X.\nMaximize this count by making optimal choices.\n\n-----Constraints-----\n - 1\u2264N\u226410^5\n - 0\u2264a_i<10^5 (1\u2264i\u2264N)\n - a_i is an integer.\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN\na_1 a_2 .. a_N\n\n-----Output-----\nPrint the maximum possible number of i such that a_i=X.\n\n-----Sample Input-----\n7\n3 1 4 1 5 9 2\n\n-----Sample Output-----\n4\n\nFor example, turn the sequence into 2,2,3,2,6,9,2 and select X=2 to obtain 4, the maximum possible count.", "solution": "n = int(input())\na = [int(x) for x in input().split()]\na.sort()\n\np = [0] * (max(a) + 5)\n\nfor i in range(n):\n  p[a[i]+1] += 1\n  \nres = 0\nfor i in range(min(a),max(a)+1):\n  res = max(res, p[i] + p[i+1] + p[i+2])\n\nprint(res)", "pass": true}
{"task_id": "4563", "program": "import math\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    ratios = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)]\n    \n    t, a = ratios[0]\n    \n    for i in range(1, N):\n        T, A = ratios[i]\n        k = max((t + T - 1) // T, (a + A - 1) // A)\n        t = k * T\n        a = k * A\n    \n    print(t + a)\n\nif __name__ == \"__main__\":\n    main()", "problem": "AtCoDeer the deer is seeing a quick report of election results on TV.\nTwo candidates are standing for the election: Takahashi and Aoki.\nThe report shows the ratio of the current numbers of votes the two candidates have obtained, but not the actual numbers of votes.\nAtCoDeer has checked the report N times, and when he checked it for the i-th (1\u2266i\u2266N) time, the ratio was T_i:A_i.\nIt is known that each candidate had at least one vote when he checked the report for the first time.\nFind the minimum possible total number of votes obtained by the two candidates when he checked the report for the N-th time.\nIt can be assumed that the number of votes obtained by each candidate never decreases.\n\n-----Constraints-----\n - 1\u2266N\u22661000\n - 1\u2266T_i,A_i\u22661000 (1\u2266i\u2266N)\n - T_i and A_i (1\u2266i\u2266N) are coprime.\n - It is guaranteed that the correct answer is at most 10^{18}.\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN\nT_1 A_1\nT_2 A_2\n:\nT_N A_N\n\n-----Output-----\nPrint the minimum possible total number of votes obtained by Takahashi and Aoki when AtCoDeer checked the report for the N-th time.\n\n-----Sample Input-----\n3\n2 3\n1 1\n3 2\n\n-----Sample Output-----\n10\n\nWhen the numbers of votes obtained by the two candidates change as 2,3 \u2192 3,3 \u2192 6,4, the total number of votes at the end is 10, which is the minimum possible number.", "solution": "n = int(input())\nt,a = 1,1\nimport math\nfor _ in range(n):\n    T,A = map(int,input().split())\n    k=(T+t-1)//T\n    m=(A+a-1)//A\n    x=max(k,m)\n    t,a = x*T,x*A\nprint(t+a)", "pass": false}
{"task_id": "4590", "program": "def max_books(N, M, K, A, B):\n    # Calculate prefix sums for both desks\n    prefix_A = [0] * (N + 1)\n    prefix_B = [0] * (M + 1)\n    \n    for i in range(1, N + 1):\n        prefix_A[i] = prefix_A[i - 1] + A[i - 1]\n    \n    for i in range(1, M + 1):\n        prefix_B[i] = prefix_B[i - 1] + B[i - 1]\n    \n    # Initialize the maximum number of books read\n    max_books_read = 0\n    \n    # Try reading i books from desk A and the rest from desk B\n    j = M\n    for i in range(N + 1):\n        if prefix_A[i] > K:\n            break\n        while j > 0 and prefix_A[i] + prefix_B[j] > K:\n            j -= 1\n        max_books_read = max(max_books_read, i + j)\n    \n    return max_books_read\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:3+N]))\nB = list(map(int, data[3+N:]))\n\n# Output the result\nprint(max_books(N, M, K, A, B))", "problem": "We have two desks: A and B. Desk A has a vertical stack of N books on it, and Desk B similarly has M books on it.\nIt takes us A_i minutes to read the i-th book from the top on Desk A (1 \\leq i \\leq N), and B_i minutes to read the i-th book from the top on Desk B (1 \\leq i \\leq M).\nConsider the following action:\n - Choose a desk with a book remaining, read the topmost book on that desk, and remove it from the desk.\nHow many books can we read at most by repeating this action so that it takes us at most K minutes in total? We ignore the time it takes to do anything other than reading.\n\n-----Constraints-----\n - 1 \\leq N, M \\leq 200000\n - 1 \\leq K \\leq 10^9\n - 1 \\leq A_i, B_i \\leq 10^9\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M K\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_M\n\n-----Output-----\nPrint an integer representing the maximum number of books that can be read.\n\n-----Sample Input-----\n3 4 240\n60 90 120\n80 150 80 150\n\n-----Sample Output-----\n3\n\nIn this case, it takes us 60, 90, 120 minutes to read the 1-st, 2-nd, 3-rd books from the top on Desk A, and 80, 150, 80, 150 minutes to read the 1-st, 2-nd, 3-rd, 4-th books from the top on Desk B, respectively.\nWe can read three books in 230 minutes, as shown below, and this is the maximum number of books we can read within 240 minutes.\n - Read the topmost book on Desk A in 60 minutes, and remove that book from the desk.\n - Read the topmost book on Desk B in 80 minutes, and remove that book from the desk.\n - Read the topmost book on Desk A in 90 minutes, and remove that book from the desk.", "solution": "from bisect import *\nn,m,k = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\n# A\u306e\u7d2f\u7a4d\u548c\u3092\u4fdd\u5b58\u3057\u3066\u304a\u304f\n# \u5404A\u306e\u8981\u7d20\u306b\u3064\u3044\u3066\u3001B\u304c\u4f55\u518a\u8aad\u3081\u308b\u304b\u4e8c\u5206\u63a2\u7d22\u3059\u308b\u3002\n# \u8a08\u7b97\u91cf: AlogB\nA.insert(0, 0)\n\nfor i in range(1,len(A)):\n  A[i] += A[i-1]\nfor i in range(1, len(B)):\n  B[i] += B[i-1]\n\nans = 0\nfor i in range(len(A)):\n  rest_time = k - A[i]\n  if rest_time >= 0:\n    numb = bisect_right(B, rest_time)\n    anstmp = i + numb \n    ans = max(ans, anstmp)\nprint(ans)", "pass": true}
{"task_id": "4606", "program": "# Read the input value\nN = int(input().strip())\n\n# Print the abbreviation for the N-th round of ABC\nprint(f\"ABC{N}\")", "problem": "This contest, AtCoder Beginner Contest, is abbreviated as ABC.\nWhen we refer to a specific round of ABC, a three-digit number is appended after ABC. For example, ABC680 is the 680th round of ABC.\nWhat is the abbreviation for the N-th round of ABC? Write a program to output the answer.\n\n-----Constraints-----\n - 100 \u2264 N \u2264 999\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\n\n-----Output-----\nPrint the abbreviation for the N-th round of ABC.\n\n-----Sample Input-----\n100\n\n-----Sample Output-----\nABC100\n\nThe 100th round of ABC is ABC100.", "solution": "print(\"ABC\"+input())", "pass": true}
{"task_id": "4654", "program": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        \n        # Check for odd numbers\n        if n >= k and (n % 2 == k % 2):\n            results.append(\"YES\")\n            results.append(\"1 \" * (k - 1) + str(n - (k - 1)))\n        # Check for even numbers\n        elif n >= 2 * k and (n % 2 == 0):\n            results.append(\"YES\")\n            results.append(\"2 \" * (k - 1) + str(n - 2 * (k - 1)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nsolve()", "problem": "You are given two positive integers $n$ ($1 \\le n \\le 10^9$) and $k$ ($1 \\le k \\le 100$). Represent the number $n$ as the sum of $k$ positive integers of the same parity (have the same remainder when divided by $2$).\n\nIn other words, find $a_1, a_2, \\ldots, a_k$ such that all $a_i>0$, $n = a_1 + a_2 + \\ldots + a_k$ and either all $a_i$ are even or all $a_i$ are odd at the same time.\n\nIf such a representation does not exist, then report it.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases in the input. Next, $t$ test cases are given, one per line.\n\nEach test case is two positive integers $n$ ($1 \\le n \\le 10^9$) and $k$ ($1 \\le k \\le 100$).\n\n\n-----Output-----\n\nFor each test case print:\n\n  YES and the required values $a_i$, if the answer exists (if there are several answers, print any of them);  NO if the answer does not exist. \n\nThe letters in the words YES and NO can be printed in any case.\n\n\n-----Example-----\nInput\n8\n10 3\n100 4\n8 7\n97 2\n8 8\n3 10\n5 3\n1000000000 9\n\nOutput\nYES\n4 2 4\nYES\n55 5 5 35\nNO\nNO\nYES\n1 1 1 1 1 1 1 1\nNO\nYES\n3 1 1\nYES\n111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111120", "solution": "import sys\nimport os\nimport time\nimport collections\nfrom collections import Counter, deque\nimport itertools\nimport math\nimport timeit\nimport random\nimport string\n\n#########################\n# imgur.com/Pkt7iIf.png #\n#########################\n\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\n\ndef divs(n, start=1):\n    divisors = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            if n / i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n    return divisors\n\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\n\ndef flin(d, x, default=-1):\n    left = right = -1\n    for i in range(len(d)):\n        if d[i] == x:\n            if left == -1: left = i\n            right = i\n    if left == -1:\n        return default, default\n    else:\n        return left, right\n\ndef ceil(n, k): return n // k + (n % k != 0)\ndef ii(): return int(input())\ndef mi(): return list(map(int, input().split()))\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef prr(a, sep=' '): print(sep.join(map(str, a)))\ndef dd(): return collections.defaultdict(int)\ndef ddl(): return collections.defaultdict(list)\n\n########################################################################################################################\n# input = sys.stdin.readline\n\nfor _ in range(ii()):\n    n, k = mi()\n    even = n - 2*(k - 1)\n    odd = n - (k - 1)\n    if odd > 0 and odd % 2:\n        res = [1]*(k - 1) + [odd]\n        print('YES')\n        prr(res, ' ')\n    elif even > 0 and even % 2 == 0:\n        res = [2] * (k - 1) + [even]\n        print('YES')\n        prr(res, ' ')\n    else:\n        print('NO')\n", "pass": true}
{"task_id": "4682", "program": "# Read input values\na = int(input())\nb = int(input())\nh = int(input())\n\n# Calculate the area of the trapezoid\narea = (a + b) * h // 2\n\n# Print the area\nprint(area)", "problem": "You are given a trapezoid. The lengths of its upper base, lower base, and height are a, b, and h, respectively.\nAn example of a trapezoid\nFind the area of this trapezoid.\n\n-----Constraints-----\n - 1\u2266a\u2266100\n - 1\u2266b\u2266100\n - 1\u2266h\u2266100\n - All input values are integers.\n - h is even.\n\n-----Input-----\nThe input is given from Standard Input in the following format:\na\nb\nh\n\n-----Output-----\nPrint the area of the given trapezoid. It is guaranteed that the area is an integer.\n\n-----Sample Input-----\n3\n4\n2\n\n-----Sample Output-----\n7\n\nWhen the lengths of the upper base, lower base, and height are 3, 4, and 2, respectively, the area of the trapezoid is (3+4)\u00d72/2 = 7.", "solution": "a = int(input())\nb = int(input())\nh = int(input())\nz =int((a + b)*h/2)\nprint(z)", "pass": true}
{"task_id": "4707", "program": "# Read the input\ns = input().strip()\n\n# Count the number of '1's in the input string\ncount_of_ones = s.count('1')\n\n# Print the result\nprint(count_of_ones)", "problem": "Snuke has a grid consisting of three squares numbered 1, 2 and 3.\nIn each square, either 0 or 1 is written. The number written in Square i is s_i.\nSnuke will place a marble on each square that says 1.\nFind the number of squares on which Snuke will place a marble.\n\n-----Constraints-----\n - Each of s_1, s_2 and s_3 is either 1 or 0.\n\n-----Input-----\nInput is given from Standard Input in the following format:\ns_{1}s_{2}s_{3}\n\n-----Output-----\nPrint the answer.\n\n-----Sample Input-----\n101\n\n-----Sample Output-----\n2\n\n - A marble will be placed on Square 1 and 3.", "solution": "import bisect,collections,copy,heapq,itertools,math,string\nimport sys\ndef I():\n    # 1 line 1 int\n    return int(sys.stdin.readline().rstrip())\ndef LI():\n    # 1 line n ints\n    return list(map(int,sys.stdin.readline().rstrip().split()))\ndef S():\n    # 1 line 1 string\n    return sys.stdin.readline().rstrip()\ndef LS():\n    # 1 line n strings\n    return list(sys.stdin.readline().rstrip().split())\n\nx = S()\n\ncount = 0\nfor s in x:\n    if s == \"1\":\n        count += 1\n\nprint(count)", "pass": true}
